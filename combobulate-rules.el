;; START Production rules for yaml
(defconst combobulate-rules-yaml 
 '(("alias" (:*unnamed* ("alias_name"))) 
 ("alias_name" (:*unnamed* nil)) 
 ("anchor" (:*unnamed* ("anchor_name"))) 
 ("anchor_name" (:*unnamed* nil)) 
 ("block_mapping" (:*unnamed* ("block_mapping_pair"))) 
 ("block_mapping_pair" (:*unnamed* nil :key ("flow_node" "block_node") :value ("flow_node" "block_node"))) 
 ("block_node" (:*unnamed* ("tag" "block_scalar" "anchor" "block_sequence" "block_mapping"))) 
 ("block_scalar" (:*unnamed* nil)) 
 ("block_sequence" (:*unnamed* ("block_sequence_item"))) 
 ("block_sequence_item" (:*unnamed* ("flow_node" "block_node"))) 
 ("boolean_scalar" (:*unnamed* nil)) 
 ("comment" (:*unnamed* nil)) 
 ("directive_name" (:*unnamed* nil)) 
 ("directive_parameter" (:*unnamed* nil)) 
 ("document" (:*unnamed* ("yaml_directive" "flow_node" "tag_directive" "block_node" "reserved_directive"))) 
 ("double_quote_scalar" (:*unnamed* ("escape_sequence"))) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("float_scalar" (:*unnamed* nil)) 
 ("flow_mapping" (:*unnamed* ("flow_pair" "flow_node"))) 
 ("flow_node" (:*unnamed* ("flow_sequence" "anchor" "double_quote_scalar" "single_quote_scalar" "tag" "plain_scalar" "flow_mapping" "alias"))) 
 ("flow_pair" (:*unnamed* nil :key ("flow_node") :value ("flow_node"))) 
 ("flow_sequence" (:*unnamed* ("flow_pair" "flow_node"))) 
 ("integer_scalar" (:*unnamed* nil)) 
 ("null_scalar" (:*unnamed* nil)) 
 ("plain_scalar" (:*unnamed* ("boolean_scalar" "float_scalar" "integer_scalar" "null_scalar" "string_scalar"))) 
 ("reserved_directive" (:*unnamed* ("directive_name" "directive_parameter"))) 
 ("single_quote_scalar" (:*unnamed* ("escape_sequence"))) 
 ("stream" (:*unnamed* ("document"))) 
 ("string_scalar" (:*unnamed* nil)) 
 ("tag" (:*unnamed* nil)) 
 ("tag_directive" (:*unnamed* ("tag_prefix" "tag_handle"))) 
 ("tag_handle" (:*unnamed* nil)) 
 ("tag_prefix" (:*unnamed* nil)) 
 ("yaml_directive" (:*unnamed* ("yaml_version"))) 
 ("yaml_version" (:*unnamed* nil)) 
))
;; END Production rules for yaml
;; START Inverse production rules for yaml
(defconst combobulate-rules-yaml-inverse 
 '(("alias" ("flow_node"))
   ("alias_name" ("alias"))
   ("anchor" ("flow_node" "block_node"))
   ("anchor_name" ("anchor"))
   ("block_mapping" ("block_node"))
   ("block_mapping_pair" ("block_mapping"))
   ("block_node" ("block_sequence_item" "block_mapping_pair" "document"))
   ("block_scalar" ("block_node"))
   ("block_sequence" ("block_node"))
   ("block_sequence_item" ("block_sequence"))
   ("boolean_scalar" ("plain_scalar"))
   ("directive_name" ("reserved_directive"))
   ("directive_parameter" ("reserved_directive"))
   ("document" ("stream"))
   ("double_quote_scalar" ("flow_node"))
   ("escape_sequence" ("double_quote_scalar" "single_quote_scalar"))
   ("float_scalar" ("plain_scalar"))
   ("flow_mapping" ("flow_node"))
   ("flow_node" ("flow_sequence" "block_sequence_item" "flow_pair" "block_mapping_pair" "flow_mapping" "document"))
   ("flow_pair" ("flow_sequence" "flow_mapping"))
   ("flow_sequence" ("flow_node"))
   ("integer_scalar" ("plain_scalar"))
   ("null_scalar" ("plain_scalar"))
   ("plain_scalar" ("flow_node"))
   ("reserved_directive" ("document"))
   ("single_quote_scalar" ("flow_node"))
   ("string_scalar" ("plain_scalar"))
   ("tag" ("flow_node" "block_node"))
   ("tag_directive" ("document"))
   ("tag_handle" ("tag_directive"))
   ("tag_prefix" ("tag_directive"))
   ("yaml_directive" ("document"))
   ("yaml_version" ("yaml_directive"))
  ) 
)
;; END Inverse production rules for yaml
;; START All node types in yaml
(defconst combobulate-rules-yaml-types 
 '("alias" "alias_name" "anchor" "anchor_name" "block_mapping" "block_mapping_pair" "block_node" "block_scalar" "block_sequence" "block_sequence_item" "boolean_scalar" "comment" "directive_name" "directive_parameter" "document" "double_quote_scalar" "escape_sequence" "float_scalar" "flow_mapping" "flow_node" "flow_pair" "flow_sequence" "integer_scalar" "null_scalar" "plain_scalar" "reserved_directive" "single_quote_scalar" "stream" "string_scalar" "tag" "tag_directive" "tag_handle" "tag_prefix" "yaml_directive" "yaml_version") 
)
;; END All node types in yaml
;; START All supertypes in yaml
(defconst combobulate-rules-yaml-supertypes 
 nil 
)
;; END All supertypes in yaml

;; START Production rules for tsx
(defconst combobulate-rules-tsx 
 '(("_primary_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("abstract_class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("abstract_method_signature" (:*unnamed* ("accessibility_modifier") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("accessibility_modifier" (:*unnamed* nil)) 
 ("ambient_declaration" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "declaration" "array_type" "property_identifier" "type_identifier" "constructor_type" "statement_block" "readonly_type" "flow_maybe_type"))) 
 ("arguments" (:*unnamed* ("expression" "spread_element"))) 
 ("array" (:*unnamed* ("expression" "spread_element"))) 
 ("array_pattern" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("array_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("arrow_function" (:*unnamed* nil :body ("expression" "statement_block") :parameter ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("as_expression" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "expression" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("asserts" (:*unnamed* ("identifier" "this" "type_predicate"))) 
 ("asserts_annotation" (:*unnamed* ("asserts"))) 
 ("assignment_expression" (:*unnamed* nil :left ("array_pattern" "undefined" "identifier" "non_null_expression" "member_expression" "subscript_expression" "object_pattern" "parenthesized_expression") :right ("expression"))) 
 ("assignment_pattern" (:*unnamed* nil :left ("pattern") :right ("expression"))) 
 ("augmented_assignment_expression" (:*unnamed* nil :left ("member_expression" "parenthesized_expression" "identifier" "subscript_expression" "non_null_expression") :operator nil :right ("expression"))) 
 ("await_expression" (:*unnamed* ("expression"))) 
 ("binary_expression" (:*unnamed* nil :left ("expression") :operator nil :right ("expression"))) 
 ("break_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("call_expression" (:*unnamed* nil :arguments ("template_string" "arguments") :function ("expression") :type_arguments ("type_arguments"))) 
 ("call_signature" (:*unnamed* nil :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("catch_clause" (:*unnamed* nil :body ("statement_block") :parameter ("identifier" "array_pattern" "object_pattern") :type ("type_annotation"))) 
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("class_body" (:*unnamed* ("public_field_definition" "method_definition" "index_signature" "method_signature" "abstract_method_signature" "class_static_block" "decorator"))) 
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("class_heritage" (:*unnamed* ("extends_clause" "implements_clause"))) 
 ("class_static_block" (:*unnamed* nil :body ("statement_block"))) 
 ("comment" (:*unnamed* nil)) 
 ("computed_property_name" (:*unnamed* ("expression"))) 
 ("conditional_type" (:*unnamed* nil :alternative ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :consequence ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :left ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :right ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("constraint" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("construct_signature" (:*unnamed* nil :parameters ("formal_parameters") :type ("type_annotation") :type_parameters ("type_parameters"))) 
 ("constructor_type" (:*unnamed* nil :parameters ("formal_parameters") :type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :type_parameters ("type_parameters"))) 
 ("continue_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("debugger_statement" (:*unnamed* nil)) 
 ("declaration" (:*unnamed* ("interface_declaration" "ambient_declaration" "module" "class_declaration" "enum_declaration" "lexical_declaration" "function_declaration" "abstract_class_declaration" "function_signature" "internal_module" "import_alias" "variable_declaration" "type_alias_declaration" "generator_function_declaration"))) 
 ("decorator" (:*unnamed* ("member_expression" "identifier" "call_expression"))) 
 ("default_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("do_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("statement"))) 
 ("empty_statement" (:*unnamed* nil)) 
 ("enum_assignment" (:*unnamed* nil :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("expression"))) 
 ("enum_body" (:*unnamed* ("enum_assignment") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number"))) 
 ("enum_declaration" (:*unnamed* nil :body ("enum_body") :name ("identifier"))) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("existential_type" (:*unnamed* nil)) 
 ("export_clause" (:*unnamed* ("export_specifier"))) 
 ("export_specifier" (:*unnamed* nil :alias ("identifier" "string") :name ("identifier" "string"))) 
 ("export_statement" (:*unnamed* ("expression" "identifier" "namespace_export" "export_clause") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression"))) 
 ("expression" (:*unnamed* ("ternary_expression" "augmented_assignment_expression" "await_expression" "as_expression" "binary_expression" "instantiation_expression" "update_expression" "internal_module" "jsx_self_closing_element" "primary_expression" "satisfies_expression" "glimmer_template" "unary_expression" "assignment_expression" "jsx_element" "yield_expression" "new_expression"))) 
 ("expression_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("extends_clause" (:*unnamed* nil :type_arguments ("type_arguments") :value ("expression"))) 
 ("extends_type_clause" (:*unnamed* nil :type ("type_identifier" "nested_type_identifier" "generic_type"))) 
 ("false" (:*unnamed* nil)) 
 ("finally_clause" (:*unnamed* nil :body ("statement_block"))) 
 ("flow_maybe_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("for_in_statement" (:*unnamed* nil :body ("statement") :kind nil :left ("array_pattern" "undefined" "identifier" "non_null_expression" "member_expression" "subscript_expression" "object_pattern" "parenthesized_expression") :operator nil :right ("expression" "sequence_expression") :value ("expression"))) 
 ("for_statement" (:*unnamed* nil :body ("statement") :condition ("empty_statement" "expression_statement") :increment ("expression" "sequence_expression") :initializer ("lexical_declaration" "empty_statement" "expression_statement" "variable_declaration"))) 
 ("formal_parameters" (:*unnamed* ("required_parameter" "optional_parameter"))) 
 ("function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("function_signature" (:*unnamed* nil :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("function_type" (:*unnamed* nil :parameters ("formal_parameters") :return_type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "type_predicate" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "asserts" "flow_maybe_type") :type_parameters ("type_parameters"))) 
 ("generator_function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("generator_function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("generic_type" (:*unnamed* nil :name ("nested_type_identifier" "type_identifier") :type_arguments ("type_arguments"))) 
 ("glimmer_closing_tag" (:*unnamed* nil)) 
 ("glimmer_opening_tag" (:*unnamed* nil)) 
 ("glimmer_template" (:*unnamed* nil :close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag"))) 
 ("hash_bang_line" (:*unnamed* nil)) 
 ("identifier" (:*unnamed* nil)) 
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement"))) 
 ("implements_clause" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("import" (:*unnamed* nil)) 
 ("import_alias" (:*unnamed* ("identifier" "nested_identifier"))) 
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports"))) 
 ("import_require_clause" (:*unnamed* ("identifier") :source ("string"))) 
 ("import_specifier" (:*unnamed* nil :alias ("identifier") :name ("identifier" "string"))) 
 ("import_statement" (:*unnamed* ("import_clause" "import_require_clause") :source ("string"))) 
 ("index_signature" (:*unnamed* ("mapped_type_clause") :index_type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :name ("identifier") :sign nil :type ("omitting_type_annotation" "type_annotation" "opting_type_annotation"))) 
 ("index_type_query" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("infer_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("instantiation_expression" (:*unnamed* ("expression") :function ("member_expression" "identifier" "import" "subscript_expression") :type_arguments ("type_arguments"))) 
 ("interface_declaration" (:*unnamed* ("extends_type_clause") :body ("object_type") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("internal_module" (:*unnamed* nil :body ("statement_block") :name ("identifier" "string" "nested_identifier"))) 
 ("intersection_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("jsx_attribute" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_self_closing_element" "string" "jsx_namespace_name" "property_identifier"))) 
 ("jsx_closing_element" (:*unnamed* nil :name ("jsx_namespace_name" "identifier" "member_expression"))) 
 ("jsx_element" (:*unnamed* ("jsx_self_closing_element" "jsx_expression" "jsx_element" "jsx_text") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element"))) 
 ("jsx_expression" (:*unnamed* ("expression" "sequence_expression" "spread_element"))) 
 ("jsx_namespace_name" (:*unnamed* ("identifier"))) 
 ("jsx_opening_element" (:*unnamed* nil :attribute ("jsx_attribute" "jsx_expression") :name ("jsx_namespace_name" "identifier" "member_expression") :type_arguments ("type_arguments"))) 
 ("jsx_self_closing_element" (:*unnamed* nil :attribute ("jsx_attribute" "jsx_expression") :name ("jsx_namespace_name" "identifier" "member_expression") :type_arguments ("type_arguments"))) 
 ("jsx_text" (:*unnamed* nil)) 
 ("labeled_statement" (:*unnamed* nil :body ("statement") :label ("statement_identifier"))) 
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil)) 
 ("literal_type" (:*unnamed* ("false" "unary_expression" "undefined" "string" "null" "true" "number"))) 
 ("lookup_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("mapped_type_clause" (:*unnamed* nil :alias ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :name ("type_identifier") :type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("member_expression" (:*unnamed* ("member_expression" "identifier" "property_identifier") :object ("expression") :optional_chain ("optional_chain") :property ("private_property_identifier" "property_identifier"))) 
 ("meta_property" (:*unnamed* nil)) 
 ("method_definition" (:*unnamed* ("accessibility_modifier" "override_modifier") :body ("statement_block") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("method_signature" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("module" (:*unnamed* nil :body ("statement_block") :name ("identifier" "string" "nested_identifier"))) 
 ("named_imports" (:*unnamed* ("import_specifier"))) 
 ("namespace_export" (:*unnamed* ("identifier" "string"))) 
 ("namespace_import" (:*unnamed* ("identifier"))) 
 ("nested_identifier" (:*unnamed* ("member_expression" "identifier" "property_identifier"))) 
 ("nested_type_identifier" (:*unnamed* nil :module ("identifier" "nested_identifier") :name ("type_identifier"))) 
 ("new_expression" (:*unnamed* nil :arguments ("arguments") :constructor ("primary_expression") :type_arguments ("type_arguments"))) 
 ("non_null_expression" (:*unnamed* ("expression"))) 
 ("null" (:*unnamed* nil)) 
 ("number" (:*unnamed* nil)) 
 ("object" (:*unnamed* ("shorthand_property_identifier" "pair" "method_definition" "spread_element"))) 
 ("object_assignment_pattern" (:*unnamed* nil :left ("array_pattern" "object_pattern" "shorthand_property_identifier_pattern") :right ("expression"))) 
 ("object_pattern" (:*unnamed* ("rest_pattern" "object_assignment_pattern" "pair_pattern" "shorthand_property_identifier_pattern"))) 
 ("object_type" (:*unnamed* ("property_signature" "index_signature" "method_signature" "construct_signature" "export_statement" "call_signature"))) 
 ("omitting_type_annotation" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("opting_type_annotation" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("optional_chain" (:*unnamed* nil)) 
 ("optional_parameter" (:*unnamed* ("accessibility_modifier" "override_modifier") :decorator ("decorator") :name ("identifier") :pattern ("this" "pattern") :type ("type_annotation") :value ("expression"))) 
 ("optional_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("override_modifier" (:*unnamed* nil)) 
 ("pair" (:*unnamed* nil :key ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("expression"))) 
 ("pair_pattern" (:*unnamed* nil :key ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("assignment_pattern" "pattern"))) 
 ("parenthesized_expression" (:*unnamed* ("expression" "sequence_expression") :type ("type_annotation"))) 
 ("parenthesized_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("pattern" (:*unnamed* ("rest_pattern" "array_pattern" "undefined" "identifier" "non_null_expression" "member_expression" "subscript_expression" "object_pattern"))) 
 ("predefined_type" (:*unnamed* nil)) 
 ("primary_expression" (:*unnamed* ("array" "import" "regex" "false" "member_expression" "object" "template_string" "string" "arrow_function" "super" "undefined" "function" "null" "identifier" "meta_property" "number" "non_null_expression" "generator_function" "this" "class" "subscript_expression" "call_expression" "true" "parenthesized_expression"))) 
 ("private_property_identifier" (:*unnamed* nil)) 
 ("program" (:*unnamed* ("statement" "hash_bang_line"))) 
 ("property_identifier" (:*unnamed* nil)) 
 ("property_signature" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :type ("type_annotation"))) 
 ("public_field_definition" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :type ("type_annotation") :value ("expression"))) 
 ("readonly_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("regex" (:*unnamed* nil :flags ("regex_flags") :pattern ("regex_pattern"))) 
 ("regex_flags" (:*unnamed* nil)) 
 ("regex_pattern" (:*unnamed* nil)) 
 ("required_parameter" (:*unnamed* ("accessibility_modifier" "override_modifier") :decorator ("decorator") :name ("rest_pattern" "identifier") :pattern ("this" "pattern") :type ("type_annotation") :value ("expression"))) 
 ("rest_pattern" (:*unnamed* ("member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression" "non_null_expression"))) 
 ("rest_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("return_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("satisfies_expression" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "expression" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("sequence_expression" (:*unnamed* nil :left ("expression") :right ("expression" "sequence_expression"))) 
 ("shorthand_property_identifier" (:*unnamed* nil)) 
 ("shorthand_property_identifier_pattern" (:*unnamed* nil)) 
 ("spread_element" (:*unnamed* ("expression"))) 
 ("statement" (:*unnamed* ("while_statement" "labeled_statement" "return_statement" "for_in_statement" "try_statement" "switch_statement" "break_statement" "debugger_statement" "continue_statement" "export_statement" "declaration" "do_statement" "empty_statement" "with_statement" "throw_statement" "statement_block" "for_statement" "if_statement" "expression_statement" "import_statement"))) 
 ("statement_block" (:*unnamed* ("statement"))) 
 ("statement_identifier" (:*unnamed* nil)) 
 ("string" (:*unnamed* ("escape_sequence" "string_fragment"))) 
 ("string_fragment" (:*unnamed* nil)) 
 ("subscript_expression" (:*unnamed* nil :index ("expression" "number" "sequence_expression" "string" "predefined_type") :object ("expression") :optional_chain ("optional_chain"))) 
 ("super" (:*unnamed* nil)) 
 ("switch_body" (:*unnamed* ("switch_case" "switch_default"))) 
 ("switch_case" (:*unnamed* nil :body ("statement") :value ("expression" "sequence_expression"))) 
 ("switch_default" (:*unnamed* nil :body ("statement"))) 
 ("switch_statement" (:*unnamed* nil :body ("switch_body") :value ("parenthesized_expression"))) 
 ("template_literal_type" (:*unnamed* ("template_type"))) 
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution"))) 
 ("template_substitution" (:*unnamed* ("expression" "sequence_expression"))) 
 ("template_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("ternary_expression" (:*unnamed* nil :alternative ("expression") :condition ("expression") :consequence ("expression"))) 
 ("this" (:*unnamed* nil)) 
 ("this_type" (:*unnamed* nil)) 
 ("throw_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("true" (:*unnamed* nil)) 
 ("try_statement" (:*unnamed* nil :body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause"))) 
 ("tuple_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "optional_parameter" "predefined_type" "intersection_type" "this_type" "conditional_type" "required_parameter" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "optional_type" "rest_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_alias_declaration" (:*unnamed* nil :name ("type_identifier") :type_parameters ("type_parameters") :value ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_annotation" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_arguments" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_identifier" (:*unnamed* nil)) 
 ("type_parameter" (:*unnamed* nil :constraint ("constraint") :name ("type_identifier") :value ("default_type"))) 
 ("type_parameters" (:*unnamed* ("type_parameter"))) 
 ("type_predicate" (:*unnamed* nil :name ("identifier" "this") :type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_predicate_annotation" (:*unnamed* ("type_predicate"))) 
 ("type_query" (:*unnamed* ("instantiation_expression" "member_expression" "identifier" "call_expression" "subscript_expression"))) 
 ("unary_expression" (:*unnamed* nil :argument ("expression" "number") :operator nil)) 
 ("undefined" (:*unnamed* nil)) 
 ("union_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("update_expression" (:*unnamed* nil :argument ("expression") :operator nil)) 
 ("variable_declaration" (:*unnamed* ("variable_declarator"))) 
 ("variable_declarator" (:*unnamed* nil :name ("identifier" "array_pattern" "object_pattern") :type ("type_annotation") :value ("expression"))) 
 ("while_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression"))) 
 ("with_statement" (:*unnamed* nil :body ("statement") :object ("parenthesized_expression"))) 
 ("yield_expression" (:*unnamed* ("expression"))) 
))
;; END Production rules for tsx
;; START Inverse production rules for tsx
(defconst combobulate-rules-tsx-inverse 
 '(("abstract_class_declaration" ("declaration"))
   ("abstract_method_signature" ("class_body"))
   ("accessibility_modifier" ("public_field_definition" "method_definition" "optional_parameter" "abstract_method_signature" "required_parameter" "property_signature" "method_signature"))
   ("ambient_declaration" ("declaration"))
   ("arguments" ("call_expression" "new_expression"))
   ("array" ("primary_expression"))
   ("array_pattern" ("rest_pattern" "assignment_expression" "for_in_statement" "variable_declarator" "object_assignment_pattern" "pattern" "catch_clause"))
   ("array_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("arrow_function" ("primary_expression"))
   ("as_expression" ("expression"))
   ("asserts" ("function_type" "asserts_annotation"))
   ("asserts_annotation" ("method_definition" "function" "abstract_method_signature" "generator_function" "function_declaration" "function_signature" "method_signature" "call_signature" "arrow_function" "generator_function_declaration"))
   ("assignment_expression" ("expression"))
   ("assignment_pattern" ("pair_pattern" "array_pattern"))
   ("augmented_assignment_expression" ("expression"))
   ("await_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("break_statement" ("statement"))
   ("call_expression" ("type_query" "decorator" "primary_expression"))
   ("call_signature" ("object_type"))
   ("catch_clause" ("try_statement"))
   ("class" ("primary_expression"))
   ("class_body" ("class" "class_declaration" "abstract_class_declaration"))
   ("class_declaration" ("declaration"))
   ("class_heritage" ("class" "class_declaration" "abstract_class_declaration"))
   ("class_static_block" ("class_body"))
   ("computed_property_name" ("public_field_definition" "method_definition" "enum_body" "abstract_method_signature" "pair" "pair_pattern" "property_signature" "method_signature" "enum_assignment"))
   ("conditional_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("constraint" ("type_parameter"))
   ("construct_signature" ("object_type"))
   ("constructor_type" ("as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "optional_type" "rest_type" "readonly_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("continue_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "export_statement" "ambient_declaration"))
   ("decorator" ("class_body" "optional_parameter" "class_declaration" "export_statement" "required_parameter" "abstract_class_declaration" "class"))
   ("default_type" ("type_parameter"))
   ("do_statement" ("statement"))
   ("else_clause" ("if_statement"))
   ("empty_statement" ("statement" "for_statement"))
   ("enum_assignment" ("enum_body"))
   ("enum_body" ("enum_declaration"))
   ("enum_declaration" ("declaration"))
   ("escape_sequence" ("template_string" "string"))
   ("existential_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("export_clause" ("export_statement"))
   ("export_specifier" ("export_clause"))
   ("export_statement" ("statement" "object_type"))
   ("expression" ("as_expression" "optional_parameter" "for_in_statement" "member_expression" "arrow_function" "template_substitution" "assignment_expression" "yield_expression" "export_statement" "pair" "throw_statement" "for_statement" "extends_clause" "call_expression" "arguments" "parenthesized_expression" "return_statement" "augmented_assignment_expression" "await_expression" "public_field_definition" "ternary_expression" "array" "jsx_expression" "required_parameter" "binary_expression" "instantiation_expression" "variable_declarator" "object_assignment_pattern" "sequence_expression" "update_expression" "computed_property_name" "satisfies_expression" "enum_assignment" "assignment_pattern" "unary_expression" "non_null_expression" "spread_element" "switch_case" "subscript_expression" "expression_statement"))
   ("expression_statement" ("statement" "for_statement"))
   ("extends_clause" ("class_heritage"))
   ("extends_type_clause" ("interface_declaration"))
   ("false" ("literal_type" "primary_expression"))
   ("finally_clause" ("try_statement"))
   ("flow_maybe_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("for_in_statement" ("statement"))
   ("for_statement" ("statement"))
   ("formal_parameters" ("function_type" "method_definition" "function" "abstract_method_signature" "generator_function_declaration" "generator_function" "function_declaration" "constructor_type" "function_signature" "call_signature" "method_signature" "arrow_function" "construct_signature"))
   ("function" ("primary_expression"))
   ("function_declaration" ("declaration"))
   ("function_signature" ("declaration"))
   ("function_type" ("as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "optional_type" "rest_type" "readonly_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("generator_function" ("primary_expression"))
   ("generator_function_declaration" ("declaration"))
   ("generic_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "extends_type_clause" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("glimmer_template" ("expression"))
   ("hash_bang_line" ("program"))
   ("identifier" ("optional_parameter" "jsx_opening_element" "for_in_statement" "member_expression" "primary_expression" "nested_identifier" "arrow_function" "import_specifier" "jsx_closing_element" "import_require_clause" "assignment_expression" "function" "export_statement" "export_specifier" "generator_function" "function_signature" "catch_clause" "asserts" "augmented_assignment_expression" "rest_pattern" "type_query" "required_parameter" "instantiation_expression" "variable_declarator" "type_predicate" "internal_module" "jsx_self_closing_element" "namespace_import" "import_alias" "import_clause" "namespace_export" "index_signature" "module" "enum_declaration" "jsx_namespace_name" "nested_type_identifier" "decorator" "pattern" "function_declaration" "generator_function_declaration"))
   ("if_statement" ("statement"))
   ("implements_clause" ("class_heritage"))
   ("import" ("instantiation_expression" "primary_expression"))
   ("import_alias" ("declaration"))
   ("import_clause" ("import_statement"))
   ("import_require_clause" ("import_statement"))
   ("import_specifier" ("named_imports"))
   ("import_statement" ("statement"))
   ("index_signature" ("class_body" "object_type"))
   ("index_type_query" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("infer_type" ("as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "optional_type" "template_type" "rest_type" "readonly_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("instantiation_expression" ("expression" "type_query"))
   ("interface_declaration" ("declaration"))
   ("internal_module" ("expression" "declaration"))
   ("intersection_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_element" ("jsx_attribute" "expression" "jsx_element"))
   ("jsx_expression" ("jsx_attribute" "jsx_opening_element" "jsx_self_closing_element" "jsx_element"))
   ("jsx_namespace_name" ("jsx_attribute" "jsx_closing_element" "jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_self_closing_element" ("jsx_attribute" "expression" "jsx_element"))
   ("jsx_text" ("jsx_element"))
   ("labeled_statement" ("statement"))
   ("lexical_declaration" ("for_statement" "declaration"))
   ("literal_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("lookup_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("mapped_type_clause" ("index_signature"))
   ("member_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "type_query" "jsx_opening_element" "decorator" "for_in_statement" "instantiation_expression" "member_expression" "pattern" "primary_expression" "jsx_self_closing_element" "nested_identifier" "jsx_closing_element"))
   ("meta_property" ("primary_expression"))
   ("method_definition" ("object" "class_body"))
   ("method_signature" ("class_body" "object_type"))
   ("module" ("declaration"))
   ("named_imports" ("import_clause"))
   ("namespace_export" ("export_statement"))
   ("namespace_import" ("import_clause"))
   ("nested_identifier" ("import_alias" "nested_type_identifier" "internal_module" "module"))
   ("nested_type_identifier" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "extends_type_clause" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "generic_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("new_expression" ("expression"))
   ("non_null_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "for_in_statement" "pattern" "primary_expression"))
   ("null" ("literal_type" "primary_expression"))
   ("number" ("unary_expression" "literal_type" "method_definition" "enum_body" "public_field_definition" "abstract_method_signature" "pair" "pair_pattern" "subscript_expression" "property_signature" "primary_expression" "method_signature" "enum_assignment"))
   ("object" ("primary_expression"))
   ("object_assignment_pattern" ("object_pattern"))
   ("object_pattern" ("rest_pattern" "assignment_expression" "for_in_statement" "variable_declarator" "object_assignment_pattern" "pattern" "catch_clause"))
   ("object_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "interface_declaration" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("omitting_type_annotation" ("index_signature"))
   ("opting_type_annotation" ("index_signature"))
   ("optional_chain" ("member_expression" "subscript_expression"))
   ("optional_parameter" ("tuple_type" "formal_parameters"))
   ("optional_type" ("tuple_type"))
   ("override_modifier" ("public_field_definition" "method_definition" "optional_parameter" "required_parameter" "property_signature" "method_signature"))
   ("pair" ("object"))
   ("pair_pattern" ("object_pattern"))
   ("parenthesized_expression" ("augmented_assignment_expression" "while_statement" "assignment_expression" "do_statement" "for_in_statement" "switch_statement" "with_statement" "primary_expression" "if_statement"))
   ("parenthesized_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("pattern" ("assignment_pattern" "array_pattern" "optional_parameter" "required_parameter" "pair_pattern"))
   ("predefined_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "type_alias_declaration" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "subscript_expression" "mapped_type_clause"))
   ("primary_expression" ("expression" "new_expression"))
   ("private_property_identifier" ("public_field_definition" "method_definition" "enum_body" "abstract_method_signature" "pair" "pair_pattern" "property_signature" "member_expression" "method_signature" "enum_assignment"))
   ("property_identifier" ("jsx_attribute" "public_field_definition" "method_definition" "enum_body" "ambient_declaration" "abstract_method_signature" "pair" "pair_pattern" "property_signature" "member_expression" "method_signature" "nested_identifier" "enum_assignment"))
   ("property_signature" ("object_type"))
   ("public_field_definition" ("class_body"))
   ("readonly_type" ("as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "optional_type" "rest_type" "readonly_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("regex" ("primary_expression"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("required_parameter" ("tuple_type" "formal_parameters"))
   ("rest_pattern" ("required_parameter" "pattern" "object_pattern"))
   ("rest_type" ("tuple_type"))
   ("return_statement" ("statement"))
   ("satisfies_expression" ("expression"))
   ("sequence_expression" ("jsx_expression" "return_statement" "for_in_statement" "sequence_expression" "throw_statement" "switch_case" "for_statement" "subscript_expression" "expression_statement" "template_substitution" "parenthesized_expression"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_assignment_pattern" "object_pattern"))
   ("spread_element" ("object" "jsx_expression" "array" "arguments"))
   ("statement" ("while_statement" "labeled_statement" "program" "do_statement" "for_in_statement" "with_statement" "statement_block" "switch_case" "for_statement" "else_clause" "if_statement" "switch_default"))
   ("statement_block" ("method_definition" "finally_clause" "ambient_declaration" "module" "function" "class_static_block" "try_statement" "statement" "generator_function" "function_declaration" "catch_clause" "internal_module" "arrow_function" "generator_function_declaration"))
   ("statement_identifier" ("break_statement" "continue_statement" "labeled_statement"))
   ("string" ("enum_body" "primary_expression" "method_signature" "import_specifier" "import_require_clause" "jsx_attribute" "literal_type" "method_definition" "export_statement" "pair" "export_specifier" "import_statement" "public_field_definition" "abstract_method_signature" "internal_module" "enum_assignment" "namespace_export" "module" "pair_pattern" "property_signature" "subscript_expression"))
   ("string_fragment" ("string"))
   ("subscript_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "type_query" "for_in_statement" "instantiation_expression" "pattern" "primary_expression"))
   ("super" ("primary_expression"))
   ("switch_body" ("switch_statement"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_statement" ("statement"))
   ("template_literal_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("template_string" ("call_expression" "primary_expression"))
   ("template_substitution" ("template_string"))
   ("template_type" ("template_literal_type"))
   ("ternary_expression" ("expression"))
   ("this" ("optional_parameter" "required_parameter" "type_predicate" "primary_expression" "asserts"))
   ("this_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("throw_statement" ("statement"))
   ("true" ("literal_type" "primary_expression"))
   ("try_statement" ("statement"))
   ("tuple_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("type_alias_declaration" ("declaration"))
   ("type_annotation" ("optional_parameter" "method_signature" "call_signature" "arrow_function" "method_definition" "function" "generator_function" "function_signature" "catch_clause" "construct_signature" "parenthesized_expression" "public_field_definition" "abstract_method_signature" "required_parameter" "variable_declarator" "index_signature" "property_signature" "function_declaration" "generator_function_declaration"))
   ("type_arguments" ("jsx_opening_element" "new_expression" "instantiation_expression" "generic_type" "jsx_self_closing_element" "extends_clause" "call_expression"))
   ("type_identifier" ("index_type_query" "as_expression" "omitting_type_annotation" "class_declaration" "intersection_type" "conditional_type" "default_type" "abstract_class_declaration" "extends_type_clause" "type_arguments" "type_parameter" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "class" "flow_maybe_type" "interface_declaration" "parenthesized_type" "union_type" "generic_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "_primary_type" "lookup_type" "function_type" "ambient_declaration" "index_signature" "nested_type_identifier" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("type_parameter" ("type_parameters"))
   ("type_parameters" ("interface_declaration" "function_type" "method_definition" "type_alias_declaration" "function" "abstract_method_signature" "class_declaration" "generator_function_declaration" "generator_function" "abstract_class_declaration" "constructor_type" "function_declaration" "call_signature" "class" "arrow_function" "function_signature" "method_signature" "construct_signature"))
   ("type_predicate" ("type_predicate_annotation" "function_type" "asserts"))
   ("type_predicate_annotation" ("method_definition" "function" "abstract_method_signature" "generator_function" "function_declaration" "function_signature" "method_signature" "call_signature" "arrow_function" "generator_function_declaration"))
   ("type_query" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("unary_expression" ("expression" "literal_type"))
   ("undefined" ("rest_pattern" "literal_type" "assignment_expression" "for_in_statement" "pattern" "primary_expression"))
   ("union_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("update_expression" ("expression"))
   ("variable_declaration" ("for_statement" "declaration"))
   ("variable_declarator" ("variable_declaration" "lexical_declaration"))
   ("while_statement" ("statement"))
   ("with_statement" ("statement"))
   ("yield_expression" ("expression"))
  ) 
)
;; END Inverse production rules for tsx
;; START All node types in tsx
(defconst combobulate-rules-tsx-types 
 '("_primary_type" "abstract_class_declaration" "abstract_method_signature" "accessibility_modifier" "ambient_declaration" "arguments" "array" "array_pattern" "array_type" "arrow_function" "as_expression" "asserts" "asserts_annotation" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "call_signature" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "conditional_type" "constraint" "construct_signature" "constructor_type" "continue_statement" "debugger_statement" "declaration" "decorator" "default_type" "do_statement" "else_clause" "empty_statement" "enum_assignment" "enum_body" "enum_declaration" "escape_sequence" "existential_type" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "extends_clause" "extends_type_clause" "false" "finally_clause" "flow_maybe_type" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "function_signature" "function_type" "generator_function" "generator_function_declaration" "generic_type" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "implements_clause" "import" "import_alias" "import_clause" "import_require_clause" "import_specifier" "import_statement" "index_signature" "index_type_query" "infer_type" "instantiation_expression" "interface_declaration" "internal_module" "intersection_type" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "literal_type" "lookup_type" "mapped_type_clause" "member_expression" "meta_property" "method_definition" "method_signature" "module" "named_imports" "namespace_export" "namespace_import" "nested_identifier" "nested_type_identifier" "new_expression" "non_null_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "object_type" "omitting_type_annotation" "opting_type_annotation" "optional_chain" "optional_parameter" "optional_type" "override_modifier" "pair" "pair_pattern" "parenthesized_expression" "parenthesized_type" "pattern" "predefined_type" "primary_expression" "private_property_identifier" "program" "property_identifier" "property_signature" "public_field_definition" "readonly_type" "regex" "regex_flags" "regex_pattern" "required_parameter" "rest_pattern" "rest_type" "return_statement" "satisfies_expression" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_literal_type" "template_string" "template_substitution" "template_type" "ternary_expression" "this" "this_type" "throw_statement" "true" "try_statement" "tuple_type" "type_alias_declaration" "type_annotation" "type_arguments" "type_identifier" "type_parameter" "type_parameters" "type_predicate" "type_predicate_annotation" "type_query" "unary_expression" "undefined" "union_type" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression") 
)
;; END All node types in tsx
;; START All supertypes in tsx
(defconst combobulate-rules-tsx-supertypes 
 '("_primary_type" "declaration" "expression" "pattern" "primary_expression" "statement") 
)
;; END All supertypes in tsx

;; START Production rules for css
(defconst combobulate-rules-css 
 '(("adjacent_sibling_selector" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("arguments" (:*unnamed* ("descendant_selector" "float_value" "tag_name" "binary_expression" "id_selector" "nesting_selector" "string_value" "universal_selector" "grid_value" "namespace_selector" "important" "color_value" "class_selector" "sibling_selector" "integer_value" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "plain_value" "child_selector" "adjacent_sibling_selector" "call_expression" "parenthesized_value"))) 
 ("at_keyword" (:*unnamed* nil)) 
 ("at_rule" (:*unnamed* ("binary_query" "at_keyword" "selector_query" "parenthesized_query" "feature_query" "block" "keyword_query" "unary_query"))) 
 ("attribute_name" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("attribute_selector" (:*unnamed* ("descendant_selector" "float_value" "tag_name" "binary_expression" "id_selector" "nesting_selector" "string_value" "universal_selector" "grid_value" "namespace_selector" "important" "color_value" "class_selector" "sibling_selector" "integer_value" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "plain_value" "child_selector" "adjacent_sibling_selector" "call_expression" "parenthesized_value"))) 
 ("binary_expression" (:*unnamed* ("grid_value" "important" "color_value" "integer_value" "binary_expression" "call_expression" "plain_value" "string_value" "float_value" "parenthesized_value"))) 
 ("binary_query" (:*unnamed* ("binary_query" "selector_query" "keyword_query" "unary_query" "parenthesized_query" "feature_query"))) 
 ("block" (:*unnamed* ("keyframes_statement" "at_rule" "declaration" "charset_statement" "postcss_statement" "rule_set" "namespace_statement" "supports_statement" "import_statement" "media_statement"))) 
 ("call_expression" (:*unnamed* ("function_name" "arguments"))) 
 ("charset_statement" (:*unnamed* ("grid_value" "important" "color_value" "integer_value" "binary_expression" "call_expression" "plain_value" "string_value" "float_value" "parenthesized_value"))) 
 ("child_selector" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("class_name" (:*unnamed* nil)) 
 ("class_selector" (:*unnamed* ("descendant_selector" "namespace_selector" "class_name" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("color_value" (:*unnamed* nil)) 
 ("comment" (:*unnamed* nil)) 
 ("declaration" (:*unnamed* ("grid_value" "important" "color_value" "property_name" "integer_value" "binary_expression" "call_expression" "plain_value" "string_value" "float_value" "parenthesized_value"))) 
 ("descendant_selector" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("feature_name" (:*unnamed* nil)) 
 ("feature_query" (:*unnamed* ("grid_value" "important" "color_value" "integer_value" "binary_expression" "feature_name" "call_expression" "plain_value" "string_value" "float_value" "parenthesized_value"))) 
 ("float_value" (:*unnamed* ("unit"))) 
 ("from" (:*unnamed* nil)) 
 ("function_name" (:*unnamed* nil)) 
 ("grid_value" (:*unnamed* ("grid_value" "important" "color_value" "integer_value" "binary_expression" "call_expression" "plain_value" "string_value" "float_value" "parenthesized_value"))) 
 ("id_name" (:*unnamed* nil)) 
 ("id_selector" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "id_name" "sibling_selector" "string_value" "attribute_selector" "pseudo_element_selector" "tag_name" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("import_statement" (:*unnamed* ("binary_query" "selector_query" "binary_expression" "feature_query" "string_value" "keyword_query" "grid_value" "important" "color_value" "integer_value" "parenthesized_query" "call_expression" "plain_value" "unary_query" "float_value" "parenthesized_value"))) 
 ("important" (:*unnamed* nil)) 
 ("integer_value" (:*unnamed* ("unit"))) 
 ("js_comment" (:*unnamed* nil)) 
 ("keyframe_block" (:*unnamed* ("from" "integer_value" "block" "to"))) 
 ("keyframe_block_list" (:*unnamed* ("keyframe_block"))) 
 ("keyframes_name" (:*unnamed* nil)) 
 ("keyframes_statement" (:*unnamed* ("keyframes_name" "keyframe_block_list" "at_keyword"))) 
 ("keyword_query" (:*unnamed* nil)) 
 ("media_statement" (:*unnamed* ("binary_query" "selector_query" "block" "keyword_query" "unary_query" "parenthesized_query" "feature_query"))) 
 ("namespace_name" (:*unnamed* nil)) 
 ("namespace_selector" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("namespace_statement" (:*unnamed* ("string_value" "namespace_name" "call_expression"))) 
 ("nesting_selector" (:*unnamed* nil)) 
 ("parenthesized_query" (:*unnamed* ("binary_query" "selector_query" "keyword_query" "unary_query" "parenthesized_query" "feature_query"))) 
 ("parenthesized_value" (:*unnamed* ("grid_value" "important" "color_value" "integer_value" "binary_expression" "call_expression" "plain_value" "string_value" "float_value" "parenthesized_value"))) 
 ("plain_value" (:*unnamed* nil)) 
 ("postcss_statement" (:*unnamed* ("grid_value" "important" "at_keyword" "color_value" "integer_value" "binary_expression" "call_expression" "plain_value" "string_value" "float_value" "parenthesized_value"))) 
 ("property_name" (:*unnamed* nil)) 
 ("pseudo_class_selector" (:*unnamed* ("descendant_selector" "class_name" "tag_name" "string_value" "nesting_selector" "universal_selector" "namespace_selector" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))) 
 ("pseudo_element_selector" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "arguments" "id_selector"))) 
 ("rule_set" (:*unnamed* ("selectors" "block"))) 
 ("selector_query" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("selectors" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("sibling_selector" (:*unnamed* ("descendant_selector" "namespace_selector" "class_selector" "sibling_selector" "string_value" "tag_name" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "nesting_selector" "child_selector" "adjacent_sibling_selector" "universal_selector" "id_selector"))) 
 ("string_value" (:*unnamed* nil)) 
 ("stylesheet" (:*unnamed* ("keyframes_statement" "at_rule" "declaration" "charset_statement" "rule_set" "namespace_statement" "supports_statement" "import_statement" "media_statement"))) 
 ("supports_statement" (:*unnamed* ("binary_query" "selector_query" "block" "keyword_query" "unary_query" "parenthesized_query" "feature_query"))) 
 ("tag_name" (:*unnamed* nil)) 
 ("to" (:*unnamed* nil)) 
 ("unary_query" (:*unnamed* ("binary_query" "selector_query" "keyword_query" "unary_query" "parenthesized_query" "feature_query"))) 
 ("unit" (:*unnamed* nil)) 
 ("universal_selector" (:*unnamed* nil)) 
))
;; END Production rules for css
;; START Inverse production rules for css
(defconst combobulate-rules-css-inverse 
 '(("adjacent_sibling_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("arguments" ("pseudo_class_selector" "pseudo_element_selector" "call_expression"))
   ("at_keyword" ("at_rule" "keyframes_statement" "postcss_statement"))
   ("at_rule" ("stylesheet" "block"))
   ("attribute_name" ("attribute_selector"))
   ("attribute_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("binary_expression" ("grid_value" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "import_statement" "arguments" "parenthesized_value"))
   ("binary_query" ("binary_query" "at_rule" "parenthesized_query" "supports_statement" "import_statement" "unary_query" "media_statement"))
   ("block" ("keyframe_block" "at_rule" "supports_statement" "rule_set" "media_statement"))
   ("call_expression" ("grid_value" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "namespace_statement" "import_statement" "arguments" "parenthesized_value"))
   ("charset_statement" ("stylesheet" "block"))
   ("child_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("class_name" ("pseudo_class_selector" "class_selector"))
   ("class_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("color_value" ("grid_value" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "import_statement" "arguments" "parenthesized_value"))
   ("declaration" ("stylesheet" "block"))
   ("descendant_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("feature_name" ("feature_query"))
   ("feature_query" ("binary_query" "at_rule" "parenthesized_query" "supports_statement" "import_statement" "unary_query" "media_statement"))
   ("float_value" ("grid_value" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "import_statement" "arguments" "parenthesized_value"))
   ("from" ("keyframe_block"))
   ("function_name" ("call_expression"))
   ("grid_value" ("grid_value" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "import_statement" "arguments" "parenthesized_value"))
   ("id_name" ("id_selector"))
   ("id_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("import_statement" ("stylesheet" "block"))
   ("important" ("grid_value" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "import_statement" "arguments" "parenthesized_value"))
   ("integer_value" ("grid_value" "keyframe_block" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "import_statement" "arguments" "parenthesized_value"))
   ("keyframe_block" ("keyframe_block_list"))
   ("keyframe_block_list" ("keyframes_statement"))
   ("keyframes_name" ("keyframes_statement"))
   ("keyframes_statement" ("stylesheet" "block"))
   ("keyword_query" ("binary_query" "at_rule" "parenthesized_query" "supports_statement" "import_statement" "unary_query" "media_statement"))
   ("media_statement" ("stylesheet" "block"))
   ("namespace_name" ("namespace_statement"))
   ("namespace_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("namespace_statement" ("stylesheet" "block"))
   ("nesting_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("parenthesized_query" ("binary_query" "at_rule" "parenthesized_query" "supports_statement" "import_statement" "unary_query" "media_statement"))
   ("parenthesized_value" ("grid_value" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "import_statement" "arguments" "parenthesized_value"))
   ("plain_value" ("grid_value" "attribute_selector" "declaration" "binary_expression" "charset_statement" "feature_query" "postcss_statement" "import_statement" "arguments" "parenthesized_value"))
   ("postcss_statement" ("block"))
   ("property_name" ("declaration"))
   ("pseudo_class_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("pseudo_element_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("rule_set" ("stylesheet" "block"))
   ("selector_query" ("binary_query" "at_rule" "parenthesized_query" "supports_statement" "import_statement" "unary_query" "media_statement"))
   ("selectors" ("rule_set"))
   ("sibling_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("string_value" ("descendant_selector" "charset_statement" "feature_query" "namespace_statement" "grid_value" "namespace_selector" "selectors" "class_selector" "sibling_selector" "declaration" "import_statement" "adjacent_sibling_selector" "arguments" "parenthesized_value" "id_selector" "selector_query" "binary_expression" "attribute_selector" "pseudo_element_selector" "postcss_statement" "pseudo_class_selector" "attribute_name" "child_selector"))
   ("supports_statement" ("stylesheet" "block"))
   ("tag_name" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
   ("to" ("keyframe_block"))
   ("unary_query" ("binary_query" "at_rule" "parenthesized_query" "supports_statement" "import_statement" "unary_query" "media_statement"))
   ("unit" ("integer_value" "float_value"))
   ("universal_selector" ("descendant_selector" "namespace_selector" "selectors" "selector_query" "class_selector" "sibling_selector" "attribute_selector" "pseudo_element_selector" "pseudo_class_selector" "attribute_name" "child_selector" "adjacent_sibling_selector" "arguments" "id_selector"))
  ) 
)
;; END Inverse production rules for css
;; START All node types in css
(defconst combobulate-rules-css-types 
 '("adjacent_sibling_selector" "arguments" "at_keyword" "at_rule" "attribute_name" "attribute_selector" "binary_expression" "binary_query" "block" "call_expression" "charset_statement" "child_selector" "class_name" "class_selector" "color_value" "comment" "declaration" "descendant_selector" "feature_name" "feature_query" "float_value" "from" "function_name" "grid_value" "id_name" "id_selector" "import_statement" "important" "integer_value" "js_comment" "keyframe_block" "keyframe_block_list" "keyframes_name" "keyframes_statement" "keyword_query" "media_statement" "namespace_name" "namespace_selector" "namespace_statement" "nesting_selector" "parenthesized_query" "parenthesized_value" "plain_value" "postcss_statement" "property_name" "pseudo_class_selector" "pseudo_element_selector" "rule_set" "selector_query" "selectors" "sibling_selector" "string_value" "stylesheet" "supports_statement" "tag_name" "to" "unary_query" "unit" "universal_selector") 
)
;; END All node types in css
;; START All supertypes in css
(defconst combobulate-rules-css-supertypes 
 nil 
)
;; END All supertypes in css

;; START Production rules for typescript
(defconst combobulate-rules-typescript 
 '(("_primary_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("abstract_class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("abstract_method_signature" (:*unnamed* ("accessibility_modifier") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("accessibility_modifier" (:*unnamed* nil)) 
 ("ambient_declaration" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "declaration" "array_type" "property_identifier" "type_identifier" "constructor_type" "statement_block" "readonly_type" "flow_maybe_type"))) 
 ("arguments" (:*unnamed* ("expression" "spread_element"))) 
 ("array" (:*unnamed* ("expression" "spread_element"))) 
 ("array_pattern" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("array_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("arrow_function" (:*unnamed* nil :body ("expression" "statement_block") :parameter ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("as_expression" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "expression" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("asserts" (:*unnamed* ("identifier" "this" "type_predicate"))) 
 ("asserts_annotation" (:*unnamed* ("asserts"))) 
 ("assignment_expression" (:*unnamed* nil :left ("array_pattern" "undefined" "identifier" "non_null_expression" "member_expression" "subscript_expression" "object_pattern" "parenthesized_expression") :right ("expression"))) 
 ("assignment_pattern" (:*unnamed* nil :left ("pattern") :right ("expression"))) 
 ("augmented_assignment_expression" (:*unnamed* nil :left ("member_expression" "parenthesized_expression" "identifier" "subscript_expression" "non_null_expression") :operator nil :right ("expression"))) 
 ("await_expression" (:*unnamed* ("expression"))) 
 ("binary_expression" (:*unnamed* nil :left ("expression") :operator nil :right ("expression"))) 
 ("break_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("call_expression" (:*unnamed* nil :arguments ("template_string" "arguments") :function ("expression") :type_arguments ("type_arguments"))) 
 ("call_signature" (:*unnamed* nil :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("catch_clause" (:*unnamed* nil :body ("statement_block") :parameter ("identifier" "array_pattern" "object_pattern") :type ("type_annotation"))) 
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("class_body" (:*unnamed* ("public_field_definition" "method_definition" "index_signature" "method_signature" "abstract_method_signature" "class_static_block" "decorator"))) 
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("class_heritage" (:*unnamed* ("extends_clause" "implements_clause"))) 
 ("class_static_block" (:*unnamed* nil :body ("statement_block"))) 
 ("comment" (:*unnamed* nil)) 
 ("computed_property_name" (:*unnamed* ("expression"))) 
 ("conditional_type" (:*unnamed* nil :alternative ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :consequence ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :left ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :right ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("constraint" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("construct_signature" (:*unnamed* nil :parameters ("formal_parameters") :type ("type_annotation") :type_parameters ("type_parameters"))) 
 ("constructor_type" (:*unnamed* nil :parameters ("formal_parameters") :type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :type_parameters ("type_parameters"))) 
 ("continue_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("debugger_statement" (:*unnamed* nil)) 
 ("declaration" (:*unnamed* ("interface_declaration" "ambient_declaration" "module" "class_declaration" "enum_declaration" "lexical_declaration" "function_declaration" "abstract_class_declaration" "function_signature" "internal_module" "import_alias" "variable_declaration" "type_alias_declaration" "generator_function_declaration"))) 
 ("decorator" (:*unnamed* ("member_expression" "identifier" "call_expression"))) 
 ("default_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("do_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("statement"))) 
 ("empty_statement" (:*unnamed* nil)) 
 ("enum_assignment" (:*unnamed* nil :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("expression"))) 
 ("enum_body" (:*unnamed* ("enum_assignment") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number"))) 
 ("enum_declaration" (:*unnamed* nil :body ("enum_body") :name ("identifier"))) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("existential_type" (:*unnamed* nil)) 
 ("export_clause" (:*unnamed* ("export_specifier"))) 
 ("export_specifier" (:*unnamed* nil :alias ("identifier" "string") :name ("identifier" "string"))) 
 ("export_statement" (:*unnamed* ("expression" "identifier" "namespace_export" "export_clause") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression"))) 
 ("expression" (:*unnamed* ("ternary_expression" "augmented_assignment_expression" "await_expression" "as_expression" "binary_expression" "type_assertion" "instantiation_expression" "update_expression" "internal_module" "primary_expression" "satisfies_expression" "glimmer_template" "unary_expression" "assignment_expression" "yield_expression" "new_expression"))) 
 ("expression_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("extends_clause" (:*unnamed* nil :type_arguments ("type_arguments") :value ("expression"))) 
 ("extends_type_clause" (:*unnamed* nil :type ("type_identifier" "nested_type_identifier" "generic_type"))) 
 ("false" (:*unnamed* nil)) 
 ("finally_clause" (:*unnamed* nil :body ("statement_block"))) 
 ("flow_maybe_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("for_in_statement" (:*unnamed* nil :body ("statement") :kind nil :left ("array_pattern" "undefined" "identifier" "non_null_expression" "member_expression" "subscript_expression" "object_pattern" "parenthesized_expression") :operator nil :right ("expression" "sequence_expression") :value ("expression"))) 
 ("for_statement" (:*unnamed* nil :body ("statement") :condition ("empty_statement" "expression_statement") :increment ("expression" "sequence_expression") :initializer ("lexical_declaration" "empty_statement" "expression_statement" "variable_declaration"))) 
 ("formal_parameters" (:*unnamed* ("required_parameter" "optional_parameter"))) 
 ("function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("function_signature" (:*unnamed* nil :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("function_type" (:*unnamed* nil :parameters ("formal_parameters") :return_type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "type_predicate" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "asserts" "flow_maybe_type") :type_parameters ("type_parameters"))) 
 ("generator_function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("generator_function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("generic_type" (:*unnamed* nil :name ("nested_type_identifier" "type_identifier") :type_arguments ("type_arguments"))) 
 ("glimmer_closing_tag" (:*unnamed* nil)) 
 ("glimmer_opening_tag" (:*unnamed* nil)) 
 ("glimmer_template" (:*unnamed* nil :close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag"))) 
 ("hash_bang_line" (:*unnamed* nil)) 
 ("identifier" (:*unnamed* nil)) 
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement"))) 
 ("implements_clause" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("import" (:*unnamed* nil)) 
 ("import_alias" (:*unnamed* ("identifier" "nested_identifier"))) 
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports"))) 
 ("import_require_clause" (:*unnamed* ("identifier") :source ("string"))) 
 ("import_specifier" (:*unnamed* nil :alias ("identifier") :name ("identifier" "string"))) 
 ("import_statement" (:*unnamed* ("import_clause" "import_require_clause") :source ("string"))) 
 ("index_signature" (:*unnamed* ("mapped_type_clause") :index_type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :name ("identifier") :sign nil :type ("omitting_type_annotation" "type_annotation" "opting_type_annotation"))) 
 ("index_type_query" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("infer_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("instantiation_expression" (:*unnamed* ("expression") :function ("member_expression" "identifier" "import" "subscript_expression") :type_arguments ("type_arguments"))) 
 ("interface_declaration" (:*unnamed* ("extends_type_clause") :body ("object_type") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("internal_module" (:*unnamed* nil :body ("statement_block") :name ("identifier" "string" "nested_identifier"))) 
 ("intersection_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("jsx_attribute" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_self_closing_element" "string" "jsx_namespace_name" "property_identifier"))) 
 ("jsx_closing_element" (:*unnamed* nil :name ("jsx_namespace_name" "identifier" "member_expression"))) 
 ("jsx_element" (:*unnamed* ("jsx_self_closing_element" "jsx_expression" "jsx_element" "jsx_text") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element"))) 
 ("jsx_expression" (:*unnamed* ("expression" "sequence_expression" "spread_element"))) 
 ("jsx_namespace_name" (:*unnamed* ("identifier"))) 
 ("jsx_opening_element" (:*unnamed* nil :attribute ("jsx_attribute" "jsx_expression") :name ("jsx_namespace_name" "identifier" "member_expression") :type_arguments ("type_arguments"))) 
 ("jsx_self_closing_element" (:*unnamed* nil :attribute ("jsx_attribute" "jsx_expression") :name ("jsx_namespace_name" "identifier" "member_expression") :type_arguments ("type_arguments"))) 
 ("jsx_text" (:*unnamed* nil)) 
 ("labeled_statement" (:*unnamed* nil :body ("statement") :label ("statement_identifier"))) 
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil)) 
 ("literal_type" (:*unnamed* ("false" "unary_expression" "undefined" "string" "null" "true" "number"))) 
 ("lookup_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("mapped_type_clause" (:*unnamed* nil :alias ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type") :name ("type_identifier") :type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("member_expression" (:*unnamed* ("member_expression" "identifier" "property_identifier") :object ("expression") :optional_chain ("optional_chain") :property ("private_property_identifier" "property_identifier"))) 
 ("meta_property" (:*unnamed* nil)) 
 ("method_definition" (:*unnamed* ("accessibility_modifier" "override_modifier") :body ("statement_block") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("method_signature" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :parameters ("formal_parameters") :return_type ("type_annotation" "type_predicate_annotation" "asserts_annotation") :type_parameters ("type_parameters"))) 
 ("module" (:*unnamed* nil :body ("statement_block") :name ("identifier" "string" "nested_identifier"))) 
 ("named_imports" (:*unnamed* ("import_specifier"))) 
 ("namespace_export" (:*unnamed* ("identifier" "string"))) 
 ("namespace_import" (:*unnamed* ("identifier"))) 
 ("nested_identifier" (:*unnamed* ("member_expression" "identifier" "property_identifier"))) 
 ("nested_type_identifier" (:*unnamed* nil :module ("identifier" "nested_identifier") :name ("type_identifier"))) 
 ("new_expression" (:*unnamed* nil :arguments ("arguments") :constructor ("primary_expression") :type_arguments ("type_arguments"))) 
 ("non_null_expression" (:*unnamed* ("expression"))) 
 ("null" (:*unnamed* nil)) 
 ("number" (:*unnamed* nil)) 
 ("object" (:*unnamed* ("shorthand_property_identifier" "pair" "method_definition" "spread_element"))) 
 ("object_assignment_pattern" (:*unnamed* nil :left ("array_pattern" "object_pattern" "shorthand_property_identifier_pattern") :right ("expression"))) 
 ("object_pattern" (:*unnamed* ("rest_pattern" "object_assignment_pattern" "pair_pattern" "shorthand_property_identifier_pattern"))) 
 ("object_type" (:*unnamed* ("property_signature" "index_signature" "method_signature" "construct_signature" "export_statement" "call_signature"))) 
 ("omitting_type_annotation" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("opting_type_annotation" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("optional_chain" (:*unnamed* nil)) 
 ("optional_parameter" (:*unnamed* ("accessibility_modifier" "override_modifier") :decorator ("decorator") :name ("identifier") :pattern ("this" "pattern") :type ("type_annotation") :value ("expression"))) 
 ("optional_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("override_modifier" (:*unnamed* nil)) 
 ("pair" (:*unnamed* nil :key ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("expression"))) 
 ("pair_pattern" (:*unnamed* nil :key ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("assignment_pattern" "pattern"))) 
 ("parenthesized_expression" (:*unnamed* ("expression" "sequence_expression") :type ("type_annotation"))) 
 ("parenthesized_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("pattern" (:*unnamed* ("rest_pattern" "array_pattern" "undefined" "identifier" "non_null_expression" "member_expression" "subscript_expression" "object_pattern"))) 
 ("predefined_type" (:*unnamed* nil)) 
 ("primary_expression" (:*unnamed* ("array" "import" "regex" "false" "member_expression" "object" "template_string" "string" "arrow_function" "super" "undefined" "function" "null" "identifier" "meta_property" "number" "non_null_expression" "generator_function" "this" "class" "subscript_expression" "call_expression" "true" "parenthesized_expression"))) 
 ("private_property_identifier" (:*unnamed* nil)) 
 ("program" (:*unnamed* ("statement" "hash_bang_line"))) 
 ("property_identifier" (:*unnamed* nil)) 
 ("property_signature" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :type ("type_annotation"))) 
 ("public_field_definition" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :type ("type_annotation") :value ("expression"))) 
 ("readonly_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("regex" (:*unnamed* nil :flags ("regex_flags") :pattern ("regex_pattern"))) 
 ("regex_flags" (:*unnamed* nil)) 
 ("regex_pattern" (:*unnamed* nil)) 
 ("required_parameter" (:*unnamed* ("accessibility_modifier" "override_modifier") :decorator ("decorator") :name ("rest_pattern" "identifier") :pattern ("this" "pattern") :type ("type_annotation") :value ("expression"))) 
 ("rest_pattern" (:*unnamed* ("member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression" "non_null_expression"))) 
 ("rest_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("return_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("satisfies_expression" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "expression" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("sequence_expression" (:*unnamed* nil :left ("expression") :right ("expression" "sequence_expression"))) 
 ("shorthand_property_identifier" (:*unnamed* nil)) 
 ("shorthand_property_identifier_pattern" (:*unnamed* nil)) 
 ("spread_element" (:*unnamed* ("expression"))) 
 ("statement" (:*unnamed* ("while_statement" "labeled_statement" "return_statement" "for_in_statement" "try_statement" "switch_statement" "break_statement" "debugger_statement" "continue_statement" "export_statement" "declaration" "do_statement" "empty_statement" "with_statement" "throw_statement" "statement_block" "for_statement" "if_statement" "expression_statement" "import_statement"))) 
 ("statement_block" (:*unnamed* ("statement"))) 
 ("statement_identifier" (:*unnamed* nil)) 
 ("string" (:*unnamed* ("escape_sequence" "string_fragment"))) 
 ("string_fragment" (:*unnamed* nil)) 
 ("subscript_expression" (:*unnamed* nil :index ("expression" "number" "sequence_expression" "string" "predefined_type") :object ("expression") :optional_chain ("optional_chain"))) 
 ("super" (:*unnamed* nil)) 
 ("switch_body" (:*unnamed* ("switch_case" "switch_default"))) 
 ("switch_case" (:*unnamed* nil :body ("statement") :value ("expression" "sequence_expression"))) 
 ("switch_default" (:*unnamed* nil :body ("statement"))) 
 ("switch_statement" (:*unnamed* nil :body ("switch_body") :value ("parenthesized_expression"))) 
 ("template_literal_type" (:*unnamed* ("template_type"))) 
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution"))) 
 ("template_substitution" (:*unnamed* ("expression" "sequence_expression"))) 
 ("template_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "flow_maybe_type"))) 
 ("ternary_expression" (:*unnamed* nil :alternative ("expression") :condition ("expression") :consequence ("expression"))) 
 ("this" (:*unnamed* nil)) 
 ("this_type" (:*unnamed* nil)) 
 ("throw_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("true" (:*unnamed* nil)) 
 ("try_statement" (:*unnamed* nil :body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause"))) 
 ("tuple_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "optional_parameter" "predefined_type" "intersection_type" "this_type" "conditional_type" "required_parameter" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "optional_type" "rest_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_alias_declaration" (:*unnamed* nil :name ("type_identifier") :type_parameters ("type_parameters") :value ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_annotation" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_arguments" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_assertion" (:*unnamed* ("expression" "type_arguments"))) 
 ("type_identifier" (:*unnamed* nil)) 
 ("type_parameter" (:*unnamed* nil :constraint ("constraint") :name ("type_identifier") :value ("default_type"))) 
 ("type_parameters" (:*unnamed* ("type_parameter"))) 
 ("type_predicate" (:*unnamed* nil :name ("identifier" "this") :type ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("type_predicate_annotation" (:*unnamed* ("type_predicate"))) 
 ("type_query" (:*unnamed* ("instantiation_expression" "member_expression" "identifier" "call_expression" "subscript_expression"))) 
 ("unary_expression" (:*unnamed* nil :argument ("expression" "number") :operator nil)) 
 ("undefined" (:*unnamed* nil)) 
 ("union_type" (:*unnamed* ("existential_type" "index_type_query" "parenthesized_type" "type_query" "predefined_type" "intersection_type" "this_type" "conditional_type" "union_type" "generic_type" "tuple_type" "lookup_type" "template_literal_type" "literal_type" "function_type" "object_type" "infer_type" "nested_type_identifier" "array_type" "type_identifier" "constructor_type" "readonly_type" "flow_maybe_type"))) 
 ("update_expression" (:*unnamed* nil :argument ("expression") :operator nil)) 
 ("variable_declaration" (:*unnamed* ("variable_declarator"))) 
 ("variable_declarator" (:*unnamed* nil :name ("identifier" "array_pattern" "object_pattern") :type ("type_annotation") :value ("expression"))) 
 ("while_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression"))) 
 ("with_statement" (:*unnamed* nil :body ("statement") :object ("parenthesized_expression"))) 
 ("yield_expression" (:*unnamed* ("expression"))) 
))
;; END Production rules for typescript
;; START Inverse production rules for typescript
(defconst combobulate-rules-typescript-inverse 
 '(("abstract_class_declaration" ("declaration"))
   ("abstract_method_signature" ("class_body"))
   ("accessibility_modifier" ("public_field_definition" "method_definition" "optional_parameter" "abstract_method_signature" "required_parameter" "property_signature" "method_signature"))
   ("ambient_declaration" ("declaration"))
   ("arguments" ("call_expression" "new_expression"))
   ("array" ("primary_expression"))
   ("array_pattern" ("rest_pattern" "assignment_expression" "for_in_statement" "variable_declarator" "object_assignment_pattern" "pattern" "catch_clause"))
   ("array_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("arrow_function" ("primary_expression"))
   ("as_expression" ("expression"))
   ("asserts" ("function_type" "asserts_annotation"))
   ("asserts_annotation" ("method_definition" "function" "abstract_method_signature" "generator_function" "function_declaration" "function_signature" "method_signature" "call_signature" "arrow_function" "generator_function_declaration"))
   ("assignment_expression" ("expression"))
   ("assignment_pattern" ("pair_pattern" "array_pattern"))
   ("augmented_assignment_expression" ("expression"))
   ("await_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("break_statement" ("statement"))
   ("call_expression" ("type_query" "decorator" "primary_expression"))
   ("call_signature" ("object_type"))
   ("catch_clause" ("try_statement"))
   ("class" ("primary_expression"))
   ("class_body" ("class" "class_declaration" "abstract_class_declaration"))
   ("class_declaration" ("declaration"))
   ("class_heritage" ("class" "class_declaration" "abstract_class_declaration"))
   ("class_static_block" ("class_body"))
   ("computed_property_name" ("public_field_definition" "method_definition" "enum_body" "abstract_method_signature" "pair" "pair_pattern" "property_signature" "method_signature" "enum_assignment"))
   ("conditional_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("constraint" ("type_parameter"))
   ("construct_signature" ("object_type"))
   ("constructor_type" ("as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "optional_type" "rest_type" "readonly_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("continue_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "export_statement" "ambient_declaration"))
   ("decorator" ("class_body" "optional_parameter" "class_declaration" "export_statement" "required_parameter" "abstract_class_declaration" "class"))
   ("default_type" ("type_parameter"))
   ("do_statement" ("statement"))
   ("else_clause" ("if_statement"))
   ("empty_statement" ("statement" "for_statement"))
   ("enum_assignment" ("enum_body"))
   ("enum_body" ("enum_declaration"))
   ("enum_declaration" ("declaration"))
   ("escape_sequence" ("template_string" "string"))
   ("existential_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("export_clause" ("export_statement"))
   ("export_specifier" ("export_clause"))
   ("export_statement" ("statement" "object_type"))
   ("expression" ("as_expression" "optional_parameter" "for_in_statement" "member_expression" "arrow_function" "template_substitution" "assignment_expression" "yield_expression" "export_statement" "pair" "throw_statement" "for_statement" "extends_clause" "call_expression" "arguments" "parenthesized_expression" "return_statement" "augmented_assignment_expression" "await_expression" "public_field_definition" "ternary_expression" "array" "jsx_expression" "required_parameter" "binary_expression" "type_assertion" "instantiation_expression" "variable_declarator" "object_assignment_pattern" "sequence_expression" "update_expression" "computed_property_name" "satisfies_expression" "enum_assignment" "assignment_pattern" "unary_expression" "non_null_expression" "spread_element" "switch_case" "subscript_expression" "expression_statement"))
   ("expression_statement" ("statement" "for_statement"))
   ("extends_clause" ("class_heritage"))
   ("extends_type_clause" ("interface_declaration"))
   ("false" ("literal_type" "primary_expression"))
   ("finally_clause" ("try_statement"))
   ("flow_maybe_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("for_in_statement" ("statement"))
   ("for_statement" ("statement"))
   ("formal_parameters" ("function_type" "method_definition" "function" "abstract_method_signature" "generator_function_declaration" "generator_function" "function_declaration" "constructor_type" "function_signature" "call_signature" "method_signature" "arrow_function" "construct_signature"))
   ("function" ("primary_expression"))
   ("function_declaration" ("declaration"))
   ("function_signature" ("declaration"))
   ("function_type" ("as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "optional_type" "rest_type" "readonly_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("generator_function" ("primary_expression"))
   ("generator_function_declaration" ("declaration"))
   ("generic_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "extends_type_clause" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("glimmer_template" ("expression"))
   ("hash_bang_line" ("program"))
   ("identifier" ("optional_parameter" "jsx_opening_element" "for_in_statement" "member_expression" "primary_expression" "nested_identifier" "arrow_function" "import_specifier" "jsx_closing_element" "import_require_clause" "assignment_expression" "function" "export_statement" "export_specifier" "generator_function" "function_signature" "catch_clause" "asserts" "augmented_assignment_expression" "rest_pattern" "type_query" "required_parameter" "instantiation_expression" "variable_declarator" "type_predicate" "internal_module" "jsx_self_closing_element" "namespace_import" "import_alias" "import_clause" "namespace_export" "index_signature" "module" "enum_declaration" "jsx_namespace_name" "nested_type_identifier" "decorator" "pattern" "function_declaration" "generator_function_declaration"))
   ("if_statement" ("statement"))
   ("implements_clause" ("class_heritage"))
   ("import" ("instantiation_expression" "primary_expression"))
   ("import_alias" ("declaration"))
   ("import_clause" ("import_statement"))
   ("import_require_clause" ("import_statement"))
   ("import_specifier" ("named_imports"))
   ("import_statement" ("statement"))
   ("index_signature" ("class_body" "object_type"))
   ("index_type_query" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("infer_type" ("as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "optional_type" "template_type" "rest_type" "readonly_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("instantiation_expression" ("expression" "type_query"))
   ("interface_declaration" ("declaration"))
   ("internal_module" ("expression" "declaration"))
   ("intersection_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_element" ("jsx_attribute" "jsx_element"))
   ("jsx_expression" ("jsx_attribute" "jsx_opening_element" "jsx_self_closing_element" "jsx_element"))
   ("jsx_namespace_name" ("jsx_attribute" "jsx_closing_element" "jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_self_closing_element" ("jsx_attribute" "jsx_element"))
   ("jsx_text" ("jsx_element"))
   ("labeled_statement" ("statement"))
   ("lexical_declaration" ("for_statement" "declaration"))
   ("literal_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("lookup_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("mapped_type_clause" ("index_signature"))
   ("member_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "type_query" "jsx_opening_element" "decorator" "for_in_statement" "instantiation_expression" "member_expression" "pattern" "primary_expression" "jsx_self_closing_element" "nested_identifier" "jsx_closing_element"))
   ("meta_property" ("primary_expression"))
   ("method_definition" ("object" "class_body"))
   ("method_signature" ("class_body" "object_type"))
   ("module" ("declaration"))
   ("named_imports" ("import_clause"))
   ("namespace_export" ("export_statement"))
   ("namespace_import" ("import_clause"))
   ("nested_identifier" ("import_alias" "nested_type_identifier" "internal_module" "module"))
   ("nested_type_identifier" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "extends_type_clause" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "generic_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("new_expression" ("expression"))
   ("non_null_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "for_in_statement" "pattern" "primary_expression"))
   ("null" ("literal_type" "primary_expression"))
   ("number" ("unary_expression" "literal_type" "method_definition" "enum_body" "public_field_definition" "abstract_method_signature" "pair" "pair_pattern" "subscript_expression" "property_signature" "primary_expression" "method_signature" "enum_assignment"))
   ("object" ("primary_expression"))
   ("object_assignment_pattern" ("object_pattern"))
   ("object_pattern" ("rest_pattern" "assignment_expression" "for_in_statement" "variable_declarator" "object_assignment_pattern" "pattern" "catch_clause"))
   ("object_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "interface_declaration" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("omitting_type_annotation" ("index_signature"))
   ("opting_type_annotation" ("index_signature"))
   ("optional_chain" ("member_expression" "subscript_expression"))
   ("optional_parameter" ("tuple_type" "formal_parameters"))
   ("optional_type" ("tuple_type"))
   ("override_modifier" ("public_field_definition" "method_definition" "optional_parameter" "required_parameter" "property_signature" "method_signature"))
   ("pair" ("object"))
   ("pair_pattern" ("object_pattern"))
   ("parenthesized_expression" ("augmented_assignment_expression" "while_statement" "assignment_expression" "do_statement" "for_in_statement" "switch_statement" "with_statement" "primary_expression" "if_statement"))
   ("parenthesized_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("pattern" ("assignment_pattern" "array_pattern" "optional_parameter" "required_parameter" "pair_pattern"))
   ("predefined_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "type_alias_declaration" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "subscript_expression" "mapped_type_clause"))
   ("primary_expression" ("expression" "new_expression"))
   ("private_property_identifier" ("public_field_definition" "method_definition" "enum_body" "abstract_method_signature" "pair" "pair_pattern" "property_signature" "member_expression" "method_signature" "enum_assignment"))
   ("property_identifier" ("jsx_attribute" "public_field_definition" "method_definition" "enum_body" "ambient_declaration" "abstract_method_signature" "pair" "pair_pattern" "property_signature" "member_expression" "method_signature" "nested_identifier" "enum_assignment"))
   ("property_signature" ("object_type"))
   ("public_field_definition" ("class_body"))
   ("readonly_type" ("as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "optional_type" "rest_type" "readonly_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("regex" ("primary_expression"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("required_parameter" ("tuple_type" "formal_parameters"))
   ("rest_pattern" ("required_parameter" "pattern" "object_pattern"))
   ("rest_type" ("tuple_type"))
   ("return_statement" ("statement"))
   ("satisfies_expression" ("expression"))
   ("sequence_expression" ("jsx_expression" "return_statement" "for_in_statement" "sequence_expression" "throw_statement" "switch_case" "for_statement" "subscript_expression" "expression_statement" "template_substitution" "parenthesized_expression"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_assignment_pattern" "object_pattern"))
   ("spread_element" ("object" "jsx_expression" "array" "arguments"))
   ("statement" ("while_statement" "labeled_statement" "program" "do_statement" "for_in_statement" "with_statement" "statement_block" "switch_case" "for_statement" "else_clause" "if_statement" "switch_default"))
   ("statement_block" ("method_definition" "finally_clause" "ambient_declaration" "module" "function" "class_static_block" "try_statement" "statement" "generator_function" "function_declaration" "catch_clause" "internal_module" "arrow_function" "generator_function_declaration"))
   ("statement_identifier" ("break_statement" "continue_statement" "labeled_statement"))
   ("string" ("enum_body" "primary_expression" "method_signature" "import_specifier" "import_require_clause" "jsx_attribute" "literal_type" "method_definition" "export_statement" "pair" "export_specifier" "import_statement" "public_field_definition" "abstract_method_signature" "internal_module" "enum_assignment" "namespace_export" "module" "pair_pattern" "property_signature" "subscript_expression"))
   ("string_fragment" ("string"))
   ("subscript_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "type_query" "for_in_statement" "instantiation_expression" "pattern" "primary_expression"))
   ("super" ("primary_expression"))
   ("switch_body" ("switch_statement"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_statement" ("statement"))
   ("template_literal_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("template_string" ("call_expression" "primary_expression"))
   ("template_substitution" ("template_string"))
   ("template_type" ("template_literal_type"))
   ("ternary_expression" ("expression"))
   ("this" ("optional_parameter" "required_parameter" "type_predicate" "primary_expression" "asserts"))
   ("this_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("throw_statement" ("statement"))
   ("true" ("literal_type" "primary_expression"))
   ("try_statement" ("statement"))
   ("tuple_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("type_alias_declaration" ("declaration"))
   ("type_annotation" ("optional_parameter" "method_signature" "call_signature" "arrow_function" "method_definition" "function" "generator_function" "function_signature" "catch_clause" "construct_signature" "parenthesized_expression" "public_field_definition" "abstract_method_signature" "required_parameter" "variable_declarator" "index_signature" "property_signature" "function_declaration" "generator_function_declaration"))
   ("type_arguments" ("jsx_opening_element" "type_assertion" "new_expression" "instantiation_expression" "generic_type" "jsx_self_closing_element" "extends_clause" "call_expression"))
   ("type_assertion" ("expression"))
   ("type_identifier" ("index_type_query" "as_expression" "omitting_type_annotation" "class_declaration" "intersection_type" "conditional_type" "default_type" "abstract_class_declaration" "extends_type_clause" "type_arguments" "type_parameter" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "class" "flow_maybe_type" "interface_declaration" "parenthesized_type" "union_type" "generic_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "_primary_type" "lookup_type" "function_type" "ambient_declaration" "index_signature" "nested_type_identifier" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("type_parameter" ("type_parameters"))
   ("type_parameters" ("interface_declaration" "function_type" "method_definition" "type_alias_declaration" "function" "abstract_method_signature" "class_declaration" "generator_function_declaration" "generator_function" "abstract_class_declaration" "constructor_type" "function_declaration" "call_signature" "class" "arrow_function" "function_signature" "method_signature" "construct_signature"))
   ("type_predicate" ("type_predicate_annotation" "function_type" "asserts"))
   ("type_predicate_annotation" ("method_definition" "function" "abstract_method_signature" "generator_function" "function_declaration" "function_signature" "method_signature" "call_signature" "arrow_function" "generator_function_declaration"))
   ("type_query" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("unary_expression" ("expression" "literal_type"))
   ("undefined" ("rest_pattern" "literal_type" "assignment_expression" "for_in_statement" "pattern" "primary_expression"))
   ("union_type" ("index_type_query" "as_expression" "omitting_type_annotation" "intersection_type" "conditional_type" "default_type" "type_arguments" "opting_type_annotation" "infer_type" "array_type" "optional_type" "template_type" "rest_type" "readonly_type" "flow_maybe_type" "parenthesized_type" "union_type" "type_predicate" "tuple_type" "constraint" "satisfies_expression" "lookup_type" "_primary_type" "function_type" "ambient_declaration" "index_signature" "implements_clause" "constructor_type" "type_annotation" "type_alias_declaration" "mapped_type_clause"))
   ("update_expression" ("expression"))
   ("variable_declaration" ("for_statement" "declaration"))
   ("variable_declarator" ("variable_declaration" "lexical_declaration"))
   ("while_statement" ("statement"))
   ("with_statement" ("statement"))
   ("yield_expression" ("expression"))
  ) 
)
;; END Inverse production rules for typescript
;; START All node types in typescript
(defconst combobulate-rules-typescript-types 
 '("_primary_type" "abstract_class_declaration" "abstract_method_signature" "accessibility_modifier" "ambient_declaration" "arguments" "array" "array_pattern" "array_type" "arrow_function" "as_expression" "asserts" "asserts_annotation" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "call_signature" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "conditional_type" "constraint" "construct_signature" "constructor_type" "continue_statement" "debugger_statement" "declaration" "decorator" "default_type" "do_statement" "else_clause" "empty_statement" "enum_assignment" "enum_body" "enum_declaration" "escape_sequence" "existential_type" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "extends_clause" "extends_type_clause" "false" "finally_clause" "flow_maybe_type" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "function_signature" "function_type" "generator_function" "generator_function_declaration" "generic_type" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "implements_clause" "import" "import_alias" "import_clause" "import_require_clause" "import_specifier" "import_statement" "index_signature" "index_type_query" "infer_type" "instantiation_expression" "interface_declaration" "internal_module" "intersection_type" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "literal_type" "lookup_type" "mapped_type_clause" "member_expression" "meta_property" "method_definition" "method_signature" "module" "named_imports" "namespace_export" "namespace_import" "nested_identifier" "nested_type_identifier" "new_expression" "non_null_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "object_type" "omitting_type_annotation" "opting_type_annotation" "optional_chain" "optional_parameter" "optional_type" "override_modifier" "pair" "pair_pattern" "parenthesized_expression" "parenthesized_type" "pattern" "predefined_type" "primary_expression" "private_property_identifier" "program" "property_identifier" "property_signature" "public_field_definition" "readonly_type" "regex" "regex_flags" "regex_pattern" "required_parameter" "rest_pattern" "rest_type" "return_statement" "satisfies_expression" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_literal_type" "template_string" "template_substitution" "template_type" "ternary_expression" "this" "this_type" "throw_statement" "true" "try_statement" "tuple_type" "type_alias_declaration" "type_annotation" "type_arguments" "type_assertion" "type_identifier" "type_parameter" "type_parameters" "type_predicate" "type_predicate_annotation" "type_query" "unary_expression" "undefined" "union_type" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression") 
)
;; END All node types in typescript
;; START All supertypes in typescript
(defconst combobulate-rules-typescript-supertypes 
 '("_primary_type" "declaration" "expression" "pattern" "primary_expression" "statement") 
)
;; END All supertypes in typescript

;; START Production rules for javascript
(defconst combobulate-rules-javascript 
 '(("arguments" (:*unnamed* ("expression" "spread_element"))) 
 ("array" (:*unnamed* ("expression" "spread_element"))) 
 ("array_pattern" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("arrow_function" (:*unnamed* nil :body ("expression" "statement_block") :parameter ("identifier") :parameters ("formal_parameters"))) 
 ("assignment_expression" (:*unnamed* nil :left ("member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression" "parenthesized_expression") :right ("expression"))) 
 ("assignment_pattern" (:*unnamed* nil :left ("pattern") :right ("expression"))) 
 ("augmented_assignment_expression" (:*unnamed* nil :left ("member_expression" "identifier" "subscript_expression" "parenthesized_expression") :operator nil :right ("expression"))) 
 ("await_expression" (:*unnamed* ("expression"))) 
 ("binary_expression" (:*unnamed* nil :left ("private_property_identifier" "expression") :operator nil :right ("expression"))) 
 ("break_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("call_expression" (:*unnamed* nil :arguments ("template_string" "arguments") :function ("expression" "import") :optional_chain ("optional_chain"))) 
 ("catch_clause" (:*unnamed* nil :body ("statement_block") :parameter ("identifier" "array_pattern" "object_pattern"))) 
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier"))) 
 ("class_body" (:*unnamed* nil :member ("field_definition" "class_static_block" "method_definition") :template ("glimmer_template"))) 
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier"))) 
 ("class_heritage" (:*unnamed* ("expression"))) 
 ("class_static_block" (:*unnamed* nil :body ("statement_block"))) 
 ("comment" (:*unnamed* nil)) 
 ("computed_property_name" (:*unnamed* ("expression"))) 
 ("continue_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("debugger_statement" (:*unnamed* nil)) 
 ("declaration" (:*unnamed* ("function_declaration" "generator_function_declaration" "class_declaration" "variable_declaration" "lexical_declaration"))) 
 ("decorator" (:*unnamed* ("member_expression" "identifier" "call_expression"))) 
 ("do_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("statement"))) 
 ("empty_statement" (:*unnamed* nil)) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("export_clause" (:*unnamed* ("export_specifier"))) 
 ("export_specifier" (:*unnamed* nil :alias ("identifier" "string") :name ("identifier" "string"))) 
 ("export_statement" (:*unnamed* ("namespace_export" "export_clause") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression"))) 
 ("expression" (:*unnamed* ("ternary_expression" "augmented_assignment_expression" "await_expression" "unary_expression" "assignment_expression" "jsx_element" "yield_expression" "binary_expression" "new_expression" "update_expression" "jsx_self_closing_element" "primary_expression" "glimmer_template"))) 
 ("expression_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("false" (:*unnamed* nil)) 
 ("field_definition" (:*unnamed* nil :decorator ("decorator") :property ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("expression"))) 
 ("finally_clause" (:*unnamed* nil :body ("statement_block"))) 
 ("for_in_statement" (:*unnamed* nil :body ("statement") :kind nil :left ("member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression" "parenthesized_expression") :operator nil :right ("expression" "sequence_expression") :value ("expression"))) 
 ("for_statement" (:*unnamed* nil :body ("statement") :condition ("empty_statement" "expression_statement") :increment ("expression" "sequence_expression") :initializer ("lexical_declaration" "empty_statement" "expression_statement" "variable_declaration"))) 
 ("formal_parameters" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("function_expression" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("generator_function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("generator_function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("glimmer_closing_tag" (:*unnamed* nil)) 
 ("glimmer_opening_tag" (:*unnamed* nil)) 
 ("glimmer_template" (:*unnamed* nil :close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag"))) 
 ("hash_bang_line" (:*unnamed* nil)) 
 ("html_character_reference" (:*unnamed* nil)) 
 ("html_comment" (:*unnamed* nil)) 
 ("identifier" (:*unnamed* nil)) 
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement"))) 
 ("import" (:*unnamed* nil)) 
 ("import_attribute" (:*unnamed* ("object"))) 
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports"))) 
 ("import_specifier" (:*unnamed* nil :alias ("identifier") :name ("identifier" "string"))) 
 ("import_statement" (:*unnamed* ("import_attribute" "import_clause") :source ("string"))) 
 ("jsx_attribute" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_self_closing_element" "string" "jsx_namespace_name" "property_identifier"))) 
 ("jsx_closing_element" (:*unnamed* nil :name ("jsx_namespace_name" "identifier" "member_expression"))) 
 ("jsx_element" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_self_closing_element" "html_character_reference" "jsx_text") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element"))) 
 ("jsx_expression" (:*unnamed* ("expression" "sequence_expression" "spread_element"))) 
 ("jsx_namespace_name" (:*unnamed* ("identifier"))) 
 ("jsx_opening_element" (:*unnamed* nil :attribute ("jsx_attribute" "jsx_expression") :name ("jsx_namespace_name" "identifier" "member_expression"))) 
 ("jsx_self_closing_element" (:*unnamed* nil :attribute ("jsx_attribute" "jsx_expression") :name ("jsx_namespace_name" "identifier" "member_expression"))) 
 ("jsx_text" (:*unnamed* nil)) 
 ("labeled_statement" (:*unnamed* nil :body ("statement") :label ("statement_identifier"))) 
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil)) 
 ("member_expression" (:*unnamed* nil :object ("expression" "import") :optional_chain ("optional_chain") :property ("private_property_identifier" "property_identifier"))) 
 ("meta_property" (:*unnamed* nil)) 
 ("method_definition" (:*unnamed* nil :body ("statement_block") :decorator ("decorator") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :parameters ("formal_parameters"))) 
 ("named_imports" (:*unnamed* ("import_specifier"))) 
 ("namespace_export" (:*unnamed* ("identifier" "string"))) 
 ("namespace_import" (:*unnamed* ("identifier"))) 
 ("new_expression" (:*unnamed* nil :arguments ("arguments") :constructor ("primary_expression" "new_expression"))) 
 ("null" (:*unnamed* nil)) 
 ("number" (:*unnamed* nil)) 
 ("object" (:*unnamed* ("shorthand_property_identifier" "pair" "method_definition" "spread_element"))) 
 ("object_assignment_pattern" (:*unnamed* nil :left ("array_pattern" "object_pattern" "shorthand_property_identifier_pattern") :right ("expression"))) 
 ("object_pattern" (:*unnamed* ("rest_pattern" "object_assignment_pattern" "pair_pattern" "shorthand_property_identifier_pattern"))) 
 ("optional_chain" (:*unnamed* nil)) 
 ("pair" (:*unnamed* nil :key ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("expression"))) 
 ("pair_pattern" (:*unnamed* nil :key ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("assignment_pattern" "pattern"))) 
 ("parenthesized_expression" (:*unnamed* ("expression" "sequence_expression"))) 
 ("pattern" (:*unnamed* ("rest_pattern" "member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression"))) 
 ("primary_expression" (:*unnamed* ("array" "function_expression" "regex" "false" "member_expression" "object" "template_string" "string" "arrow_function" "super" "undefined" "null" "identifier" "meta_property" "number" "generator_function" "this" "class" "subscript_expression" "call_expression" "true" "parenthesized_expression"))) 
 ("private_property_identifier" (:*unnamed* nil)) 
 ("program" (:*unnamed* ("statement" "hash_bang_line"))) 
 ("property_identifier" (:*unnamed* nil)) 
 ("regex" (:*unnamed* nil :flags ("regex_flags") :pattern ("regex_pattern"))) 
 ("regex_flags" (:*unnamed* nil)) 
 ("regex_pattern" (:*unnamed* nil)) 
 ("rest_pattern" (:*unnamed* ("member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression"))) 
 ("return_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("sequence_expression" (:*unnamed* ("expression"))) 
 ("shorthand_property_identifier" (:*unnamed* nil)) 
 ("shorthand_property_identifier_pattern" (:*unnamed* nil)) 
 ("spread_element" (:*unnamed* ("expression"))) 
 ("statement" (:*unnamed* ("while_statement" "labeled_statement" "return_statement" "for_in_statement" "try_statement" "switch_statement" "break_statement" "debugger_statement" "continue_statement" "export_statement" "declaration" "do_statement" "empty_statement" "with_statement" "throw_statement" "statement_block" "for_statement" "if_statement" "expression_statement" "import_statement"))) 
 ("statement_block" (:*unnamed* ("statement"))) 
 ("statement_identifier" (:*unnamed* nil)) 
 ("string" (:*unnamed* ("escape_sequence" "string_fragment" "html_character_reference"))) 
 ("string_fragment" (:*unnamed* nil)) 
 ("subscript_expression" (:*unnamed* nil :index ("expression" "sequence_expression") :object ("expression") :optional_chain ("optional_chain"))) 
 ("super" (:*unnamed* nil)) 
 ("switch_body" (:*unnamed* ("switch_case" "switch_default"))) 
 ("switch_case" (:*unnamed* nil :body ("statement") :value ("expression" "sequence_expression"))) 
 ("switch_default" (:*unnamed* nil :body ("statement"))) 
 ("switch_statement" (:*unnamed* nil :body ("switch_body") :value ("parenthesized_expression"))) 
 ("template_string" (:*unnamed* ("escape_sequence" "string_fragment" "template_substitution"))) 
 ("template_substitution" (:*unnamed* ("expression" "sequence_expression"))) 
 ("ternary_expression" (:*unnamed* nil :alternative ("expression") :condition ("expression") :consequence ("expression"))) 
 ("this" (:*unnamed* nil)) 
 ("throw_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("true" (:*unnamed* nil)) 
 ("try_statement" (:*unnamed* nil :body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause"))) 
 ("unary_expression" (:*unnamed* nil :argument ("expression") :operator nil)) 
 ("undefined" (:*unnamed* nil)) 
 ("update_expression" (:*unnamed* nil :argument ("expression") :operator nil)) 
 ("variable_declaration" (:*unnamed* ("variable_declarator"))) 
 ("variable_declarator" (:*unnamed* nil :name ("identifier" "array_pattern" "object_pattern") :value ("expression"))) 
 ("while_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression"))) 
 ("with_statement" (:*unnamed* nil :body ("statement") :object ("parenthesized_expression"))) 
 ("yield_expression" (:*unnamed* ("expression"))) 
))
;; END Production rules for javascript
;; START Inverse production rules for javascript
(defconst combobulate-rules-javascript-inverse 
 '(("arguments" ("call_expression" "new_expression"))
   ("array" ("primary_expression"))
   ("array_pattern" ("rest_pattern" "assignment_expression" "for_in_statement" "variable_declarator" "object_assignment_pattern" "pattern" "catch_clause"))
   ("arrow_function" ("primary_expression"))
   ("assignment_expression" ("expression"))
   ("assignment_pattern" ("pair_pattern" "array_pattern" "formal_parameters"))
   ("augmented_assignment_expression" ("expression"))
   ("await_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("break_statement" ("statement"))
   ("call_expression" ("decorator" "primary_expression"))
   ("catch_clause" ("try_statement"))
   ("class" ("primary_expression"))
   ("class_body" ("class" "class_declaration"))
   ("class_declaration" ("declaration"))
   ("class_heritage" ("class" "class_declaration"))
   ("class_static_block" ("class_body"))
   ("computed_property_name" ("field_definition" "pair" "method_definition" "pair_pattern"))
   ("continue_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "export_statement"))
   ("decorator" ("method_definition" "class_declaration" "export_statement" "field_definition" "class"))
   ("do_statement" ("statement"))
   ("else_clause" ("if_statement"))
   ("empty_statement" ("statement" "for_statement"))
   ("escape_sequence" ("template_string" "string"))
   ("export_clause" ("export_statement"))
   ("export_specifier" ("export_clause"))
   ("export_statement" ("statement"))
   ("expression" ("for_in_statement" "field_definition" "member_expression" "arrow_function" "class_heritage" "template_substitution" "assignment_expression" "yield_expression" "export_statement" "pair" "throw_statement" "for_statement" "call_expression" "arguments" "parenthesized_expression" "return_statement" "augmented_assignment_expression" "await_expression" "ternary_expression" "array" "jsx_expression" "binary_expression" "variable_declarator" "object_assignment_pattern" "sequence_expression" "update_expression" "computed_property_name" "assignment_pattern" "unary_expression" "spread_element" "switch_case" "subscript_expression" "expression_statement"))
   ("expression_statement" ("statement" "for_statement"))
   ("false" ("primary_expression"))
   ("field_definition" ("class_body"))
   ("finally_clause" ("try_statement"))
   ("for_in_statement" ("statement"))
   ("for_statement" ("statement"))
   ("formal_parameters" ("method_definition" "function_expression" "generator_function" "function_declaration" "arrow_function" "generator_function_declaration"))
   ("function_declaration" ("declaration"))
   ("function_expression" ("primary_expression"))
   ("generator_function" ("primary_expression"))
   ("generator_function_declaration" ("declaration"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("glimmer_template" ("expression" "class_body"))
   ("hash_bang_line" ("program"))
   ("html_character_reference" ("jsx_element" "string"))
   ("identifier" ("class_declaration" "jsx_opening_element" "function_expression" "for_in_statement" "primary_expression" "arrow_function" "import_specifier" "jsx_closing_element" "assignment_expression" "export_specifier" "generator_function" "catch_clause" "class" "augmented_assignment_expression" "rest_pattern" "variable_declarator" "jsx_self_closing_element" "namespace_import" "import_clause" "namespace_export" "jsx_namespace_name" "decorator" "pattern" "function_declaration" "generator_function_declaration"))
   ("if_statement" ("statement"))
   ("import" ("member_expression" "call_expression"))
   ("import_attribute" ("import_statement"))
   ("import_clause" ("import_statement"))
   ("import_specifier" ("named_imports"))
   ("import_statement" ("statement"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_element" ("jsx_attribute" "expression" "jsx_element"))
   ("jsx_expression" ("jsx_attribute" "jsx_opening_element" "jsx_self_closing_element" "jsx_element"))
   ("jsx_namespace_name" ("jsx_attribute" "jsx_closing_element" "jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_self_closing_element" ("jsx_attribute" "expression" "jsx_element"))
   ("jsx_text" ("jsx_element"))
   ("labeled_statement" ("statement"))
   ("lexical_declaration" ("for_statement" "declaration"))
   ("member_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "jsx_opening_element" "decorator" "for_in_statement" "pattern" "primary_expression" "jsx_self_closing_element" "jsx_closing_element"))
   ("meta_property" ("primary_expression"))
   ("method_definition" ("object" "class_body"))
   ("named_imports" ("import_clause"))
   ("namespace_export" ("export_statement"))
   ("namespace_import" ("import_clause"))
   ("new_expression" ("expression" "new_expression"))
   ("null" ("primary_expression"))
   ("number" ("method_definition" "pair" "pair_pattern" "field_definition" "primary_expression"))
   ("object" ("import_attribute" "primary_expression"))
   ("object_assignment_pattern" ("object_pattern"))
   ("object_pattern" ("rest_pattern" "assignment_expression" "for_in_statement" "variable_declarator" "object_assignment_pattern" "pattern" "catch_clause"))
   ("optional_chain" ("member_expression" "subscript_expression" "call_expression"))
   ("pair" ("object"))
   ("pair_pattern" ("object_pattern"))
   ("parenthesized_expression" ("augmented_assignment_expression" "while_statement" "assignment_expression" "do_statement" "for_in_statement" "switch_statement" "with_statement" "primary_expression" "if_statement"))
   ("pattern" ("pair_pattern" "assignment_pattern" "array_pattern" "formal_parameters"))
   ("primary_expression" ("expression" "new_expression"))
   ("private_property_identifier" ("method_definition" "pair" "pair_pattern" "binary_expression" "field_definition" "member_expression"))
   ("property_identifier" ("jsx_attribute" "method_definition" "pair" "pair_pattern" "field_definition" "member_expression"))
   ("regex" ("primary_expression"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("rest_pattern" ("pattern" "object_pattern"))
   ("return_statement" ("statement"))
   ("sequence_expression" ("jsx_expression" "return_statement" "for_in_statement" "throw_statement" "switch_case" "for_statement" "subscript_expression" "expression_statement" "template_substitution" "parenthesized_expression"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_assignment_pattern" "object_pattern"))
   ("spread_element" ("object" "jsx_expression" "array" "arguments"))
   ("statement" ("while_statement" "labeled_statement" "program" "do_statement" "for_in_statement" "with_statement" "statement_block" "switch_case" "for_statement" "else_clause" "if_statement" "switch_default"))
   ("statement_block" ("method_definition" "finally_clause" "class_static_block" "function_expression" "try_statement" "statement" "generator_function" "function_declaration" "catch_clause" "arrow_function" "generator_function_declaration"))
   ("statement_identifier" ("break_statement" "continue_statement" "labeled_statement"))
   ("string" ("jsx_attribute" "namespace_export" "method_definition" "export_statement" "pair" "pair_pattern" "field_definition" "export_specifier" "primary_expression" "import_statement" "import_specifier"))
   ("string_fragment" ("template_string" "string"))
   ("subscript_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "for_in_statement" "pattern" "primary_expression"))
   ("super" ("primary_expression"))
   ("switch_body" ("switch_statement"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_statement" ("statement"))
   ("template_string" ("call_expression" "primary_expression"))
   ("template_substitution" ("template_string"))
   ("ternary_expression" ("expression"))
   ("this" ("primary_expression"))
   ("throw_statement" ("statement"))
   ("true" ("primary_expression"))
   ("try_statement" ("statement"))
   ("unary_expression" ("expression"))
   ("undefined" ("rest_pattern" "assignment_expression" "for_in_statement" "pattern" "primary_expression"))
   ("update_expression" ("expression"))
   ("variable_declaration" ("for_statement" "declaration"))
   ("variable_declarator" ("variable_declaration" "lexical_declaration"))
   ("while_statement" ("statement"))
   ("with_statement" ("statement"))
   ("yield_expression" ("expression"))
  ) 
)
;; END Inverse production rules for javascript
;; START All node types in javascript
(defconst combobulate-rules-javascript-types 
 '("arguments" "array" "array_pattern" "arrow_function" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "continue_statement" "debugger_statement" "declaration" "decorator" "do_statement" "else_clause" "empty_statement" "escape_sequence" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "false" "field_definition" "finally_clause" "for_in_statement" "for_statement" "formal_parameters" "function_declaration" "function_expression" "generator_function" "generator_function_declaration" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "html_character_reference" "html_comment" "identifier" "if_statement" "import" "import_attribute" "import_clause" "import_specifier" "import_statement" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "member_expression" "meta_property" "method_definition" "named_imports" "namespace_export" "namespace_import" "new_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "optional_chain" "pair" "pair_pattern" "parenthesized_expression" "pattern" "primary_expression" "private_property_identifier" "program" "property_identifier" "regex" "regex_flags" "regex_pattern" "rest_pattern" "return_statement" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_string" "template_substitution" "ternary_expression" "this" "throw_statement" "true" "try_statement" "unary_expression" "undefined" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression") 
)
;; END All node types in javascript
;; START All supertypes in javascript
(defconst combobulate-rules-javascript-supertypes 
 '("declaration" "expression" "pattern" "primary_expression" "statement") 
)
;; END All supertypes in javascript

;; START Production rules for jsx
(defconst combobulate-rules-jsx 
 '(("arguments" (:*unnamed* ("expression" "spread_element"))) 
 ("array" (:*unnamed* ("expression" "spread_element"))) 
 ("array_pattern" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("arrow_function" (:*unnamed* nil :body ("expression" "statement_block") :parameter ("identifier") :parameters ("formal_parameters"))) 
 ("assignment_expression" (:*unnamed* nil :left ("member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression" "parenthesized_expression") :right ("expression"))) 
 ("assignment_pattern" (:*unnamed* nil :left ("pattern") :right ("expression"))) 
 ("augmented_assignment_expression" (:*unnamed* nil :left ("member_expression" "identifier" "subscript_expression" "parenthesized_expression") :operator nil :right ("expression"))) 
 ("await_expression" (:*unnamed* ("expression"))) 
 ("binary_expression" (:*unnamed* nil :left ("private_property_identifier" "expression") :operator nil :right ("expression"))) 
 ("break_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("call_expression" (:*unnamed* nil :arguments ("template_string" "arguments") :function ("expression" "import") :optional_chain ("optional_chain"))) 
 ("catch_clause" (:*unnamed* nil :body ("statement_block") :parameter ("identifier" "array_pattern" "object_pattern"))) 
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier"))) 
 ("class_body" (:*unnamed* nil :member ("field_definition" "class_static_block" "method_definition") :template ("glimmer_template"))) 
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier"))) 
 ("class_heritage" (:*unnamed* ("expression"))) 
 ("class_static_block" (:*unnamed* nil :body ("statement_block"))) 
 ("comment" (:*unnamed* nil)) 
 ("computed_property_name" (:*unnamed* ("expression"))) 
 ("continue_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("debugger_statement" (:*unnamed* nil)) 
 ("declaration" (:*unnamed* ("function_declaration" "generator_function_declaration" "class_declaration" "variable_declaration" "lexical_declaration"))) 
 ("decorator" (:*unnamed* ("member_expression" "identifier" "call_expression"))) 
 ("do_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("statement"))) 
 ("empty_statement" (:*unnamed* nil)) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("export_clause" (:*unnamed* ("export_specifier"))) 
 ("export_specifier" (:*unnamed* nil :alias ("identifier" "string") :name ("identifier" "string"))) 
 ("export_statement" (:*unnamed* ("namespace_export" "export_clause") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression"))) 
 ("expression" (:*unnamed* ("ternary_expression" "augmented_assignment_expression" "await_expression" "unary_expression" "assignment_expression" "jsx_element" "yield_expression" "binary_expression" "new_expression" "update_expression" "jsx_self_closing_element" "primary_expression" "glimmer_template"))) 
 ("expression_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("false" (:*unnamed* nil)) 
 ("field_definition" (:*unnamed* nil :decorator ("decorator") :property ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("expression"))) 
 ("finally_clause" (:*unnamed* nil :body ("statement_block"))) 
 ("for_in_statement" (:*unnamed* nil :body ("statement") :kind nil :left ("member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression" "parenthesized_expression") :operator nil :right ("expression" "sequence_expression") :value ("expression"))) 
 ("for_statement" (:*unnamed* nil :body ("statement") :condition ("empty_statement" "expression_statement") :increment ("expression" "sequence_expression") :initializer ("lexical_declaration" "empty_statement" "expression_statement" "variable_declaration"))) 
 ("formal_parameters" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("function_expression" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("generator_function" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("generator_function_declaration" (:*unnamed* nil :body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("glimmer_closing_tag" (:*unnamed* nil)) 
 ("glimmer_opening_tag" (:*unnamed* nil)) 
 ("glimmer_template" (:*unnamed* nil :close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag"))) 
 ("hash_bang_line" (:*unnamed* nil)) 
 ("html_character_reference" (:*unnamed* nil)) 
 ("html_comment" (:*unnamed* nil)) 
 ("identifier" (:*unnamed* nil)) 
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement"))) 
 ("import" (:*unnamed* nil)) 
 ("import_attribute" (:*unnamed* ("object"))) 
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports"))) 
 ("import_specifier" (:*unnamed* nil :alias ("identifier") :name ("identifier" "string"))) 
 ("import_statement" (:*unnamed* ("import_attribute" "import_clause") :source ("string"))) 
 ("jsx_attribute" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_self_closing_element" "string" "jsx_namespace_name" "property_identifier"))) 
 ("jsx_closing_element" (:*unnamed* nil :name ("jsx_namespace_name" "identifier" "member_expression"))) 
 ("jsx_element" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_self_closing_element" "html_character_reference" "jsx_text") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element"))) 
 ("jsx_expression" (:*unnamed* ("expression" "sequence_expression" "spread_element"))) 
 ("jsx_namespace_name" (:*unnamed* ("identifier"))) 
 ("jsx_opening_element" (:*unnamed* nil :attribute ("jsx_attribute" "jsx_expression") :name ("jsx_namespace_name" "identifier" "member_expression"))) 
 ("jsx_self_closing_element" (:*unnamed* nil :attribute ("jsx_attribute" "jsx_expression") :name ("jsx_namespace_name" "identifier" "member_expression"))) 
 ("jsx_text" (:*unnamed* nil)) 
 ("labeled_statement" (:*unnamed* nil :body ("statement") :label ("statement_identifier"))) 
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil)) 
 ("member_expression" (:*unnamed* nil :object ("expression" "import") :optional_chain ("optional_chain") :property ("private_property_identifier" "property_identifier"))) 
 ("meta_property" (:*unnamed* nil)) 
 ("method_definition" (:*unnamed* nil :body ("statement_block") :decorator ("decorator") :name ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :parameters ("formal_parameters"))) 
 ("named_imports" (:*unnamed* ("import_specifier"))) 
 ("namespace_export" (:*unnamed* ("identifier" "string"))) 
 ("namespace_import" (:*unnamed* ("identifier"))) 
 ("new_expression" (:*unnamed* nil :arguments ("arguments") :constructor ("primary_expression" "new_expression"))) 
 ("null" (:*unnamed* nil)) 
 ("number" (:*unnamed* nil)) 
 ("object" (:*unnamed* ("shorthand_property_identifier" "pair" "method_definition" "spread_element"))) 
 ("object_assignment_pattern" (:*unnamed* nil :left ("array_pattern" "object_pattern" "shorthand_property_identifier_pattern") :right ("expression"))) 
 ("object_pattern" (:*unnamed* ("rest_pattern" "object_assignment_pattern" "pair_pattern" "shorthand_property_identifier_pattern"))) 
 ("optional_chain" (:*unnamed* nil)) 
 ("pair" (:*unnamed* nil :key ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("expression"))) 
 ("pair_pattern" (:*unnamed* nil :key ("private_property_identifier" "computed_property_name" "string" "property_identifier" "number") :value ("assignment_pattern" "pattern"))) 
 ("parenthesized_expression" (:*unnamed* ("expression" "sequence_expression"))) 
 ("pattern" (:*unnamed* ("rest_pattern" "member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression"))) 
 ("primary_expression" (:*unnamed* ("array" "function_expression" "regex" "false" "member_expression" "object" "template_string" "string" "arrow_function" "super" "undefined" "null" "identifier" "meta_property" "number" "generator_function" "this" "class" "subscript_expression" "call_expression" "true" "parenthesized_expression"))) 
 ("private_property_identifier" (:*unnamed* nil)) 
 ("program" (:*unnamed* ("statement" "hash_bang_line"))) 
 ("property_identifier" (:*unnamed* nil)) 
 ("regex" (:*unnamed* nil :flags ("regex_flags") :pattern ("regex_pattern"))) 
 ("regex_flags" (:*unnamed* nil)) 
 ("regex_pattern" (:*unnamed* nil)) 
 ("rest_pattern" (:*unnamed* ("member_expression" "array_pattern" "undefined" "identifier" "object_pattern" "subscript_expression"))) 
 ("return_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("sequence_expression" (:*unnamed* ("expression"))) 
 ("shorthand_property_identifier" (:*unnamed* nil)) 
 ("shorthand_property_identifier_pattern" (:*unnamed* nil)) 
 ("spread_element" (:*unnamed* ("expression"))) 
 ("statement" (:*unnamed* ("while_statement" "labeled_statement" "return_statement" "for_in_statement" "try_statement" "switch_statement" "break_statement" "debugger_statement" "continue_statement" "export_statement" "declaration" "do_statement" "empty_statement" "with_statement" "throw_statement" "statement_block" "for_statement" "if_statement" "expression_statement" "import_statement"))) 
 ("statement_block" (:*unnamed* ("statement"))) 
 ("statement_identifier" (:*unnamed* nil)) 
 ("string" (:*unnamed* ("escape_sequence" "string_fragment" "html_character_reference"))) 
 ("string_fragment" (:*unnamed* nil)) 
 ("subscript_expression" (:*unnamed* nil :index ("expression" "sequence_expression") :object ("expression") :optional_chain ("optional_chain"))) 
 ("super" (:*unnamed* nil)) 
 ("switch_body" (:*unnamed* ("switch_case" "switch_default"))) 
 ("switch_case" (:*unnamed* nil :body ("statement") :value ("expression" "sequence_expression"))) 
 ("switch_default" (:*unnamed* nil :body ("statement"))) 
 ("switch_statement" (:*unnamed* nil :body ("switch_body") :value ("parenthesized_expression"))) 
 ("template_string" (:*unnamed* ("escape_sequence" "string_fragment" "template_substitution"))) 
 ("template_substitution" (:*unnamed* ("expression" "sequence_expression"))) 
 ("ternary_expression" (:*unnamed* nil :alternative ("expression") :condition ("expression") :consequence ("expression"))) 
 ("this" (:*unnamed* nil)) 
 ("throw_statement" (:*unnamed* ("expression" "sequence_expression"))) 
 ("true" (:*unnamed* nil)) 
 ("try_statement" (:*unnamed* nil :body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause"))) 
 ("unary_expression" (:*unnamed* nil :argument ("expression") :operator nil)) 
 ("undefined" (:*unnamed* nil)) 
 ("update_expression" (:*unnamed* nil :argument ("expression") :operator nil)) 
 ("variable_declaration" (:*unnamed* ("variable_declarator"))) 
 ("variable_declarator" (:*unnamed* nil :name ("identifier" "array_pattern" "object_pattern") :value ("expression"))) 
 ("while_statement" (:*unnamed* nil :body ("statement") :condition ("parenthesized_expression"))) 
 ("with_statement" (:*unnamed* nil :body ("statement") :object ("parenthesized_expression"))) 
 ("yield_expression" (:*unnamed* ("expression"))) 
))
;; END Production rules for jsx
;; START Inverse production rules for jsx
(defconst combobulate-rules-jsx-inverse 
 '(("arguments" ("call_expression" "new_expression"))
   ("array" ("primary_expression"))
   ("array_pattern" ("rest_pattern" "assignment_expression" "for_in_statement" "variable_declarator" "object_assignment_pattern" "pattern" "catch_clause"))
   ("arrow_function" ("primary_expression"))
   ("assignment_expression" ("expression"))
   ("assignment_pattern" ("pair_pattern" "array_pattern" "formal_parameters"))
   ("augmented_assignment_expression" ("expression"))
   ("await_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("break_statement" ("statement"))
   ("call_expression" ("decorator" "primary_expression"))
   ("catch_clause" ("try_statement"))
   ("class" ("primary_expression"))
   ("class_body" ("class" "class_declaration"))
   ("class_declaration" ("declaration"))
   ("class_heritage" ("class" "class_declaration"))
   ("class_static_block" ("class_body"))
   ("computed_property_name" ("field_definition" "pair" "method_definition" "pair_pattern"))
   ("continue_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "export_statement"))
   ("decorator" ("method_definition" "class_declaration" "export_statement" "field_definition" "class"))
   ("do_statement" ("statement"))
   ("else_clause" ("if_statement"))
   ("empty_statement" ("statement" "for_statement"))
   ("escape_sequence" ("template_string" "string"))
   ("export_clause" ("export_statement"))
   ("export_specifier" ("export_clause"))
   ("export_statement" ("statement"))
   ("expression" ("for_in_statement" "field_definition" "member_expression" "arrow_function" "class_heritage" "template_substitution" "assignment_expression" "yield_expression" "export_statement" "pair" "throw_statement" "for_statement" "call_expression" "arguments" "parenthesized_expression" "return_statement" "augmented_assignment_expression" "await_expression" "ternary_expression" "array" "jsx_expression" "binary_expression" "variable_declarator" "object_assignment_pattern" "sequence_expression" "update_expression" "computed_property_name" "assignment_pattern" "unary_expression" "spread_element" "switch_case" "subscript_expression" "expression_statement"))
   ("expression_statement" ("statement" "for_statement"))
   ("false" ("primary_expression"))
   ("field_definition" ("class_body"))
   ("finally_clause" ("try_statement"))
   ("for_in_statement" ("statement"))
   ("for_statement" ("statement"))
   ("formal_parameters" ("method_definition" "function_expression" "generator_function" "function_declaration" "arrow_function" "generator_function_declaration"))
   ("function_declaration" ("declaration"))
   ("function_expression" ("primary_expression"))
   ("generator_function" ("primary_expression"))
   ("generator_function_declaration" ("declaration"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("glimmer_template" ("expression" "class_body"))
   ("hash_bang_line" ("program"))
   ("html_character_reference" ("jsx_element" "string"))
   ("identifier" ("class_declaration" "jsx_opening_element" "function_expression" "for_in_statement" "primary_expression" "arrow_function" "import_specifier" "jsx_closing_element" "assignment_expression" "export_specifier" "generator_function" "catch_clause" "class" "augmented_assignment_expression" "rest_pattern" "variable_declarator" "jsx_self_closing_element" "namespace_import" "import_clause" "namespace_export" "jsx_namespace_name" "decorator" "pattern" "function_declaration" "generator_function_declaration"))
   ("if_statement" ("statement"))
   ("import" ("member_expression" "call_expression"))
   ("import_attribute" ("import_statement"))
   ("import_clause" ("import_statement"))
   ("import_specifier" ("named_imports"))
   ("import_statement" ("statement"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_element" ("jsx_attribute" "expression" "jsx_element"))
   ("jsx_expression" ("jsx_attribute" "jsx_opening_element" "jsx_self_closing_element" "jsx_element"))
   ("jsx_namespace_name" ("jsx_attribute" "jsx_closing_element" "jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_self_closing_element" ("jsx_attribute" "expression" "jsx_element"))
   ("jsx_text" ("jsx_element"))
   ("labeled_statement" ("statement"))
   ("lexical_declaration" ("for_statement" "declaration"))
   ("member_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "jsx_opening_element" "decorator" "for_in_statement" "pattern" "primary_expression" "jsx_self_closing_element" "jsx_closing_element"))
   ("meta_property" ("primary_expression"))
   ("method_definition" ("object" "class_body"))
   ("named_imports" ("import_clause"))
   ("namespace_export" ("export_statement"))
   ("namespace_import" ("import_clause"))
   ("new_expression" ("expression" "new_expression"))
   ("null" ("primary_expression"))
   ("number" ("method_definition" "pair" "pair_pattern" "field_definition" "primary_expression"))
   ("object" ("import_attribute" "primary_expression"))
   ("object_assignment_pattern" ("object_pattern"))
   ("object_pattern" ("rest_pattern" "assignment_expression" "for_in_statement" "variable_declarator" "object_assignment_pattern" "pattern" "catch_clause"))
   ("optional_chain" ("member_expression" "subscript_expression" "call_expression"))
   ("pair" ("object"))
   ("pair_pattern" ("object_pattern"))
   ("parenthesized_expression" ("augmented_assignment_expression" "while_statement" "assignment_expression" "do_statement" "for_in_statement" "switch_statement" "with_statement" "primary_expression" "if_statement"))
   ("pattern" ("pair_pattern" "assignment_pattern" "array_pattern" "formal_parameters"))
   ("primary_expression" ("expression" "new_expression"))
   ("private_property_identifier" ("method_definition" "pair" "pair_pattern" "binary_expression" "field_definition" "member_expression"))
   ("property_identifier" ("jsx_attribute" "method_definition" "pair" "pair_pattern" "field_definition" "member_expression"))
   ("regex" ("primary_expression"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("rest_pattern" ("pattern" "object_pattern"))
   ("return_statement" ("statement"))
   ("sequence_expression" ("jsx_expression" "return_statement" "for_in_statement" "throw_statement" "switch_case" "for_statement" "subscript_expression" "expression_statement" "template_substitution" "parenthesized_expression"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_assignment_pattern" "object_pattern"))
   ("spread_element" ("object" "jsx_expression" "array" "arguments"))
   ("statement" ("while_statement" "labeled_statement" "program" "do_statement" "for_in_statement" "with_statement" "statement_block" "switch_case" "for_statement" "else_clause" "if_statement" "switch_default"))
   ("statement_block" ("method_definition" "finally_clause" "class_static_block" "function_expression" "try_statement" "statement" "generator_function" "function_declaration" "catch_clause" "arrow_function" "generator_function_declaration"))
   ("statement_identifier" ("break_statement" "continue_statement" "labeled_statement"))
   ("string" ("jsx_attribute" "namespace_export" "method_definition" "export_statement" "pair" "pair_pattern" "field_definition" "export_specifier" "primary_expression" "import_statement" "import_specifier"))
   ("string_fragment" ("template_string" "string"))
   ("subscript_expression" ("augmented_assignment_expression" "rest_pattern" "assignment_expression" "for_in_statement" "pattern" "primary_expression"))
   ("super" ("primary_expression"))
   ("switch_body" ("switch_statement"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_statement" ("statement"))
   ("template_string" ("call_expression" "primary_expression"))
   ("template_substitution" ("template_string"))
   ("ternary_expression" ("expression"))
   ("this" ("primary_expression"))
   ("throw_statement" ("statement"))
   ("true" ("primary_expression"))
   ("try_statement" ("statement"))
   ("unary_expression" ("expression"))
   ("undefined" ("rest_pattern" "assignment_expression" "for_in_statement" "pattern" "primary_expression"))
   ("update_expression" ("expression"))
   ("variable_declaration" ("for_statement" "declaration"))
   ("variable_declarator" ("variable_declaration" "lexical_declaration"))
   ("while_statement" ("statement"))
   ("with_statement" ("statement"))
   ("yield_expression" ("expression"))
  ) 
)
;; END Inverse production rules for jsx
;; START All node types in jsx
(defconst combobulate-rules-jsx-types 
 '("arguments" "array" "array_pattern" "arrow_function" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "continue_statement" "debugger_statement" "declaration" "decorator" "do_statement" "else_clause" "empty_statement" "escape_sequence" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "false" "field_definition" "finally_clause" "for_in_statement" "for_statement" "formal_parameters" "function_declaration" "function_expression" "generator_function" "generator_function_declaration" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "html_character_reference" "html_comment" "identifier" "if_statement" "import" "import_attribute" "import_clause" "import_specifier" "import_statement" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "member_expression" "meta_property" "method_definition" "named_imports" "namespace_export" "namespace_import" "new_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "optional_chain" "pair" "pair_pattern" "parenthesized_expression" "pattern" "primary_expression" "private_property_identifier" "program" "property_identifier" "regex" "regex_flags" "regex_pattern" "rest_pattern" "return_statement" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_string" "template_substitution" "ternary_expression" "this" "throw_statement" "true" "try_statement" "unary_expression" "undefined" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression") 
)
;; END All node types in jsx
;; START All supertypes in jsx
(defconst combobulate-rules-jsx-supertypes 
 '("declaration" "expression" "pattern" "primary_expression" "statement") 
)
;; END All supertypes in jsx

;; START Production rules for go
(defconst combobulate-rules-go 
 '(("_expression" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("_simple_statement" (:*unnamed* ("dec_statement" "short_var_declaration" "assignment_statement" "inc_statement" "send_statement" "expression_statement"))) 
 ("_simple_type" (:*unnamed* ("qualified_type" "function_type" "interface_type" "struct_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("_statement" (:*unnamed* ("type_switch_statement" "labeled_statement" "assignment_statement" "var_declaration" "if_statement" "dec_statement" "block" "inc_statement" "select_statement" "break_statement" "defer_statement" "expression_switch_statement" "short_var_declaration" "continue_statement" "go_statement" "type_declaration" "empty_statement" "const_declaration" "goto_statement" "for_statement" "send_statement" "expression_statement" "fallthrough_statement" "return_statement"))) 
 ("_type" (:*unnamed* ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("argument_list" (:*unnamed* ("index_expression" "rune_literal" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "map_type" "imaginary_literal" "type_instantiation_expression" "func_literal" "array_type" "composite_literal" "type_identifier" "variadic_argument" "call_expression" "qualified_type" "parenthesized_expression" "parenthesized_type" "interface_type" "binary_expression" "iota" "generic_type" "slice_type" "channel_type" "unary_expression" "function_type" "struct_type" "selector_expression" "identifier" "negated_type" "type_assertion_expression" "interpreted_string_literal" "pointer_type" "slice_expression" "true" "float_literal"))) 
 ("array_type" (:*unnamed* nil :element ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type") :length ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("assignment_statement" (:*unnamed* nil :left ("expression_list") :operator nil :right ("expression_list"))) 
 ("binary_expression" (:*unnamed* nil :left ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :operator nil :right ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("blank_identifier" (:*unnamed* nil)) 
 ("block" (:*unnamed* ("type_switch_statement" "labeled_statement" "assignment_statement" "var_declaration" "if_statement" "dec_statement" "block" "inc_statement" "select_statement" "break_statement" "defer_statement" "expression_switch_statement" "short_var_declaration" "continue_statement" "go_statement" "type_declaration" "empty_statement" "const_declaration" "goto_statement" "for_statement" "send_statement" "expression_statement" "fallthrough_statement" "return_statement"))) 
 ("break_statement" (:*unnamed* ("label_name"))) 
 ("call_expression" (:*unnamed* nil :arguments ("argument_list") :function ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :type_arguments ("type_arguments"))) 
 ("channel_type" (:*unnamed* nil :value ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("comment" (:*unnamed* nil)) 
 ("communication_case" (:*unnamed* ("type_switch_statement" "labeled_statement" "assignment_statement" "var_declaration" "if_statement" "dec_statement" "block" "inc_statement" "select_statement" "break_statement" "defer_statement" "expression_switch_statement" "short_var_declaration" "continue_statement" "go_statement" "type_declaration" "empty_statement" "const_declaration" "goto_statement" "for_statement" "send_statement" "expression_statement" "fallthrough_statement" "return_statement") :communication ("receive_statement" "send_statement"))) 
 ("composite_literal" (:*unnamed* nil :body ("literal_value") :type ("qualified_type" "struct_type" "array_type" "implicit_length_array_type" "generic_type" "type_identifier" "slice_type" "map_type"))) 
 ("const_declaration" (:*unnamed* ("const_spec"))) 
 ("const_spec" (:*unnamed* nil :name ("identifier") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type") :value ("expression_list"))) 
 ("continue_statement" (:*unnamed* ("label_name"))) 
 ("dec_statement" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("default_case" (:*unnamed* ("type_switch_statement" "labeled_statement" "assignment_statement" "var_declaration" "if_statement" "dec_statement" "block" "inc_statement" "select_statement" "break_statement" "defer_statement" "expression_switch_statement" "short_var_declaration" "continue_statement" "go_statement" "type_declaration" "empty_statement" "const_declaration" "goto_statement" "for_statement" "send_statement" "expression_statement" "fallthrough_statement" "return_statement"))) 
 ("defer_statement" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("dot" (:*unnamed* nil)) 
 ("empty_statement" (:*unnamed* nil)) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("expression_case" (:*unnamed* ("type_switch_statement" "labeled_statement" "assignment_statement" "var_declaration" "if_statement" "dec_statement" "block" "inc_statement" "select_statement" "break_statement" "defer_statement" "expression_switch_statement" "short_var_declaration" "continue_statement" "go_statement" "type_declaration" "empty_statement" "const_declaration" "goto_statement" "for_statement" "send_statement" "expression_statement" "fallthrough_statement" "return_statement") :value ("expression_list"))) 
 ("expression_list" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("expression_statement" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("expression_switch_statement" (:*unnamed* ("default_case" "expression_case") :initializer ("dec_statement" "short_var_declaration" "assignment_statement" "inc_statement" "send_statement" "expression_statement") :value ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("fallthrough_statement" (:*unnamed* nil)) 
 ("false" (:*unnamed* nil)) 
 ("field_declaration" (:*unnamed* nil :name ("field_identifier") :tag ("interpreted_string_literal" "raw_string_literal") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("field_declaration_list" (:*unnamed* ("field_declaration"))) 
 ("field_identifier" (:*unnamed* nil)) 
 ("float_literal" (:*unnamed* nil)) 
 ("for_clause" (:*unnamed* nil :condition ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :initializer ("dec_statement" "short_var_declaration" "assignment_statement" "inc_statement" "send_statement" "expression_statement") :update ("dec_statement" "short_var_declaration" "assignment_statement" "inc_statement" "send_statement" "expression_statement"))) 
 ("for_statement" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "for_clause" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "range_clause" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :body ("block"))) 
 ("func_literal" (:*unnamed* nil :body ("block") :parameters ("parameter_list") :result ("qualified_type" "function_type" "interface_type" "struct_type" "parameter_list" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("function_declaration" (:*unnamed* nil :body ("block") :name ("identifier") :parameters ("parameter_list") :result ("qualified_type" "function_type" "interface_type" "struct_type" "parameter_list" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type") :type_parameters ("type_parameter_list"))) 
 ("function_type" (:*unnamed* nil :parameters ("parameter_list") :result ("qualified_type" "function_type" "interface_type" "struct_type" "parameter_list" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("generic_type" (:*unnamed* nil :type ("type_identifier" "negated_type" "qualified_type") :type_arguments ("type_arguments"))) 
 ("go_statement" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("goto_statement" (:*unnamed* ("label_name"))) 
 ("identifier" (:*unnamed* nil)) 
 ("if_statement" (:*unnamed* nil :alternative ("if_statement" "block") :condition ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :consequence ("block") :initializer ("dec_statement" "short_var_declaration" "assignment_statement" "inc_statement" "send_statement" "expression_statement"))) 
 ("imaginary_literal" (:*unnamed* nil)) 
 ("implicit_length_array_type" (:*unnamed* nil :element ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("import_declaration" (:*unnamed* ("import_spec_list" "import_spec"))) 
 ("import_spec" (:*unnamed* nil :name ("dot" "package_identifier" "blank_identifier") :path ("interpreted_string_literal" "raw_string_literal"))) 
 ("import_spec_list" (:*unnamed* ("import_spec"))) 
 ("inc_statement" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("index_expression" (:*unnamed* nil :index ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :operand ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("int_literal" (:*unnamed* nil)) 
 ("interface_type" (:*unnamed* ("method_elem" "type_elem"))) 
 ("interpreted_string_literal" (:*unnamed* ("escape_sequence"))) 
 ("iota" (:*unnamed* nil)) 
 ("keyed_element" (:*unnamed* ("literal_element"))) 
 ("label_name" (:*unnamed* nil)) 
 ("labeled_statement" (:*unnamed* ("type_switch_statement" "labeled_statement" "assignment_statement" "var_declaration" "if_statement" "dec_statement" "block" "inc_statement" "select_statement" "break_statement" "defer_statement" "expression_switch_statement" "short_var_declaration" "continue_statement" "go_statement" "type_declaration" "empty_statement" "const_declaration" "goto_statement" "for_statement" "send_statement" "expression_statement" "fallthrough_statement" "return_statement") :label ("label_name"))) 
 ("literal_element" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "literal_value" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("literal_value" (:*unnamed* ("keyed_element" "literal_element"))) 
 ("map_type" (:*unnamed* nil :key ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type") :value ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("method_declaration" (:*unnamed* nil :body ("block") :name ("field_identifier") :parameters ("parameter_list") :receiver ("parameter_list") :result ("qualified_type" "function_type" "interface_type" "struct_type" "parameter_list" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("method_elem" (:*unnamed* nil :name ("field_identifier") :parameters ("parameter_list") :result ("qualified_type" "function_type" "interface_type" "struct_type" "parameter_list" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("negated_type" (:*unnamed* ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("nil" (:*unnamed* nil)) 
 ("package_clause" (:*unnamed* ("package_identifier"))) 
 ("package_identifier" (:*unnamed* nil)) 
 ("parameter_declaration" (:*unnamed* nil :name ("identifier") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("parameter_list" (:*unnamed* ("variadic_parameter_declaration" "parameter_declaration"))) 
 ("parenthesized_expression" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("parenthesized_type" (:*unnamed* ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("pointer_type" (:*unnamed* ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("qualified_type" (:*unnamed* nil :name ("type_identifier") :package ("package_identifier"))) 
 ("range_clause" (:*unnamed* nil :left ("expression_list") :right ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("raw_string_literal" (:*unnamed* nil)) 
 ("receive_statement" (:*unnamed* nil :left ("expression_list") :right ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("return_statement" (:*unnamed* ("expression_list"))) 
 ("rune_literal" (:*unnamed* nil)) 
 ("select_statement" (:*unnamed* ("default_case" "communication_case"))) 
 ("selector_expression" (:*unnamed* nil :field ("field_identifier") :operand ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("send_statement" (:*unnamed* nil :channel ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :value ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("short_var_declaration" (:*unnamed* nil :left ("expression_list") :right ("expression_list"))) 
 ("slice_expression" (:*unnamed* nil :capacity ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :end ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :operand ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :start ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("slice_type" (:*unnamed* nil :element ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("source_file" (:*unnamed* ("type_switch_statement" "labeled_statement" "assignment_statement" "var_declaration" "if_statement" "dec_statement" "block" "package_clause" "inc_statement" "import_declaration" "select_statement" "break_statement" "defer_statement" "expression_switch_statement" "short_var_declaration" "continue_statement" "go_statement" "type_declaration" "method_declaration" "empty_statement" "function_declaration" "const_declaration" "goto_statement" "for_statement" "send_statement" "expression_statement" "fallthrough_statement" "return_statement"))) 
 ("struct_type" (:*unnamed* ("field_declaration_list"))) 
 ("true" (:*unnamed* nil)) 
 ("type_alias" (:*unnamed* nil :name ("type_identifier") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("type_arguments" (:*unnamed* ("type_elem"))) 
 ("type_assertion_expression" (:*unnamed* nil :operand ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("type_case" (:*unnamed* ("type_switch_statement" "labeled_statement" "assignment_statement" "var_declaration" "if_statement" "dec_statement" "block" "inc_statement" "select_statement" "break_statement" "defer_statement" "expression_switch_statement" "short_var_declaration" "continue_statement" "go_statement" "type_declaration" "empty_statement" "const_declaration" "goto_statement" "for_statement" "send_statement" "expression_statement" "fallthrough_statement" "return_statement") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("type_constraint" (:*unnamed* ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("type_conversion_expression" (:*unnamed* nil :operand ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("type_declaration" (:*unnamed* ("type_spec" "type_alias"))) 
 ("type_elem" (:*unnamed* ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("type_identifier" (:*unnamed* nil)) 
 ("type_instantiation_expression" (:*unnamed* ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
 ("type_parameter_declaration" (:*unnamed* nil :name ("identifier") :type ("type_constraint"))) 
 ("type_parameter_list" (:*unnamed* ("type_parameter_declaration"))) 
 ("type_spec" (:*unnamed* nil :name ("type_identifier") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type") :type_parameters ("type_parameter_list"))) 
 ("type_switch_statement" (:*unnamed* ("default_case" "type_case") :alias ("expression_list") :initializer ("dec_statement" "short_var_declaration" "assignment_statement" "inc_statement" "send_statement" "expression_statement") :value ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("unary_expression" (:*unnamed* nil :operand ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression") :operator nil)) 
 ("var_declaration" (:*unnamed* ("var_spec"))) 
 ("var_spec" (:*unnamed* nil :name ("identifier") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type") :value ("expression_list"))) 
 ("variadic_argument" (:*unnamed* ("index_expression" "rune_literal" "binary_expression" "iota" "false" "nil" "type_conversion_expression" "int_literal" "raw_string_literal" "imaginary_literal" "unary_expression" "type_instantiation_expression" "selector_expression" "identifier" "func_literal" "composite_literal" "type_assertion_expression" "interpreted_string_literal" "slice_expression" "true" "float_literal" "call_expression" "parenthesized_expression"))) 
 ("variadic_parameter_declaration" (:*unnamed* nil :name ("identifier") :type ("qualified_type" "function_type" "interface_type" "struct_type" "parenthesized_type" "negated_type" "array_type" "generic_type" "pointer_type" "slice_type" "type_identifier" "map_type" "channel_type"))) 
))
;; END Production rules for go
;; START Inverse production rules for go
(defconst combobulate-rules-go-inverse 
 '(("argument_list" ("call_expression"))
   ("array_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "composite_literal" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("assignment_statement" ("type_switch_statement" "labeled_statement" "type_case" "default_case" "for_clause" "block" "expression_case" "_statement" "_simple_statement" "source_file" "if_statement" "communication_case" "expression_switch_statement"))
   ("binary_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("blank_identifier" ("import_spec"))
   ("block" ("labeled_statement" "type_case" "default_case" "method_declaration" "func_literal" "source_file" "block" "expression_case" "_statement" "function_declaration" "for_statement" "if_statement" "communication_case"))
   ("break_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("call_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("channel_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("communication_case" ("select_statement"))
   ("composite_literal" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("const_declaration" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("const_spec" ("const_declaration"))
   ("continue_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("dec_statement" ("type_switch_statement" "labeled_statement" "type_case" "default_case" "for_clause" "block" "expression_case" "_statement" "_simple_statement" "source_file" "if_statement" "communication_case" "expression_switch_statement"))
   ("default_case" ("type_switch_statement" "select_statement" "expression_switch_statement"))
   ("defer_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("dot" ("import_spec"))
   ("empty_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("escape_sequence" ("interpreted_string_literal"))
   ("expression_case" ("expression_switch_statement"))
   ("expression_list" ("type_switch_statement" "short_var_declaration" "assignment_statement" "receive_statement" "var_spec" "range_clause" "expression_case" "const_spec" "return_statement"))
   ("expression_statement" ("type_switch_statement" "labeled_statement" "type_case" "default_case" "for_clause" "block" "expression_case" "_statement" "_simple_statement" "source_file" "if_statement" "communication_case" "expression_switch_statement"))
   ("expression_switch_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("fallthrough_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("false" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("field_declaration" ("field_declaration_list"))
   ("field_declaration_list" ("struct_type"))
   ("field_identifier" ("selector_expression" "method_declaration" "method_elem" "field_declaration"))
   ("float_literal" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("for_clause" ("for_statement"))
   ("for_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("func_literal" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("function_declaration" ("source_file"))
   ("function_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("generic_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "composite_literal" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("go_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("goto_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("identifier" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "expression_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "variadic_parameter_declaration" "var_spec" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parameter_declaration" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "type_parameter_declaration" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "function_declaration" "slice_expression" "if_statement" "const_spec"))
   ("if_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "if_statement" "communication_case"))
   ("imaginary_literal" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("implicit_length_array_type" ("composite_literal"))
   ("import_declaration" ("source_file"))
   ("import_spec" ("import_spec_list" "import_declaration"))
   ("import_spec_list" ("import_declaration"))
   ("inc_statement" ("type_switch_statement" "labeled_statement" "type_case" "default_case" "for_clause" "block" "expression_case" "_statement" "_simple_statement" "source_file" "if_statement" "communication_case" "expression_switch_statement"))
   ("index_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("int_literal" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("interface_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("interpreted_string_literal" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "import_spec" "receive_statement" "binary_expression" "field_declaration" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("iota" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("keyed_element" ("literal_value"))
   ("label_name" ("labeled_statement" "break_statement" "continue_statement" "goto_statement"))
   ("labeled_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("literal_element" ("literal_value" "keyed_element"))
   ("literal_value" ("composite_literal" "literal_element"))
   ("map_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "composite_literal" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("method_declaration" ("source_file"))
   ("method_elem" ("interface_type"))
   ("negated_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "generic_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("nil" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("package_clause" ("source_file"))
   ("package_identifier" ("qualified_type" "package_clause" "import_spec"))
   ("parameter_declaration" ("parameter_list"))
   ("parameter_list" ("function_type" "method_declaration" "func_literal" "function_declaration" "method_elem"))
   ("parenthesized_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("parenthesized_type" ("type_constraint" "type_conversion_expression" "type_alias" "map_type" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "var_spec" "array_type" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "slice_type" "argument_list" "channel_type" "negated_type" "type_spec" "type_assertion_expression" "pointer_type" "const_spec"))
   ("pointer_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("qualified_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "composite_literal" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "generic_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("range_clause" ("for_statement"))
   ("raw_string_literal" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "import_spec" "receive_statement" "binary_expression" "field_declaration" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("receive_statement" ("communication_case"))
   ("return_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("rune_literal" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("select_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("selector_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("send_statement" ("type_switch_statement" "labeled_statement" "type_case" "default_case" "for_clause" "block" "expression_case" "_statement" "_simple_statement" "source_file" "if_statement" "communication_case" "expression_switch_statement"))
   ("short_var_declaration" ("type_switch_statement" "labeled_statement" "type_case" "default_case" "for_clause" "block" "expression_case" "_statement" "_simple_statement" "source_file" "if_statement" "communication_case" "expression_switch_statement"))
   ("slice_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("slice_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "composite_literal" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("struct_type" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "composite_literal" "type_elem" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("true" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("type_alias" ("type_declaration"))
   ("type_arguments" ("generic_type" "call_expression"))
   ("type_assertion_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("type_case" ("type_switch_statement"))
   ("type_constraint" ("type_parameter_declaration"))
   ("type_conversion_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("type_declaration" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("type_elem" ("type_arguments" "interface_type"))
   ("type_identifier" ("type_constraint" "type_conversion_expression" "method_elem" "map_type" "type_alias" "type_case" "type_instantiation_expression" "variadic_parameter_declaration" "method_declaration" "func_literal" "array_type" "var_spec" "composite_literal" "type_elem" "qualified_type" "parameter_declaration" "parenthesized_type" "_type" "field_declaration" "implicit_length_array_type" "_simple_type" "generic_type" "slice_type" "argument_list" "channel_type" "function_type" "negated_type" "type_spec" "type_assertion_expression" "function_declaration" "pointer_type" "const_spec"))
   ("type_instantiation_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("type_parameter_declaration" ("type_parameter_list"))
   ("type_parameter_list" ("type_spec" "function_declaration"))
   ("type_spec" ("type_declaration"))
   ("type_switch_statement" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("unary_expression" ("type_switch_statement" "send_statement" "index_expression" "literal_element" "dec_statement" "inc_statement" "_expression" "type_conversion_expression" "defer_statement" "go_statement" "array_type" "range_clause" "variadic_argument" "for_statement" "call_expression" "parenthesized_expression" "receive_statement" "binary_expression" "for_clause" "argument_list" "expression_switch_statement" "unary_expression" "expression_list" "selector_expression" "type_assertion_expression" "slice_expression" "if_statement" "expression_statement"))
   ("var_declaration" ("labeled_statement" "type_case" "default_case" "block" "expression_case" "_statement" "source_file" "communication_case"))
   ("var_spec" ("var_declaration"))
   ("variadic_argument" ("argument_list"))
   ("variadic_parameter_declaration" ("parameter_list"))
  ) 
)
;; END Inverse production rules for go
;; START All node types in go
(defconst combobulate-rules-go-types 
 '("_expression" "_simple_statement" "_simple_type" "_statement" "_type" "argument_list" "array_type" "assignment_statement" "binary_expression" "blank_identifier" "block" "break_statement" "call_expression" "channel_type" "comment" "communication_case" "composite_literal" "const_declaration" "const_spec" "continue_statement" "dec_statement" "default_case" "defer_statement" "dot" "empty_statement" "escape_sequence" "expression_case" "expression_list" "expression_statement" "expression_switch_statement" "fallthrough_statement" "false" "field_declaration" "field_declaration_list" "field_identifier" "float_literal" "for_clause" "for_statement" "func_literal" "function_declaration" "function_type" "generic_type" "go_statement" "goto_statement" "identifier" "if_statement" "imaginary_literal" "implicit_length_array_type" "import_declaration" "import_spec" "import_spec_list" "inc_statement" "index_expression" "int_literal" "interface_type" "interpreted_string_literal" "iota" "keyed_element" "label_name" "labeled_statement" "literal_element" "literal_value" "map_type" "method_declaration" "method_elem" "negated_type" "nil" "package_clause" "package_identifier" "parameter_declaration" "parameter_list" "parenthesized_expression" "parenthesized_type" "pointer_type" "qualified_type" "range_clause" "raw_string_literal" "receive_statement" "return_statement" "rune_literal" "select_statement" "selector_expression" "send_statement" "short_var_declaration" "slice_expression" "slice_type" "source_file" "struct_type" "true" "type_alias" "type_arguments" "type_assertion_expression" "type_case" "type_constraint" "type_conversion_expression" "type_declaration" "type_elem" "type_identifier" "type_instantiation_expression" "type_parameter_declaration" "type_parameter_list" "type_spec" "type_switch_statement" "unary_expression" "var_declaration" "var_spec" "variadic_argument" "variadic_parameter_declaration") 
)
;; END All node types in go
;; START All supertypes in go
(defconst combobulate-rules-go-supertypes 
 '("_expression" "_simple_statement" "_simple_type" "_statement" "_type") 
)
;; END All supertypes in go

;; START Production rules for python
(defconst combobulate-rules-python 
 '(("_compound_statement" (:*unnamed* ("function_definition" "while_statement" "decorated_definition" "class_definition" "try_statement" "with_statement" "match_statement" "for_statement" "if_statement"))) 
 ("_simple_statement" (:*unnamed* ("raise_statement" "import_from_statement" "assert_statement" "delete_statement" "expression_statement" "nonlocal_statement" "exec_statement" "break_statement" "continue_statement" "global_statement" "pass_statement" "future_import_statement" "import_statement" "type_alias_statement" "print_statement" "return_statement"))) 
 ("aliased_import" (:*unnamed* nil :alias ("identifier") :name ("dotted_name"))) 
 ("argument_list" (:*unnamed* ("expression" "keyword_argument" "list_splat" "dictionary_splat" "parenthesized_expression"))) 
 ("as_pattern" (:*unnamed* ("expression" "case_pattern" "identifier") :alias ("as_pattern_target"))) 
 ("assert_statement" (:*unnamed* ("expression"))) 
 ("assignment" (:*unnamed* nil :left ("pattern_list" "pattern") :right ("augmented_assignment" "expression" "assignment" "yield" "expression_list" "pattern_list") :type ("type"))) 
 ("attribute" (:*unnamed* nil :attribute ("identifier") :object ("primary_expression"))) 
 ("augmented_assignment" (:*unnamed* nil :left ("pattern_list" "pattern") :operator nil :right ("augmented_assignment" "expression" "assignment" "yield" "expression_list" "pattern_list"))) 
 ("await" (:*unnamed* ("primary_expression"))) 
 ("binary_operator" (:*unnamed* nil :left ("primary_expression") :operator nil :right ("primary_expression"))) 
 ("block" (:*unnamed* ("while_statement" "decorated_definition" "raise_statement" "import_from_statement" "class_definition" "type_alias_statement" "print_statement" "return_statement" "try_statement" "expression_statement" "nonlocal_statement" "exec_statement" "break_statement" "function_definition" "continue_statement" "global_statement" "pass_statement" "future_import_statement" "with_statement" "match_statement" "for_statement" "if_statement" "assert_statement" "delete_statement" "import_statement") :alternative ("case_clause"))) 
 ("boolean_operator" (:*unnamed* nil :left ("expression") :operator nil :right ("expression"))) 
 ("break_statement" (:*unnamed* nil)) 
 ("call" (:*unnamed* nil :arguments ("argument_list" "generator_expression") :function ("primary_expression"))) 
 ("case_clause" (:*unnamed* ("case_pattern") :consequence ("block") :guard ("if_clause"))) 
 ("case_pattern" (:*unnamed* ("tuple_pattern" "none" "splat_pattern" "list_pattern" "false" "dict_pattern" "string" "dotted_name" "complex_pattern" "class_pattern" "float" "concatenated_string" "union_pattern" "as_pattern" "integer" "true" "keyword_pattern"))) 
 ("chevron" (:*unnamed* ("expression"))) 
 ("class_definition" (:*unnamed* nil :body ("block") :name ("identifier") :superclasses ("argument_list") :type_parameters ("type_parameter"))) 
 ("class_pattern" (:*unnamed* ("dotted_name" "case_pattern"))) 
 ("comment" (:*unnamed* nil)) 
 ("comparison_operator" (:*unnamed* ("primary_expression") :operators nil)) 
 ("complex_pattern" (:*unnamed* ("integer" "float"))) 
 ("concatenated_string" (:*unnamed* ("string"))) 
 ("conditional_expression" (:*unnamed* ("expression"))) 
 ("constrained_type" (:*unnamed* ("type"))) 
 ("continue_statement" (:*unnamed* nil)) 
 ("decorated_definition" (:*unnamed* ("decorator") :definition ("function_definition" "class_definition"))) 
 ("decorator" (:*unnamed* ("expression"))) 
 ("default_parameter" (:*unnamed* nil :name ("tuple_pattern" "identifier") :value ("expression"))) 
 ("delete_statement" (:*unnamed* ("expression" "expression_list"))) 
 ("dict_pattern" (:*unnamed* ("splat_pattern") :key ("tuple_pattern" "concatenated_string" "none" "splat_pattern" "list_pattern" "complex_pattern" "union_pattern" "integer" "false" "dict_pattern" "string" "dotted_name" "true" "class_pattern" "float") :value ("case_pattern"))) 
 ("dictionary" (:*unnamed* ("dictionary_splat" "pair"))) 
 ("dictionary_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("pair"))) 
 ("dictionary_splat" (:*unnamed* ("expression"))) 
 ("dictionary_splat_pattern" (:*unnamed* ("identifier" "attribute" "subscript"))) 
 ("dotted_name" (:*unnamed* ("identifier"))) 
 ("elif_clause" (:*unnamed* nil :condition ("expression") :consequence ("block"))) 
 ("ellipsis" (:*unnamed* nil)) 
 ("else_clause" (:*unnamed* nil :body ("block"))) 
 ("escape_interpolation" (:*unnamed* nil)) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("except_clause" (:*unnamed* ("expression" "block"))) 
 ("except_group_clause" (:*unnamed* ("expression" "block"))) 
 ("exec_statement" (:*unnamed* ("expression") :code ("identifier" "string"))) 
 ("expression" (:*unnamed* ("not_operator" "lambda" "conditional_expression" "named_expression" "as_pattern" "boolean_operator" "primary_expression" "comparison_operator"))) 
 ("expression_list" (:*unnamed* ("expression"))) 
 ("expression_statement" (:*unnamed* ("augmented_assignment" "expression" "assignment" "yield"))) 
 ("false" (:*unnamed* nil)) 
 ("finally_clause" (:*unnamed* ("block"))) 
 ("float" (:*unnamed* nil)) 
 ("for_in_clause" (:*unnamed* nil :left ("pattern_list" "pattern") :right ("expression"))) 
 ("for_statement" (:*unnamed* nil :alternative ("else_clause") :body ("block") :left ("pattern_list" "pattern") :right ("expression" "expression_list"))) 
 ("format_expression" (:*unnamed* nil :expression ("expression" "yield" "pattern_list" "expression_list") :format_specifier ("format_specifier") :type_conversion ("type_conversion"))) 
 ("format_specifier" (:*unnamed* ("format_expression"))) 
 ("function_definition" (:*unnamed* nil :body ("block") :name ("identifier") :parameters ("parameters") :return_type ("type") :type_parameters ("type_parameter"))) 
 ("future_import_statement" (:*unnamed* nil :name ("aliased_import" "dotted_name"))) 
 ("generator_expression" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression"))) 
 ("generic_type" (:*unnamed* ("identifier" "type_parameter"))) 
 ("global_statement" (:*unnamed* ("identifier"))) 
 ("identifier" (:*unnamed* nil)) 
 ("if_clause" (:*unnamed* ("expression"))) 
 ("if_statement" (:*unnamed* nil :alternative ("else_clause" "elif_clause") :condition ("expression") :consequence ("block"))) 
 ("import_from_statement" (:*unnamed* ("wildcard_import") :module_name ("dotted_name" "relative_import") :name ("aliased_import" "dotted_name"))) 
 ("import_prefix" (:*unnamed* nil)) 
 ("import_statement" (:*unnamed* nil :name ("aliased_import" "dotted_name"))) 
 ("integer" (:*unnamed* nil)) 
 ("interpolation" (:*unnamed* nil :expression ("expression" "yield" "pattern_list" "expression_list") :format_specifier ("format_specifier") :type_conversion ("type_conversion"))) 
 ("keyword_argument" (:*unnamed* nil :name ("identifier") :value ("expression"))) 
 ("keyword_pattern" (:*unnamed* ("tuple_pattern" "none" "splat_pattern" "list_pattern" "false" "dict_pattern" "string" "dotted_name" "complex_pattern" "class_pattern" "float" "concatenated_string" "identifier" "union_pattern" "integer" "true"))) 
 ("keyword_separator" (:*unnamed* nil)) 
 ("lambda" (:*unnamed* nil :body ("expression") :parameters ("lambda_parameters"))) 
 ("lambda_parameters" (:*unnamed* ("parameter"))) 
 ("line_continuation" (:*unnamed* nil)) 
 ("list" (:*unnamed* ("expression" "yield" "parenthesized_list_splat" "list_splat"))) 
 ("list_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression"))) 
 ("list_pattern" (:*unnamed* ("case_pattern" "pattern"))) 
 ("list_splat" (:*unnamed* ("expression" "identifier" "attribute" "subscript"))) 
 ("list_splat_pattern" (:*unnamed* ("identifier" "attribute" "subscript"))) 
 ("match_statement" (:*unnamed* nil :body ("block") :subject ("expression"))) 
 ("member_type" (:*unnamed* ("type" "identifier"))) 
 ("module" (:*unnamed* ("while_statement" "decorated_definition" "raise_statement" "import_from_statement" "class_definition" "type_alias_statement" "print_statement" "return_statement" "try_statement" "expression_statement" "nonlocal_statement" "exec_statement" "break_statement" "function_definition" "continue_statement" "global_statement" "pass_statement" "future_import_statement" "with_statement" "match_statement" "for_statement" "if_statement" "assert_statement" "delete_statement" "import_statement"))) 
 ("named_expression" (:*unnamed* nil :name ("identifier") :value ("expression"))) 
 ("none" (:*unnamed* nil)) 
 ("nonlocal_statement" (:*unnamed* ("identifier"))) 
 ("not_operator" (:*unnamed* nil :argument ("expression"))) 
 ("pair" (:*unnamed* nil :key ("expression") :value ("expression"))) 
 ("parameter" (:*unnamed* ("keyword_separator" "tuple_pattern" "dictionary_splat_pattern" "list_splat_pattern" "identifier" "default_parameter" "typed_parameter" "positional_separator" "typed_default_parameter"))) 
 ("parameters" (:*unnamed* ("parameter"))) 
 ("parenthesized_expression" (:*unnamed* ("expression" "parenthesized_expression" "yield" "list_splat"))) 
 ("parenthesized_list_splat" (:*unnamed* ("parenthesized_expression" "list_splat"))) 
 ("pass_statement" (:*unnamed* nil)) 
 ("pattern" (:*unnamed* ("tuple_pattern" "subscript" "list_splat_pattern" "identifier" "attribute" "list_pattern"))) 
 ("pattern_list" (:*unnamed* ("pattern"))) 
 ("positional_separator" (:*unnamed* nil)) 
 ("primary_expression" (:*unnamed* ("none" "set" "generator_expression" "list_splat" "await" "ellipsis" "false" "list_comprehension" "string" "attribute" "float" "list" "concatenated_string" "subscript" "tuple" "set_comprehension" "identifier" "dictionary" "binary_operator" "integer" "unary_operator" "call" "dictionary_comprehension" "true" "parenthesized_expression"))) 
 ("print_statement" (:*unnamed* ("chevron") :argument ("expression"))) 
 ("raise_statement" (:*unnamed* ("expression" "expression_list") :cause ("expression"))) 
 ("relative_import" (:*unnamed* ("dotted_name" "import_prefix"))) 
 ("return_statement" (:*unnamed* ("expression" "expression_list"))) 
 ("set" (:*unnamed* ("expression" "yield" "parenthesized_list_splat" "list_splat"))) 
 ("set_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression"))) 
 ("slice" (:*unnamed* ("expression"))) 
 ("splat_pattern" (:*unnamed* ("identifier"))) 
 ("splat_type" (:*unnamed* ("identifier"))) 
 ("string" (:*unnamed* ("string_content" "interpolation" "string_end" "string_start"))) 
 ("string_content" (:*unnamed* ("escape_interpolation" "escape_sequence"))) 
 ("string_end" (:*unnamed* nil)) 
 ("string_start" (:*unnamed* nil)) 
 ("subscript" (:*unnamed* nil :subscript ("expression" "slice") :value ("primary_expression"))) 
 ("true" (:*unnamed* nil)) 
 ("try_statement" (:*unnamed* ("except_clause" "else_clause" "except_group_clause" "finally_clause") :body ("block"))) 
 ("tuple" (:*unnamed* ("expression" "yield" "parenthesized_list_splat" "list_splat"))) 
 ("tuple_pattern" (:*unnamed* ("case_pattern" "pattern"))) 
 ("type" (:*unnamed* ("constrained_type" "expression" "union_type" "generic_type" "member_type" "splat_type"))) 
 ("type_alias_statement" (:*unnamed* ("type"))) 
 ("type_conversion" (:*unnamed* nil)) 
 ("type_parameter" (:*unnamed* ("type"))) 
 ("typed_default_parameter" (:*unnamed* nil :name ("identifier") :type ("type") :value ("expression"))) 
 ("typed_parameter" (:*unnamed* ("list_splat_pattern" "identifier" "dictionary_splat_pattern") :type ("type"))) 
 ("unary_operator" (:*unnamed* nil :argument ("primary_expression") :operator nil)) 
 ("union_pattern" (:*unnamed* ("tuple_pattern" "concatenated_string" "none" "splat_pattern" "list_pattern" "complex_pattern" "union_pattern" "integer" "false" "dict_pattern" "string" "dotted_name" "true" "class_pattern" "float"))) 
 ("union_type" (:*unnamed* ("type"))) 
 ("while_statement" (:*unnamed* nil :alternative ("else_clause") :body ("block") :condition ("expression"))) 
 ("wildcard_import" (:*unnamed* nil)) 
 ("with_clause" (:*unnamed* ("with_item"))) 
 ("with_item" (:*unnamed* nil :value ("expression"))) 
 ("with_statement" (:*unnamed* ("with_clause") :body ("block"))) 
 ("yield" (:*unnamed* ("expression" "expression_list"))) 
))
;; END Production rules for python
;; START Inverse production rules for python
(defconst combobulate-rules-python-inverse 
 '(("aliased_import" ("import_statement" "import_from_statement" "future_import_statement"))
   ("argument_list" ("class_definition" "call"))
   ("as_pattern" ("expression" "case_pattern"))
   ("as_pattern_target" ("as_pattern"))
   ("assert_statement" ("module" "block" "_simple_statement"))
   ("assignment" ("augmented_assignment" "assignment" "expression_statement"))
   ("attribute" ("dictionary_splat_pattern" "list_splat" "list_splat_pattern" "pattern" "primary_expression"))
   ("augmented_assignment" ("augmented_assignment" "assignment" "expression_statement"))
   ("await" ("primary_expression"))
   ("binary_operator" ("primary_expression"))
   ("block" ("except_clause" "function_definition" "while_statement" "finally_clause" "case_clause" "class_definition" "elif_clause" "try_statement" "with_statement" "match_statement" "for_statement" "else_clause" "if_statement" "except_group_clause"))
   ("boolean_operator" ("expression"))
   ("break_statement" ("module" "block" "_simple_statement"))
   ("call" ("primary_expression"))
   ("case_clause" ("block"))
   ("case_pattern" ("tuple_pattern" "case_clause" "list_pattern" "as_pattern" "dict_pattern" "class_pattern"))
   ("chevron" ("print_statement"))
   ("class_definition" ("_compound_statement" "decorated_definition" "block" "module"))
   ("class_pattern" ("case_pattern" "keyword_pattern" "dict_pattern" "union_pattern"))
   ("comparison_operator" ("expression"))
   ("complex_pattern" ("case_pattern" "keyword_pattern" "dict_pattern" "union_pattern"))
   ("concatenated_string" ("union_pattern" "case_pattern" "primary_expression" "dict_pattern" "keyword_pattern"))
   ("conditional_expression" ("expression"))
   ("constrained_type" ("type"))
   ("continue_statement" ("module" "block" "_simple_statement"))
   ("decorated_definition" ("_compound_statement" "block" "module"))
   ("decorator" ("decorated_definition"))
   ("default_parameter" ("parameter"))
   ("delete_statement" ("module" "block" "_simple_statement"))
   ("dict_pattern" ("case_pattern" "keyword_pattern" "dict_pattern" "union_pattern"))
   ("dictionary" ("primary_expression"))
   ("dictionary_comprehension" ("primary_expression"))
   ("dictionary_splat" ("argument_list" "dictionary"))
   ("dictionary_splat_pattern" ("typed_parameter" "parameter"))
   ("dotted_name" ("import_from_statement" "aliased_import" "future_import_statement" "union_pattern" "case_pattern" "relative_import" "dict_pattern" "keyword_pattern" "import_statement" "class_pattern"))
   ("elif_clause" ("if_statement"))
   ("ellipsis" ("primary_expression"))
   ("else_clause" ("for_statement" "while_statement" "if_statement" "try_statement"))
   ("escape_interpolation" ("string_content"))
   ("escape_sequence" ("string_content"))
   ("except_clause" ("try_statement"))
   ("except_group_clause" ("try_statement"))
   ("exec_statement" ("module" "block" "_simple_statement"))
   ("expression" ("keyword_argument" "print_statement" "list_splat" "named_expression" "list_comprehension" "for_in_clause" "list" "assignment" "subscript" "tuple" "pair" "set_comprehension" "chevron" "default_parameter" "elif_clause" "slice" "if_clause" "for_statement" "except_group_clause" "parenthesized_expression" "return_statement" "set" "while_statement" "generator_expression" "raise_statement" "conditional_expression" "assert_statement" "augmented_assignment" "boolean_operator" "exec_statement" "dictionary_splat" "argument_list" "except_clause" "interpolation" "not_operator" "expression_list" "lambda" "decorator" "as_pattern" "with_item" "match_statement" "yield" "format_expression" "type" "if_statement" "expression_statement" "delete_statement" "typed_default_parameter"))
   ("expression_list" ("assignment" "interpolation" "raise_statement" "augmented_assignment" "yield" "format_expression" "for_statement" "delete_statement" "return_statement"))
   ("expression_statement" ("module" "block" "_simple_statement"))
   ("false" ("union_pattern" "case_pattern" "primary_expression" "dict_pattern" "keyword_pattern"))
   ("finally_clause" ("try_statement"))
   ("float" ("complex_pattern" "union_pattern" "case_pattern" "primary_expression" "dict_pattern" "keyword_pattern"))
   ("for_in_clause" ("dictionary_comprehension" "set_comprehension" "generator_expression" "list_comprehension"))
   ("for_statement" ("_compound_statement" "block" "module"))
   ("format_expression" ("format_specifier"))
   ("format_specifier" ("format_expression" "interpolation"))
   ("function_definition" ("_compound_statement" "decorated_definition" "block" "module"))
   ("future_import_statement" ("module" "block" "_simple_statement"))
   ("generator_expression" ("primary_expression" "call"))
   ("generic_type" ("type"))
   ("global_statement" ("module" "block" "_simple_statement"))
   ("identifier" ("dictionary_splat_pattern" "keyword_argument" "class_definition" "list_splat" "list_splat_pattern" "aliased_import" "named_expression" "primary_expression" "typed_parameter" "dotted_name" "splat_type" "attribute" "function_definition" "global_statement" "default_parameter" "keyword_pattern" "splat_pattern" "generic_type" "nonlocal_statement" "exec_statement" "as_pattern" "pattern" "member_type" "parameter" "typed_default_parameter"))
   ("if_clause" ("generator_expression" "case_clause" "set_comprehension" "list_comprehension" "dictionary_comprehension"))
   ("if_statement" ("_compound_statement" "block" "module"))
   ("import_from_statement" ("module" "block" "_simple_statement"))
   ("import_prefix" ("relative_import"))
   ("import_statement" ("module" "block" "_simple_statement"))
   ("integer" ("complex_pattern" "union_pattern" "case_pattern" "primary_expression" "dict_pattern" "keyword_pattern"))
   ("interpolation" ("string"))
   ("keyword_argument" ("argument_list"))
   ("keyword_pattern" ("case_pattern"))
   ("keyword_separator" ("parameter"))
   ("lambda" ("expression"))
   ("lambda_parameters" ("lambda"))
   ("list" ("primary_expression"))
   ("list_comprehension" ("primary_expression"))
   ("list_pattern" ("union_pattern" "case_pattern" "pattern" "dict_pattern" "keyword_pattern"))
   ("list_splat" ("list" "set" "parenthesized_list_splat" "tuple" "primary_expression" "argument_list" "parenthesized_expression"))
   ("list_splat_pattern" ("typed_parameter" "parameter" "pattern"))
   ("match_statement" ("_compound_statement" "block" "module"))
   ("member_type" ("type"))
   ("named_expression" ("expression"))
   ("none" ("union_pattern" "case_pattern" "primary_expression" "dict_pattern" "keyword_pattern"))
   ("nonlocal_statement" ("module" "block" "_simple_statement"))
   ("not_operator" ("expression"))
   ("pair" ("dictionary_comprehension" "dictionary"))
   ("parameter" ("parameters" "lambda_parameters"))
   ("parameters" ("function_definition"))
   ("parenthesized_expression" ("argument_list" "parenthesized_list_splat" "primary_expression" "parenthesized_expression"))
   ("parenthesized_list_splat" ("list" "set" "tuple"))
   ("pass_statement" ("module" "block" "_simple_statement"))
   ("pattern" ("tuple_pattern" "assignment" "pattern_list" "list_pattern" "augmented_assignment" "for_statement" "for_in_clause"))
   ("pattern_list" ("assignment" "interpolation" "augmented_assignment" "format_expression" "for_statement" "for_in_clause"))
   ("positional_separator" ("parameter"))
   ("primary_expression" ("subscript" "await" "binary_operator" "expression" "unary_operator" "call" "comparison_operator" "attribute"))
   ("print_statement" ("module" "block" "_simple_statement"))
   ("raise_statement" ("module" "block" "_simple_statement"))
   ("relative_import" ("import_from_statement"))
   ("return_statement" ("module" "block" "_simple_statement"))
   ("set" ("primary_expression"))
   ("set_comprehension" ("primary_expression"))
   ("slice" ("subscript"))
   ("splat_pattern" ("case_pattern" "keyword_pattern" "dict_pattern" "union_pattern"))
   ("splat_type" ("type"))
   ("string" ("concatenated_string" "union_pattern" "case_pattern" "primary_expression" "dict_pattern" "exec_statement" "keyword_pattern"))
   ("string_content" ("string"))
   ("string_end" ("string"))
   ("string_start" ("string"))
   ("subscript" ("dictionary_splat_pattern" "list_splat" "list_splat_pattern" "pattern" "primary_expression"))
   ("true" ("union_pattern" "case_pattern" "primary_expression" "dict_pattern" "keyword_pattern"))
   ("try_statement" ("_compound_statement" "block" "module"))
   ("tuple" ("primary_expression"))
   ("tuple_pattern" ("default_parameter" "union_pattern" "case_pattern" "pattern" "dict_pattern" "parameter" "keyword_pattern"))
   ("type" ("function_definition" "assignment" "constrained_type" "union_type" "member_type" "typed_parameter" "type_parameter" "type_alias_statement" "typed_default_parameter"))
   ("type_alias_statement" ("module" "block" "_simple_statement"))
   ("type_conversion" ("format_expression" "interpolation"))
   ("type_parameter" ("function_definition" "generic_type" "class_definition"))
   ("typed_default_parameter" ("parameter"))
   ("typed_parameter" ("parameter"))
   ("unary_operator" ("primary_expression"))
   ("union_pattern" ("case_pattern" "keyword_pattern" "dict_pattern" "union_pattern"))
   ("union_type" ("type"))
   ("while_statement" ("_compound_statement" "block" "module"))
   ("wildcard_import" ("import_from_statement"))
   ("with_clause" ("with_statement"))
   ("with_item" ("with_clause"))
   ("with_statement" ("_compound_statement" "block" "module"))
   ("yield" ("list" "set" "interpolation" "assignment" "tuple" "augmented_assignment" "format_expression" "expression_statement" "parenthesized_expression"))
  ) 
)
;; END Inverse production rules for python
;; START All node types in python
(defconst combobulate-rules-python-types 
 '("_compound_statement" "_simple_statement" "aliased_import" "argument_list" "as_pattern" "as_pattern_target" "assert_statement" "assignment" "attribute" "augmented_assignment" "await" "binary_operator" "block" "boolean_operator" "break_statement" "call" "case_clause" "case_pattern" "chevron" "class_definition" "class_pattern" "comment" "comparison_operator" "complex_pattern" "concatenated_string" "conditional_expression" "constrained_type" "continue_statement" "decorated_definition" "decorator" "default_parameter" "delete_statement" "dict_pattern" "dictionary" "dictionary_comprehension" "dictionary_splat" "dictionary_splat_pattern" "dotted_name" "elif_clause" "ellipsis" "else_clause" "escape_interpolation" "escape_sequence" "except_clause" "except_group_clause" "exec_statement" "expression" "expression_list" "expression_statement" "false" "finally_clause" "float" "for_in_clause" "for_statement" "format_expression" "format_specifier" "function_definition" "future_import_statement" "generator_expression" "generic_type" "global_statement" "identifier" "if_clause" "if_statement" "import_from_statement" "import_prefix" "import_statement" "integer" "interpolation" "keyword_argument" "keyword_pattern" "keyword_separator" "lambda" "lambda_parameters" "line_continuation" "list" "list_comprehension" "list_pattern" "list_splat" "list_splat_pattern" "match_statement" "member_type" "module" "named_expression" "none" "nonlocal_statement" "not_operator" "pair" "parameter" "parameters" "parenthesized_expression" "parenthesized_list_splat" "pass_statement" "pattern" "pattern_list" "positional_separator" "primary_expression" "print_statement" "raise_statement" "relative_import" "return_statement" "set" "set_comprehension" "slice" "splat_pattern" "splat_type" "string" "string_content" "string_end" "string_start" "subscript" "true" "try_statement" "tuple" "tuple_pattern" "type" "type_alias_statement" "type_conversion" "type_parameter" "typed_default_parameter" "typed_parameter" "unary_operator" "union_pattern" "union_type" "while_statement" "wildcard_import" "with_clause" "with_item" "with_statement" "yield") 
)
;; END All node types in python
;; START All supertypes in python
(defconst combobulate-rules-python-supertypes 
 '("_compound_statement" "_simple_statement" "expression" "parameter" "pattern" "primary_expression") 
)
;; END All supertypes in python

;; START Production rules for c
(defconst combobulate-rules-c 
 '(("_abstract_declarator" (:*unnamed* ("abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "abstract_pointer_declarator"))) 
 ("_declarator" (:*unnamed* ("array_declarator" "parenthesized_declarator" "attributed_declarator" "pointer_declarator" "identifier" "function_declarator"))) 
 ("_expression" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("_field_declarator" (:*unnamed* ("array_declarator" "parenthesized_declarator" "attributed_declarator" "pointer_declarator" "field_identifier" "function_declarator"))) 
 ("_statement" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "do_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("_type_declarator" (:*unnamed* ("array_declarator" "primitive_type" "parenthesized_declarator" "attributed_declarator" "type_identifier" "pointer_declarator" "function_declarator"))) 
 ("_type_specifier" (:*unnamed* ("primitive_type" "macro_type_specifier" "type_identifier" "sized_type_specifier" "enum_specifier" "union_specifier" "struct_specifier"))) 
 ("abstract_array_declarator" (:*unnamed* ("type_qualifier") :declarator ("abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "abstract_pointer_declarator") :size ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("abstract_function_declarator" (:*unnamed* nil :declarator ("abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "abstract_pointer_declarator") :parameters ("parameter_list"))) 
 ("abstract_parenthesized_declarator" (:*unnamed* ("abstract_parenthesized_declarator" "abstract_function_declarator" "ms_call_modifier" "abstract_array_declarator" "abstract_pointer_declarator"))) 
 ("abstract_pointer_declarator" (:*unnamed* ("type_qualifier" "ms_pointer_modifier") :declarator ("abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "abstract_pointer_declarator"))) 
 ("alignof_expression" (:*unnamed* nil :type ("type_descriptor"))) 
 ("argument_list" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "compound_statement" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "preproc_defined" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("array_declarator" (:*unnamed* ("type_qualifier") :declarator ("primitive_type" "pointer_declarator" "identifier" "field_identifier" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_identifier" "function_declarator") :size ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("assignment_expression" (:*unnamed* nil :left ("field_expression" "pointer_expression" "identifier" "call_expression" "subscript_expression" "parenthesized_expression") :operator nil :right ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("attribute" (:*unnamed* ("argument_list") :name ("identifier") :prefix ("identifier"))) 
 ("attribute_declaration" (:*unnamed* ("attribute"))) 
 ("attribute_specifier" (:*unnamed* ("argument_list"))) 
 ("attributed_declarator" (:*unnamed* ("primitive_type" "pointer_declarator" "identifier" "field_identifier" "attribute_declaration" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_identifier" "function_declarator"))) 
 ("attributed_statement" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "attribute_declaration" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "do_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("binary_expression" (:*unnamed* nil :left ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "preproc_defined" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :operator nil :right ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "preproc_defined" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("bitfield_clause" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("break_statement" (:*unnamed* nil)) 
 ("call_expression" (:*unnamed* nil :arguments ("argument_list") :function ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("case_statement" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "switch_statement" "attributed_statement" "type_definition" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "declaration" "do_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :value ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("cast_expression" (:*unnamed* nil :type ("type_descriptor") :value ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("char_literal" (:*unnamed* ("escape_sequence" "character"))) 
 ("character" (:*unnamed* nil)) 
 ("comma_expression" (:*unnamed* nil :left ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :right ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "comma_expression" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("comment" (:*unnamed* nil)) 
 ("compound_literal_expression" (:*unnamed* nil :type ("type_descriptor") :value ("initializer_list"))) 
 ("compound_statement" (:*unnamed* ("labeled_statement" "seh_leave_statement" "attributed_statement" "preproc_call" "type_definition" "preproc_if" "compound_statement" "function_definition" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "preproc_ifdef" "type_identifier" "case_statement" "for_statement" "return_statement" "preproc_def" "while_statement" "macro_type_specifier" "sized_type_specifier" "preproc_function_def" "switch_statement" "union_specifier" "break_statement" "primitive_type" "seh_try_statement" "do_statement" "struct_specifier" "goto_statement" "if_statement" "expression_statement"))) 
 ("concatenated_string" (:*unnamed* ("identifier" "string_literal"))) 
 ("conditional_expression" (:*unnamed* nil :alternative ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :condition ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :consequence ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "comma_expression" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("continue_statement" (:*unnamed* nil)) 
 ("declaration" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "storage_class_specifier" "type_qualifier" "attribute_declaration") :declarator ("pointer_declarator" "init_declarator" "identifier" "array_declarator" "gnu_asm_expression" "parenthesized_declarator" "attributed_declarator" "ms_call_modifier" "function_declarator") :type ("primitive_type" "macro_type_specifier" "type_identifier" "sized_type_specifier" "enum_specifier" "union_specifier" "struct_specifier"))) 
 ("declaration_list" (:*unnamed* ("labeled_statement" "seh_leave_statement" "attributed_statement" "preproc_call" "type_definition" "preproc_if" "compound_statement" "function_definition" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "preproc_ifdef" "type_identifier" "case_statement" "for_statement" "return_statement" "preproc_def" "while_statement" "macro_type_specifier" "sized_type_specifier" "preproc_function_def" "switch_statement" "union_specifier" "break_statement" "primitive_type" "seh_try_statement" "do_statement" "struct_specifier" "goto_statement" "if_statement" "expression_statement"))) 
 ("do_statement" (:*unnamed* nil :body ("while_statement" "labeled_statement" "seh_leave_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "do_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "do_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("enum_specifier" (:*unnamed* ("attribute_specifier") :body ("enumerator_list") :name ("type_identifier") :underlying_type ("primitive_type"))) 
 ("enumerator" (:*unnamed* nil :name ("identifier") :value ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("enumerator_list" (:*unnamed* ("enumerator" "preproc_if" "preproc_call" "preproc_ifdef"))) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("expression_statement" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "comma_expression" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("false" (:*unnamed* nil)) 
 ("field_declaration" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "bitfield_clause" "storage_class_specifier" "type_qualifier" "attribute_declaration") :declarator ("array_declarator" "parenthesized_declarator" "attributed_declarator" "pointer_declarator" "field_identifier" "function_declarator") :type ("primitive_type" "macro_type_specifier" "type_identifier" "sized_type_specifier" "enum_specifier" "union_specifier" "struct_specifier"))) 
 ("field_declaration_list" (:*unnamed* ("preproc_def" "preproc_call" "preproc_if" "preproc_function_def" "field_declaration" "preproc_ifdef"))) 
 ("field_designator" (:*unnamed* ("field_identifier"))) 
 ("field_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :field ("field_identifier") :operator nil)) 
 ("field_identifier" (:*unnamed* nil)) 
 ("for_statement" (:*unnamed* nil :body ("while_statement" "labeled_statement" "seh_leave_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "do_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :condition ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "comma_expression" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :initializer ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "comma_expression" "declaration" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :update ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "comma_expression" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("function_declarator" (:*unnamed* ("attribute_specifier" "gnu_asm_expression" "identifier" "call_expression") :declarator ("primitive_type" "pointer_declarator" "identifier" "field_identifier" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_identifier" "function_declarator") :parameters ("parameter_list"))) 
 ("function_definition" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "ms_call_modifier" "storage_class_specifier" "type_qualifier" "declaration" "attribute_declaration") :body ("compound_statement") :declarator ("array_declarator" "parenthesized_declarator" "attributed_declarator" "pointer_declarator" "identifier" "function_declarator") :type ("primitive_type" "macro_type_specifier" "type_identifier" "sized_type_specifier" "enum_specifier" "union_specifier" "struct_specifier"))) 
 ("generic_expression" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "type_descriptor" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("gnu_asm_clobber_list" (:*unnamed* nil :register ("concatenated_string" "string_literal"))) 
 ("gnu_asm_expression" (:*unnamed* ("gnu_asm_qualifier") :assembly_code ("concatenated_string" "string_literal") :clobbers ("gnu_asm_clobber_list") :goto_labels ("gnu_asm_goto_list") :input_operands ("gnu_asm_input_operand_list") :output_operands ("gnu_asm_output_operand_list"))) 
 ("gnu_asm_goto_list" (:*unnamed* nil :label ("identifier"))) 
 ("gnu_asm_input_operand" (:*unnamed* nil :constraint ("string_literal") :symbol ("identifier") :value ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("gnu_asm_input_operand_list" (:*unnamed* nil :operand ("gnu_asm_input_operand"))) 
 ("gnu_asm_output_operand" (:*unnamed* nil :constraint ("string_literal") :symbol ("identifier") :value ("identifier"))) 
 ("gnu_asm_output_operand_list" (:*unnamed* nil :operand ("gnu_asm_output_operand"))) 
 ("gnu_asm_qualifier" (:*unnamed* nil)) 
 ("goto_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("identifier" (:*unnamed* nil)) 
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("while_statement" "labeled_statement" "seh_leave_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "do_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("init_declarator" (:*unnamed* nil :declarator ("array_declarator" "parenthesized_declarator" "attributed_declarator" "pointer_declarator" "identifier" "function_declarator") :value ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "initializer_list" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("initializer_list" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "initializer_list" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "initializer_pair" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("initializer_pair" (:*unnamed* nil :designator ("subscript_designator" "field_designator" "field_identifier" "subscript_range_designator") :value ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "initializer_list" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("labeled_statement" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "do_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :label ("statement_identifier"))) 
 ("linkage_specification" (:*unnamed* nil :body ("function_definition" "declaration_list" "declaration") :value ("string_literal"))) 
 ("macro_type_specifier" (:*unnamed* nil :name ("identifier") :type ("type_descriptor"))) 
 ("ms_based_modifier" (:*unnamed* ("argument_list"))) 
 ("ms_call_modifier" (:*unnamed* nil)) 
 ("ms_declspec_modifier" (:*unnamed* ("identifier"))) 
 ("ms_pointer_modifier" (:*unnamed* ("ms_unsigned_ptr_modifier" "ms_unaligned_ptr_modifier" "ms_restrict_modifier" "ms_signed_ptr_modifier"))) 
 ("ms_restrict_modifier" (:*unnamed* nil)) 
 ("ms_signed_ptr_modifier" (:*unnamed* nil)) 
 ("ms_unaligned_ptr_modifier" (:*unnamed* nil)) 
 ("ms_unsigned_ptr_modifier" (:*unnamed* nil)) 
 ("null" (:*unnamed* nil)) 
 ("number_literal" (:*unnamed* nil)) 
 ("offsetof_expression" (:*unnamed* nil :member ("field_identifier") :type ("type_descriptor"))) 
 ("parameter_declaration" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "storage_class_specifier" "type_qualifier" "attribute_declaration") :declarator ("pointer_declarator" "identifier" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "array_declarator" "parenthesized_declarator" "abstract_function_declarator" "attributed_declarator" "abstract_array_declarator" "function_declarator") :type ("primitive_type" "macro_type_specifier" "type_identifier" "sized_type_specifier" "enum_specifier" "union_specifier" "struct_specifier"))) 
 ("parameter_list" (:*unnamed* ("identifier" "variadic_parameter" "parameter_declaration"))) 
 ("parenthesized_declarator" (:*unnamed* ("primitive_type" "pointer_declarator" "identifier" "field_identifier" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_identifier" "ms_call_modifier" "function_declarator"))) 
 ("parenthesized_expression" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "comma_expression" "subscript_expression" "gnu_asm_expression" "number_literal" "preproc_defined" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("pointer_declarator" (:*unnamed* ("type_qualifier" "ms_based_modifier" "ms_pointer_modifier") :declarator ("primitive_type" "pointer_declarator" "identifier" "field_identifier" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_identifier" "function_declarator"))) 
 ("pointer_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :operator nil)) 
 ("preproc_arg" (:*unnamed* nil)) 
 ("preproc_call" (:*unnamed* nil :argument ("preproc_arg") :directive ("preproc_directive"))) 
 ("preproc_def" (:*unnamed* nil :name ("identifier") :value ("preproc_arg"))) 
 ("preproc_defined" (:*unnamed* ("identifier"))) 
 ("preproc_directive" (:*unnamed* nil)) 
 ("preproc_elif" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "attributed_statement" "preproc_call" "type_definition" "preproc_if" "compound_statement" "function_definition" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "preproc_ifdef" "type_identifier" "case_statement" "for_statement" "return_statement" "preproc_def" "while_statement" "macro_type_specifier" "sized_type_specifier" "preproc_function_def" "field_declaration" "switch_statement" "union_specifier" "break_statement" "primitive_type" "seh_try_statement" "do_statement" "struct_specifier" "goto_statement" "if_statement" "expression_statement") :alternative ("preproc_elifdef" "preproc_elif" "preproc_else") :condition ("char_literal" "unary_expression" "identifier" "binary_expression" "number_literal" "preproc_defined" "call_expression" "parenthesized_expression"))) 
 ("preproc_elifdef" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "attributed_statement" "preproc_call" "type_definition" "preproc_if" "compound_statement" "function_definition" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "preproc_ifdef" "type_identifier" "case_statement" "for_statement" "return_statement" "preproc_def" "while_statement" "macro_type_specifier" "sized_type_specifier" "preproc_function_def" "field_declaration" "switch_statement" "union_specifier" "break_statement" "primitive_type" "seh_try_statement" "do_statement" "struct_specifier" "goto_statement" "if_statement" "expression_statement") :alternative ("preproc_elifdef" "preproc_elif" "preproc_else") :name ("identifier"))) 
 ("preproc_else" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "attributed_statement" "preproc_call" "type_definition" "preproc_if" "compound_statement" "function_definition" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "preproc_ifdef" "type_identifier" "case_statement" "for_statement" "return_statement" "preproc_def" "while_statement" "macro_type_specifier" "sized_type_specifier" "preproc_function_def" "field_declaration" "switch_statement" "union_specifier" "break_statement" "primitive_type" "seh_try_statement" "do_statement" "struct_specifier" "goto_statement" "if_statement" "expression_statement"))) 
 ("preproc_function_def" (:*unnamed* nil :name ("identifier") :parameters ("preproc_params") :value ("preproc_arg"))) 
 ("preproc_if" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "attributed_statement" "preproc_call" "type_definition" "preproc_if" "compound_statement" "function_definition" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "preproc_ifdef" "type_identifier" "case_statement" "for_statement" "return_statement" "preproc_def" "while_statement" "macro_type_specifier" "sized_type_specifier" "preproc_function_def" "field_declaration" "switch_statement" "union_specifier" "break_statement" "primitive_type" "seh_try_statement" "do_statement" "struct_specifier" "goto_statement" "if_statement" "expression_statement") :alternative ("preproc_elifdef" "preproc_elif" "preproc_else") :condition ("char_literal" "unary_expression" "identifier" "binary_expression" "number_literal" "preproc_defined" "call_expression" "parenthesized_expression"))) 
 ("preproc_ifdef" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "attributed_statement" "preproc_call" "type_definition" "preproc_if" "compound_statement" "function_definition" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "preproc_ifdef" "type_identifier" "case_statement" "for_statement" "return_statement" "preproc_def" "while_statement" "macro_type_specifier" "sized_type_specifier" "preproc_function_def" "field_declaration" "switch_statement" "union_specifier" "break_statement" "primitive_type" "seh_try_statement" "do_statement" "struct_specifier" "goto_statement" "if_statement" "expression_statement") :alternative ("preproc_elifdef" "preproc_elif" "preproc_else") :name ("identifier"))) 
 ("preproc_include" (:*unnamed* nil :path ("identifier" "string_literal" "call_expression" "system_lib_string"))) 
 ("preproc_params" (:*unnamed* ("identifier"))) 
 ("primitive_type" (:*unnamed* nil)) 
 ("return_statement" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "comma_expression" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("seh_except_clause" (:*unnamed* nil :body ("compound_statement") :filter ("parenthesized_expression"))) 
 ("seh_finally_clause" (:*unnamed* nil :body ("compound_statement"))) 
 ("seh_leave_statement" (:*unnamed* nil)) 
 ("seh_try_statement" (:*unnamed* ("seh_except_clause" "seh_finally_clause") :body ("compound_statement"))) 
 ("sized_type_specifier" (:*unnamed* nil :type ("primitive_type" "type_identifier"))) 
 ("sizeof_expression" (:*unnamed* nil :type ("type_descriptor") :value ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("statement_identifier" (:*unnamed* nil)) 
 ("storage_class_specifier" (:*unnamed* nil)) 
 ("string_content" (:*unnamed* nil)) 
 ("string_literal" (:*unnamed* ("escape_sequence" "string_content"))) 
 ("struct_specifier" (:*unnamed* ("attribute_specifier" "ms_declspec_modifier") :body ("field_declaration_list") :name ("type_identifier"))) 
 ("subscript_designator" (:*unnamed* ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("subscript_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :index ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("subscript_range_designator" (:*unnamed* nil :end ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :start ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression"))) 
 ("switch_statement" (:*unnamed* nil :body ("compound_statement") :condition ("parenthesized_expression"))) 
 ("system_lib_string" (:*unnamed* nil)) 
 ("translation_unit" (:*unnamed* ("preproc_def" "while_statement" "macro_type_specifier" "labeled_statement" "sized_type_specifier" "preproc_function_def" "switch_statement" "attributed_statement" "preproc_call" "type_definition" "preproc_if" "union_specifier" "break_statement" "compound_statement" "primitive_type" "function_definition" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "do_statement" "struct_specifier" "preproc_ifdef" "type_identifier" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("true" (:*unnamed* nil)) 
 ("type_definition" (:*unnamed* ("attribute_specifier" "type_qualifier") :declarator ("array_declarator" "primitive_type" "parenthesized_declarator" "attributed_declarator" "type_identifier" "pointer_declarator" "function_declarator") :type ("primitive_type" "macro_type_specifier" "type_identifier" "sized_type_specifier" "enum_specifier" "union_specifier" "struct_specifier"))) 
 ("type_descriptor" (:*unnamed* ("type_qualifier") :declarator ("abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "abstract_pointer_declarator") :type ("primitive_type" "macro_type_specifier" "type_identifier" "sized_type_specifier" "enum_specifier" "union_specifier" "struct_specifier"))) 
 ("type_identifier" (:*unnamed* nil)) 
 ("type_qualifier" (:*unnamed* nil)) 
 ("unary_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "preproc_defined" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :operator nil)) 
 ("union_specifier" (:*unnamed* ("attribute_specifier" "ms_declspec_modifier") :body ("field_declaration_list") :name ("type_identifier"))) 
 ("update_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "conditional_expression" "binary_expression" "false" "pointer_expression" "update_expression" "offsetof_expression" "alignof_expression" "generic_expression" "field_expression" "concatenated_string" "unary_expression" "assignment_expression" "sizeof_expression" "null" "identifier" "subscript_expression" "gnu_asm_expression" "number_literal" "cast_expression" "true" "call_expression" "compound_literal_expression" "parenthesized_expression") :operator nil)) 
 ("variadic_parameter" (:*unnamed* nil)) 
 ("while_statement" (:*unnamed* nil :body ("while_statement" "labeled_statement" "seh_leave_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "seh_try_statement" "do_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :condition ("parenthesized_expression"))) 
))
;; END Production rules for c
;; START Inverse production rules for c
(defconst combobulate-rules-c-inverse 
 '(("abstract_array_declarator" ("type_descriptor" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("abstract_function_declarator" ("type_descriptor" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("abstract_parenthesized_declarator" ("type_descriptor" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("abstract_pointer_declarator" ("type_descriptor" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("alignof_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("argument_list" ("attribute_specifier" "attribute" "call_expression" "ms_based_modifier"))
   ("array_declarator" ("function_definition" "_type_declarator" "_field_declarator" "pointer_declarator" "_declarator" "init_declarator" "declaration" "field_declaration" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_definition" "function_declarator" "parameter_declaration"))
   ("assignment_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("attribute" ("attribute_declaration"))
   ("attribute_declaration" ("function_definition" "declaration" "field_declaration" "attributed_declarator" "attributed_statement" "parameter_declaration"))
   ("attribute_specifier" ("function_definition" "enum_specifier" "declaration" "field_declaration" "struct_specifier" "type_definition" "union_specifier" "function_declarator" "parameter_declaration"))
   ("attributed_declarator" ("function_definition" "_type_declarator" "_field_declarator" "pointer_declarator" "_declarator" "init_declarator" "declaration" "field_declaration" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_definition" "function_declarator" "parameter_declaration"))
   ("attributed_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("binary_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "preproc_if" "abstract_array_declarator" "field_expression" "assignment_expression" "preproc_elif" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("bitfield_clause" ("field_declaration"))
   ("break_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("call_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "preproc_if" "abstract_array_declarator" "field_expression" "assignment_expression" "preproc_include" "preproc_elif" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "function_declarator" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("case_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("cast_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("char_literal" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "preproc_if" "abstract_array_declarator" "field_expression" "assignment_expression" "preproc_elif" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("character" ("char_literal"))
   ("comma_expression" ("comma_expression" "conditional_expression" "return_statement" "for_statement" "expression_statement" "parenthesized_expression"))
   ("compound_literal_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("compound_statement" ("seh_finally_clause" "labeled_statement" "translation_unit" "attributed_statement" "_statement" "seh_except_clause" "preproc_if" "compound_statement" "function_definition" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "case_statement" "for_statement" "else_clause" "preproc_elifdef" "while_statement" "switch_statement" "argument_list" "seh_try_statement" "do_statement" "if_statement"))
   ("concatenated_string" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "gnu_asm_clobber_list" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "gnu_asm_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("conditional_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("continue_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("declaration" ("preproc_elifdef" "function_definition" "linkage_specification" "preproc_if" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "case_statement" "for_statement" "compound_statement"))
   ("declaration_list" ("linkage_specification"))
   ("do_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("else_clause" ("if_statement"))
   ("enum_specifier" ("preproc_elifdef" "function_definition" "type_descriptor" "declaration" "_type_specifier" "field_declaration" "preproc_ifdef" "translation_unit" "declaration_list" "preproc_elif" "preproc_else" "type_definition" "preproc_if" "compound_statement" "parameter_declaration"))
   ("enumerator" ("preproc_elifdef" "enumerator_list" "preproc_ifdef" "preproc_elif" "preproc_else" "preproc_if"))
   ("enumerator_list" ("enum_specifier"))
   ("escape_sequence" ("char_literal" "string_literal"))
   ("expression_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("false" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("field_declaration" ("preproc_elifdef" "preproc_ifdef" "field_declaration_list" "preproc_elif" "preproc_else" "preproc_if"))
   ("field_declaration_list" ("union_specifier" "struct_specifier"))
   ("field_designator" ("initializer_pair"))
   ("field_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("field_identifier" ("field_expression" "_field_declarator" "pointer_declarator" "field_declaration" "array_declarator" "parenthesized_declarator" "attributed_declarator" "offsetof_expression" "field_designator" "function_declarator" "initializer_pair"))
   ("for_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("function_declarator" ("function_definition" "_type_declarator" "_field_declarator" "pointer_declarator" "_declarator" "init_declarator" "declaration" "field_declaration" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_definition" "function_declarator" "parameter_declaration"))
   ("function_definition" ("preproc_elifdef" "linkage_specification" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("generic_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("gnu_asm_clobber_list" ("gnu_asm_expression"))
   ("gnu_asm_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "declaration" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "function_declarator" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("gnu_asm_goto_list" ("gnu_asm_expression"))
   ("gnu_asm_input_operand" ("gnu_asm_input_operand_list"))
   ("gnu_asm_input_operand_list" ("gnu_asm_expression"))
   ("gnu_asm_output_operand" ("gnu_asm_output_operand_list"))
   ("gnu_asm_output_operand_list" ("gnu_asm_expression"))
   ("gnu_asm_qualifier" ("gnu_asm_expression"))
   ("goto_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("identifier" ("enumerator" "ms_declspec_modifier" "gnu_asm_input_operand" "pointer_expression" "_expression" "preproc_if" "abstract_array_declarator" "attribute" "field_expression" "function_definition" "assignment_expression" "parameter_list" "preproc_include" "declaration" "preproc_ifdef" "parenthesized_declarator" "attributed_declarator" "preproc_elif" "case_statement" "cast_expression" "for_statement" "call_expression" "parameter_declaration" "parenthesized_expression" "preproc_def" "preproc_elifdef" "return_statement" "macro_type_specifier" "subscript_range_designator" "pointer_declarator" "init_declarator" "conditional_expression" "preproc_function_def" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "function_declarator" "gnu_asm_goto_list" "generic_expression" "gnu_asm_output_operand" "concatenated_string" "preproc_params" "unary_expression" "bitfield_clause" "sizeof_expression" "_declarator" "comma_expression" "subscript_designator" "preproc_defined" "subscript_expression" "expression_statement" "initializer_pair"))
   ("if_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("init_declarator" ("declaration"))
   ("initializer_list" ("init_declarator" "initializer_list" "compound_literal_expression" "initializer_pair"))
   ("initializer_pair" ("initializer_list"))
   ("labeled_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("linkage_specification" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("macro_type_specifier" ("preproc_elifdef" "function_definition" "type_descriptor" "declaration" "_type_specifier" "field_declaration" "preproc_ifdef" "translation_unit" "declaration_list" "preproc_elif" "preproc_else" "type_definition" "preproc_if" "compound_statement" "parameter_declaration"))
   ("ms_based_modifier" ("pointer_declarator"))
   ("ms_call_modifier" ("abstract_parenthesized_declarator" "function_definition" "parenthesized_declarator" "declaration"))
   ("ms_declspec_modifier" ("function_definition" "declaration" "field_declaration" "struct_specifier" "union_specifier" "parameter_declaration"))
   ("ms_pointer_modifier" ("pointer_declarator" "abstract_pointer_declarator"))
   ("ms_restrict_modifier" ("ms_pointer_modifier"))
   ("ms_signed_ptr_modifier" ("ms_pointer_modifier"))
   ("ms_unaligned_ptr_modifier" ("ms_pointer_modifier"))
   ("ms_unsigned_ptr_modifier" ("ms_pointer_modifier"))
   ("null" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("number_literal" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "preproc_if" "abstract_array_declarator" "field_expression" "assignment_expression" "preproc_elif" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("offsetof_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("parameter_declaration" ("parameter_list"))
   ("parameter_list" ("abstract_function_declarator" "function_declarator"))
   ("parenthesized_declarator" ("function_definition" "_type_declarator" "_field_declarator" "pointer_declarator" "_declarator" "init_declarator" "declaration" "field_declaration" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_definition" "function_declarator" "parameter_declaration"))
   ("parenthesized_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "seh_except_clause" "preproc_if" "abstract_array_declarator" "field_expression" "assignment_expression" "preproc_elif" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "while_statement" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "switch_statement" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "do_statement" "subscript_designator" "subscript_expression" "if_statement" "expression_statement" "initializer_pair"))
   ("pointer_declarator" ("function_definition" "_type_declarator" "_field_declarator" "pointer_declarator" "_declarator" "init_declarator" "declaration" "field_declaration" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_definition" "function_declarator" "parameter_declaration"))
   ("pointer_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("preproc_arg" ("preproc_def" "preproc_function_def" "preproc_call"))
   ("preproc_call" ("preproc_elifdef" "enumerator_list" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_def" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_defined" ("unary_expression" "binary_expression" "preproc_elif" "preproc_if" "argument_list" "parenthesized_expression"))
   ("preproc_directive" ("preproc_call"))
   ("preproc_elif" ("preproc_elifdef" "preproc_if" "preproc_elif" "preproc_ifdef"))
   ("preproc_elifdef" ("preproc_elifdef" "preproc_if" "preproc_elif" "preproc_ifdef"))
   ("preproc_else" ("preproc_elifdef" "preproc_if" "preproc_elif" "preproc_ifdef"))
   ("preproc_function_def" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_if" ("preproc_elifdef" "enumerator_list" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_ifdef" ("preproc_elifdef" "enumerator_list" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_include" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_params" ("preproc_function_def"))
   ("primitive_type" ("_type_declarator" "translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "enum_specifier" "declaration" "preproc_ifdef" "parenthesized_declarator" "declaration_list" "attributed_declarator" "preproc_elif" "preproc_else" "parameter_declaration" "preproc_elifdef" "pointer_declarator" "sized_type_specifier" "_type_specifier" "field_declaration" "array_declarator" "function_declarator" "type_descriptor"))
   ("return_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("seh_except_clause" ("seh_try_statement"))
   ("seh_finally_clause" ("seh_try_statement"))
   ("seh_leave_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("seh_try_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("sized_type_specifier" ("preproc_elifdef" "function_definition" "type_descriptor" "declaration" "_type_specifier" "field_declaration" "preproc_ifdef" "translation_unit" "declaration_list" "preproc_elif" "preproc_else" "type_definition" "preproc_if" "compound_statement" "parameter_declaration"))
   ("sizeof_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("statement_identifier" ("labeled_statement" "goto_statement"))
   ("storage_class_specifier" ("function_definition" "declaration" "field_declaration" "parameter_declaration"))
   ("string_content" ("string_literal"))
   ("string_literal" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "linkage_specification" "preproc_include" "case_statement" "gnu_asm_clobber_list" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "gnu_asm_output_operand" "generic_expression" "concatenated_string" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "gnu_asm_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("struct_specifier" ("preproc_elifdef" "function_definition" "type_descriptor" "declaration" "_type_specifier" "field_declaration" "preproc_ifdef" "translation_unit" "declaration_list" "preproc_elif" "preproc_else" "type_definition" "preproc_if" "compound_statement" "parameter_declaration"))
   ("subscript_designator" ("initializer_pair"))
   ("subscript_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("subscript_range_designator" ("initializer_pair"))
   ("switch_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("system_lib_string" ("preproc_include"))
   ("true" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("type_definition" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "case_statement" "preproc_if" "compound_statement"))
   ("type_descriptor" ("macro_type_specifier" "sizeof_expression" "offsetof_expression" "cast_expression" "alignof_expression" "compound_literal_expression" "generic_expression"))
   ("type_identifier" ("_type_declarator" "translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "enum_specifier" "declaration" "preproc_ifdef" "parenthesized_declarator" "declaration_list" "attributed_declarator" "preproc_elif" "preproc_else" "parameter_declaration" "preproc_elifdef" "pointer_declarator" "sized_type_specifier" "_type_specifier" "field_declaration" "array_declarator" "union_specifier" "function_declarator" "type_descriptor" "struct_specifier"))
   ("type_qualifier" ("function_definition" "pointer_declarator" "type_descriptor" "declaration" "field_declaration" "abstract_pointer_declarator" "array_declarator" "type_definition" "abstract_array_declarator" "parameter_declaration"))
   ("unary_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "preproc_if" "abstract_array_declarator" "field_expression" "assignment_expression" "preproc_elif" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("union_specifier" ("preproc_elifdef" "function_definition" "type_descriptor" "declaration" "_type_specifier" "field_declaration" "preproc_ifdef" "translation_unit" "declaration_list" "preproc_elif" "preproc_else" "type_definition" "preproc_if" "compound_statement" "parameter_declaration"))
   ("update_expression" ("enumerator" "gnu_asm_input_operand" "pointer_expression" "_expression" "abstract_array_declarator" "field_expression" "assignment_expression" "case_statement" "for_statement" "cast_expression" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "init_declarator" "conditional_expression" "binary_expression" "array_declarator" "update_expression" "argument_list" "initializer_list" "generic_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "comma_expression" "subscript_designator" "subscript_expression" "expression_statement" "initializer_pair"))
   ("variadic_parameter" ("parameter_list"))
   ("while_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
  ) 
)
;; END Inverse production rules for c
;; START All node types in c
(defconst combobulate-rules-c-types 
 '("_abstract_declarator" "_declarator" "_expression" "_field_declarator" "_statement" "_type_declarator" "_type_specifier" "abstract_array_declarator" "abstract_function_declarator" "abstract_parenthesized_declarator" "abstract_pointer_declarator" "alignof_expression" "argument_list" "array_declarator" "assignment_expression" "attribute" "attribute_declaration" "attribute_specifier" "attributed_declarator" "attributed_statement" "binary_expression" "bitfield_clause" "break_statement" "call_expression" "case_statement" "cast_expression" "char_literal" "character" "comma_expression" "comment" "compound_literal_expression" "compound_statement" "concatenated_string" "conditional_expression" "continue_statement" "declaration" "declaration_list" "do_statement" "else_clause" "enum_specifier" "enumerator" "enumerator_list" "escape_sequence" "expression_statement" "false" "field_declaration" "field_declaration_list" "field_designator" "field_expression" "field_identifier" "for_statement" "function_declarator" "function_definition" "generic_expression" "gnu_asm_clobber_list" "gnu_asm_expression" "gnu_asm_goto_list" "gnu_asm_input_operand" "gnu_asm_input_operand_list" "gnu_asm_output_operand" "gnu_asm_output_operand_list" "gnu_asm_qualifier" "goto_statement" "identifier" "if_statement" "init_declarator" "initializer_list" "initializer_pair" "labeled_statement" "linkage_specification" "macro_type_specifier" "ms_based_modifier" "ms_call_modifier" "ms_declspec_modifier" "ms_pointer_modifier" "ms_restrict_modifier" "ms_signed_ptr_modifier" "ms_unaligned_ptr_modifier" "ms_unsigned_ptr_modifier" "null" "number_literal" "offsetof_expression" "parameter_declaration" "parameter_list" "parenthesized_declarator" "parenthesized_expression" "pointer_declarator" "pointer_expression" "preproc_arg" "preproc_call" "preproc_def" "preproc_defined" "preproc_directive" "preproc_elif" "preproc_elifdef" "preproc_else" "preproc_function_def" "preproc_if" "preproc_ifdef" "preproc_include" "preproc_params" "primitive_type" "return_statement" "seh_except_clause" "seh_finally_clause" "seh_leave_statement" "seh_try_statement" "sized_type_specifier" "sizeof_expression" "statement_identifier" "storage_class_specifier" "string_content" "string_literal" "struct_specifier" "subscript_designator" "subscript_expression" "subscript_range_designator" "switch_statement" "system_lib_string" "translation_unit" "true" "type_definition" "type_descriptor" "type_identifier" "type_qualifier" "unary_expression" "union_specifier" "update_expression" "variadic_parameter" "while_statement") 
)
;; END All node types in c
;; START All supertypes in c
(defconst combobulate-rules-c-supertypes 
 '("_abstract_declarator" "_declarator" "_expression" "_field_declarator" "_statement" "_type_declarator" "_type_specifier") 
)
;; END All supertypes in c

;; START Production rules for html
(defconst combobulate-rules-html 
 '(("attribute" (:*unnamed* ("attribute_value" "quoted_attribute_value" "attribute_name"))) 
 ("attribute_name" (:*unnamed* nil)) 
 ("attribute_value" (:*unnamed* nil)) 
 ("comment" (:*unnamed* nil)) 
 ("doctype" (:*unnamed* nil)) 
 ("document" (:*unnamed* ("doctype" "script_element" "element" "text" "style_element" "erroneous_end_tag" "entity"))) 
 ("element" (:*unnamed* ("doctype" "script_element" "element" "self_closing_tag" "start_tag" "erroneous_end_tag" "entity" "text" "end_tag" "style_element"))) 
 ("end_tag" (:*unnamed* ("tag_name"))) 
 ("entity" (:*unnamed* nil)) 
 ("erroneous_end_tag" (:*unnamed* ("erroneous_end_tag_name"))) 
 ("erroneous_end_tag_name" (:*unnamed* nil)) 
 ("quoted_attribute_value" (:*unnamed* ("attribute_value"))) 
 ("raw_text" (:*unnamed* nil)) 
 ("script_element" (:*unnamed* ("start_tag" "raw_text" "end_tag"))) 
 ("self_closing_tag" (:*unnamed* ("tag_name" "attribute"))) 
 ("start_tag" (:*unnamed* ("tag_name" "attribute"))) 
 ("style_element" (:*unnamed* ("start_tag" "raw_text" "end_tag"))) 
 ("tag_name" (:*unnamed* nil)) 
 ("text" (:*unnamed* nil)) 
))
;; END Production rules for html
;; START Inverse production rules for html
(defconst combobulate-rules-html-inverse 
 '(("attribute" ("start_tag" "self_closing_tag"))
   ("attribute_name" ("attribute"))
   ("attribute_value" ("attribute" "quoted_attribute_value"))
   ("doctype" ("element" "document"))
   ("element" ("element" "document"))
   ("end_tag" ("script_element" "style_element" "element"))
   ("entity" ("element" "document"))
   ("erroneous_end_tag" ("element" "document"))
   ("erroneous_end_tag_name" ("erroneous_end_tag"))
   ("quoted_attribute_value" ("attribute"))
   ("raw_text" ("script_element" "style_element"))
   ("script_element" ("element" "document"))
   ("self_closing_tag" ("element"))
   ("start_tag" ("script_element" "style_element" "element"))
   ("style_element" ("element" "document"))
   ("tag_name" ("self_closing_tag" "start_tag" "end_tag"))
   ("text" ("element" "document"))
  ) 
)
;; END Inverse production rules for html
;; START All node types in html
(defconst combobulate-rules-html-types 
 '("attribute" "attribute_name" "attribute_value" "comment" "doctype" "document" "element" "end_tag" "entity" "erroneous_end_tag" "erroneous_end_tag_name" "quoted_attribute_value" "raw_text" "script_element" "self_closing_tag" "start_tag" "style_element" "tag_name" "text") 
)
;; END All node types in html
;; START All supertypes in html
(defconst combobulate-rules-html-supertypes 
 nil 
)
;; END All supertypes in html

;; START Production rules for toml
(defconst combobulate-rules-toml 
 '(("array" (:*unnamed* ("local_date" "array" "inline_table" "local_date_time" "boolean" "integer" "local_time" "string" "offset_date_time" "float"))) 
 ("bare_key" (:*unnamed* nil)) 
 ("boolean" (:*unnamed* nil)) 
 ("comment" (:*unnamed* nil)) 
 ("document" (:*unnamed* ("pair" "table_array_element" "table"))) 
 ("dotted_key" (:*unnamed* ("dotted_key" "bare_key" "quoted_key"))) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("float" (:*unnamed* nil)) 
 ("inline_table" (:*unnamed* ("pair"))) 
 ("integer" (:*unnamed* nil)) 
 ("local_date" (:*unnamed* nil)) 
 ("local_date_time" (:*unnamed* nil)) 
 ("local_time" (:*unnamed* nil)) 
 ("offset_date_time" (:*unnamed* nil)) 
 ("pair" (:*unnamed* ("local_date" "array" "inline_table" "local_date_time" "bare_key" "boolean" "integer" "local_time" "string" "offset_date_time" "dotted_key" "quoted_key" "float"))) 
 ("quoted_key" (:*unnamed* ("escape_sequence"))) 
 ("string" (:*unnamed* ("escape_sequence"))) 
 ("table" (:*unnamed* ("pair" "dotted_key" "bare_key" "quoted_key"))) 
 ("table_array_element" (:*unnamed* ("pair" "dotted_key" "bare_key" "quoted_key"))) 
))
;; END Production rules for toml
;; START Inverse production rules for toml
(defconst combobulate-rules-toml-inverse 
 '(("array" ("pair" "array"))
   ("bare_key" ("pair" "dotted_key" "table" "table_array_element"))
   ("boolean" ("pair" "array"))
   ("dotted_key" ("pair" "dotted_key" "table" "table_array_element"))
   ("escape_sequence" ("string" "quoted_key"))
   ("float" ("pair" "array"))
   ("inline_table" ("pair" "array"))
   ("integer" ("pair" "array"))
   ("local_date" ("pair" "array"))
   ("local_date_time" ("pair" "array"))
   ("local_time" ("pair" "array"))
   ("offset_date_time" ("pair" "array"))
   ("pair" ("table_array_element" "inline_table" "table" "document"))
   ("quoted_key" ("pair" "dotted_key" "table" "table_array_element"))
   ("string" ("pair" "array"))
   ("table" ("document"))
   ("table_array_element" ("document"))
  ) 
)
;; END Inverse production rules for toml
;; START All node types in toml
(defconst combobulate-rules-toml-types 
 '("array" "bare_key" "boolean" "comment" "document" "dotted_key" "escape_sequence" "float" "inline_table" "integer" "local_date" "local_date_time" "local_time" "offset_date_time" "pair" "quoted_key" "string" "table" "table_array_element") 
)
;; END All node types in toml
;; START All supertypes in toml
(defconst combobulate-rules-toml-supertypes 
 nil 
)
;; END All supertypes in toml

;; START Production rules for json
(defconst combobulate-rules-json 
 '(("_value" (:*unnamed* ("object" "false" "array" "string" "null" "true" "number"))) 
 ("array" (:*unnamed* ("object" "false" "array" "string" "null" "true" "number"))) 
 ("comment" (:*unnamed* nil)) 
 ("document" (:*unnamed* ("object" "false" "array" "string" "null" "true" "number"))) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("false" (:*unnamed* nil)) 
 ("null" (:*unnamed* nil)) 
 ("number" (:*unnamed* nil)) 
 ("object" (:*unnamed* ("pair"))) 
 ("pair" (:*unnamed* nil :key ("string") :value ("object" "false" "array" "string" "null" "true" "number"))) 
 ("string" (:*unnamed* ("escape_sequence" "string_content"))) 
 ("string_content" (:*unnamed* nil)) 
 ("true" (:*unnamed* nil)) 
))
;; END Production rules for json
;; START Inverse production rules for json
(defconst combobulate-rules-json-inverse 
 '(("array" ("pair" "array" "_value" "document"))
   ("escape_sequence" ("string"))
   ("false" ("pair" "array" "_value" "document"))
   ("null" ("pair" "array" "_value" "document"))
   ("number" ("pair" "array" "_value" "document"))
   ("object" ("pair" "array" "_value" "document"))
   ("pair" ("object"))
   ("string" ("pair" "array" "_value" "document"))
   ("string_content" ("string"))
   ("true" ("pair" "array" "_value" "document"))
  ) 
)
;; END Inverse production rules for json
;; START All node types in json
(defconst combobulate-rules-json-types 
 '("_value" "array" "comment" "document" "escape_sequence" "false" "null" "number" "object" "pair" "string" "string_content" "true") 
)
;; END All node types in json
;; START All supertypes in json
(defconst combobulate-rules-json-supertypes 
 '("_value") 
)
;; END All supertypes in json

;; START Production rules for rust
(defconst combobulate-rules-rust 
 '(("_declaration_statement" (:*unnamed* ("attribute_item" "inner_attribute_item" "macro_definition" "mod_item" "foreign_mod_item" "struct_item" "static_item" "trait_item" "type_item" "let_declaration" "extern_crate_declaration" "enum_item" "union_item" "const_item" "associated_type" "macro_invocation" "empty_statement" "function_signature_item" "impl_item" "use_declaration" "function_item"))) 
 ("_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 (_literal (:*unnamed* ("integer_literal" "char_literal" "boolean_literal" "string_literal" "float_literal" "raw_string_literal"))) 
 ("_literal_pattern" (:*unnamed* ("integer_literal" "char_literal" "boolean_literal" "string_literal" "negative_literal" "float_literal" "raw_string_literal"))) 
 ("_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("_type" (:*unnamed* ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("abstract_type" (:*unnamed* ("type_parameters") :trait ("removed_trait_bound" "function_type" "generic_type" "type_identifier" "tuple_type" "scoped_type_identifier"))) 
 ("arguments" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "attribute_item" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("array_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "attribute_item" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block") :length ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("array_type" (:*unnamed* nil :element ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :length ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("assignment_expression" (:*unnamed* nil :left ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block") :right ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("associated_type" (:*unnamed* ("where_clause") :bounds ("trait_bounds") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("async_block" (:*unnamed* ("block"))) 
 ("attribute" (:*unnamed* ("scoped_identifier" "super" "metavariable" "crate" "identifier" "self") :arguments ("token_tree") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("attribute_item" (:*unnamed* ("attribute"))) 
 ("await_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("base_field_initializer" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("binary_expression" (:*unnamed* nil :left ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block") :operator nil :right ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("block" (:*unnamed* ("index_expression" "inner_attribute_item" "macro_definition" "mod_item" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "struct_item" "range_expression" "trait_item" "array_expression" "while_expression" "let_declaration" "async_block" "field_expression" "assignment_expression" "extern_crate_declaration" "enum_item" "yield_expression" "closure_expression" "const_item" "associated_type" "if_expression" "macro_invocation" "function_signature_item" "impl_item" "use_declaration" "call_expression" "break_expression" "function_item" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "attribute_item" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "label" "foreign_mod_item" "block" "static_item" "type_item" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "union_item" "identifier" "empty_statement" "metavariable" "expression_statement" "try_block"))) 
 ("block_comment" (:*unnamed* nil :doc ("doc_comment") :inner ("inner_doc_comment_marker") :outer ("outer_doc_comment_marker"))) 
 ("boolean_literal" (:*unnamed* nil)) 
 ("bounded_type" (:*unnamed* ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type" "lifetime"))) 
 ("bracketed_type" (:*unnamed* ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type" "qualified_type"))) 
 ("break_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "label" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("call_expression" (:*unnamed* nil :arguments ("arguments") :function ("char_literal" "string_literal" "index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "array_expression" "raw_string_literal" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "return_expression" "integer_literal" "parenthesized_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "unit_expression" "reference_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "boolean_literal" "identifier" "metavariable" "float_literal" "try_block"))) 
 ("captured_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("char_literal" (:*unnamed* nil)) 
 ("closure_expression" (:*unnamed* nil :body ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block") :parameters ("closure_parameters") :return_type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("closure_parameters" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "parameter" "float_literal" "range_pattern"))) 
 ("compound_assignment_expr" (:*unnamed* nil :left ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block") :operator nil :right ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("const_block" (:*unnamed* nil :body ("block"))) 
 ("const_item" (:*unnamed* ("visibility_modifier") :name ("identifier") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("const_parameter" (:*unnamed* nil :name ("identifier") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("constrained_type_parameter" (:*unnamed* nil :bounds ("trait_bounds") :left ("lifetime" "type_identifier"))) 
 ("continue_expression" (:*unnamed* ("label"))) 
 ("crate" (:*unnamed* nil)) 
 ("declaration_list" (:*unnamed* ("attribute_item" "inner_attribute_item" "macro_definition" "mod_item" "foreign_mod_item" "struct_item" "static_item" "trait_item" "type_item" "let_declaration" "extern_crate_declaration" "enum_item" "union_item" "const_item" "associated_type" "macro_invocation" "empty_statement" "function_signature_item" "impl_item" "use_declaration" "function_item"))) 
 ("doc_comment" (:*unnamed* nil)) 
 ("dynamic_type" (:*unnamed* nil :trait ("function_type" "type_identifier" "generic_type" "higher_ranked_trait_bound" "scoped_type_identifier"))) 
 ("else_clause" (:*unnamed* ("block" "if_expression"))) 
 ("empty_statement" (:*unnamed* nil)) 
 ("enum_item" (:*unnamed* ("where_clause" "visibility_modifier") :body ("enum_variant_list") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("enum_variant" (:*unnamed* ("visibility_modifier") :body ("field_declaration_list" "ordered_field_declaration_list") :name ("identifier") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("enum_variant_list" (:*unnamed* ("enum_variant" "attribute_item"))) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("expression_statement" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("extern_crate_declaration" (:*unnamed* ("crate" "visibility_modifier") :alias ("identifier") :name ("identifier"))) 
 ("extern_modifier" (:*unnamed* ("string_literal"))) 
 ("field_declaration" (:*unnamed* ("visibility_modifier") :name ("field_identifier") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("field_declaration_list" (:*unnamed* ("field_declaration" "attribute_item"))) 
 ("field_expression" (:*unnamed* nil :field ("integer_literal" "field_identifier") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("field_identifier" (:*unnamed* nil)) 
 ("field_initializer" (:*unnamed* ("attribute_item") :field ("integer_literal" "field_identifier") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("field_initializer_list" (:*unnamed* ("base_field_initializer" "field_initializer" "shorthand_field_initializer"))) 
 ("field_pattern" (:*unnamed* ("mutable_specifier") :name ("field_identifier" "shorthand_field_identifier") :pattern ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("float_literal" (:*unnamed* nil)) 
 ("for_expression" (:*unnamed* ("label") :body ("block") :pattern ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("for_lifetimes" (:*unnamed* ("lifetime"))) 
 ("foreign_mod_item" (:*unnamed* ("extern_modifier" "visibility_modifier") :body ("declaration_list"))) 
 ("fragment_specifier" (:*unnamed* nil)) 
 ("function_item" (:*unnamed* ("where_clause" "visibility_modifier" "function_modifiers") :body ("block") :name ("identifier" "metavariable") :parameters ("parameters") :return_type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :type_parameters ("type_parameters"))) 
 ("function_modifiers" (:*unnamed* ("extern_modifier"))) 
 ("function_signature_item" (:*unnamed* ("where_clause" "visibility_modifier" "function_modifiers") :name ("identifier" "metavariable") :parameters ("parameters") :return_type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :type_parameters ("type_parameters"))) 
 ("function_type" (:*unnamed* ("for_lifetimes" "function_modifiers") :parameters ("parameters") :return_type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :trait ("scoped_type_identifier" "type_identifier"))) 
 ("generic_function" (:*unnamed* nil :function ("field_expression" "scoped_identifier" "identifier") :type_arguments ("type_arguments"))) 
 ("generic_type" (:*unnamed* nil :type ("scoped_identifier" "identifier" "scoped_type_identifier" "type_identifier") :type_arguments ("type_arguments"))) 
 ("generic_type_with_turbofish" (:*unnamed* nil :type ("scoped_identifier" "type_identifier") :type_arguments ("type_arguments"))) 
 ("higher_ranked_trait_bound" (:*unnamed* nil :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :type_parameters ("type_parameters"))) 
 ("identifier" (:*unnamed* nil)) 
 ("if_expression" (:*unnamed* nil :alternative ("else_clause") :condition ("let_chain" "index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block") :consequence ("block"))) 
 ("impl_item" (:*unnamed* ("where_clause") :body ("declaration_list") :trait ("type_identifier" "scoped_type_identifier" "generic_type") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :type_parameters ("type_parameters"))) 
 ("index_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("inner_attribute_item" (:*unnamed* ("attribute"))) 
 ("inner_doc_comment_marker" (:*unnamed* nil)) 
 ("integer_literal" (:*unnamed* nil)) 
 ("label" (:*unnamed* ("identifier"))) 
 ("let_chain" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("let_condition" (:*unnamed* nil :pattern ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("let_declaration" (:*unnamed* ("mutable_specifier") :alternative ("block") :pattern ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("lifetime" (:*unnamed* ("identifier"))) 
 ("line_comment" (:*unnamed* nil :doc ("doc_comment") :inner ("inner_doc_comment_marker") :outer ("outer_doc_comment_marker"))) 
 ("loop_expression" (:*unnamed* ("label") :body ("block"))) 
 ("macro_definition" (:*unnamed* ("macro_rule") :name ("identifier"))) 
 ("macro_invocation" (:*unnamed* ("token_tree") :macro ("scoped_identifier" "identifier"))) 
 ("macro_rule" (:*unnamed* nil :left ("token_tree_pattern") :right ("token_tree"))) 
 ("match_arm" (:*unnamed* ("inner_attribute_item" "attribute_item") :pattern ("match_pattern") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("match_block" (:*unnamed* ("match_arm"))) 
 ("match_expression" (:*unnamed* nil :body ("match_block") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("match_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern") :condition ("let_chain" "index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("metavariable" (:*unnamed* nil)) 
 ("mod_item" (:*unnamed* ("visibility_modifier") :body ("declaration_list") :name ("identifier"))) 
 ("mut_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "mutable_specifier" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("mutable_specifier" (:*unnamed* nil)) 
 ("negative_literal" (:*unnamed* ("integer_literal" "float_literal"))) 
 ("never_type" (:*unnamed* nil)) 
 ("optional_type_parameter" (:*unnamed* nil :default_type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :name ("constrained_type_parameter" "type_identifier"))) 
 ("or_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("ordered_field_declaration_list" (:*unnamed* ("visibility_modifier" "attribute_item") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("outer_doc_comment_marker" (:*unnamed* nil)) 
 ("parameter" (:*unnamed* ("mutable_specifier") :pattern ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "self" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("parameters" (:*unnamed* ("attribute_item" "self_parameter" "scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type" "variadic_parameter" "parameter"))) 
 ("parenthesized_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("pointer_type" (:*unnamed* ("mutable_specifier") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("primitive_type" (:*unnamed* nil)) 
 ("qualified_type" (:*unnamed* nil :alias ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("range_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("range_pattern" (:*unnamed* ("integer_literal" "char_literal" "scoped_identifier" "string_literal" "super" "boolean_literal" "crate" "identifier" "self" "metavariable" "negative_literal" "float_literal" "raw_string_literal"))) 
 ("raw_string_literal" (:*unnamed* ("string_content"))) 
 ("ref_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("reference_expression" (:*unnamed* ("mutable_specifier") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("reference_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "mutable_specifier" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("reference_type" (:*unnamed* ("lifetime" "mutable_specifier") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("remaining_field_pattern" (:*unnamed* nil)) 
 ("removed_trait_bound" (:*unnamed* ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("return_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("scoped_identifier" (:*unnamed* nil :name ("identifier" "super") :path ("scoped_identifier" "super" "crate" "identifier" "self" "generic_type" "metavariable" "bracketed_type"))) 
 ("scoped_type_identifier" (:*unnamed* nil :name ("type_identifier") :path ("scoped_identifier" "super" "crate" "identifier" "self" "generic_type" "metavariable" "bracketed_type"))) 
 ("scoped_use_list" (:*unnamed* nil :list ("use_list") :path ("scoped_identifier" "super" "metavariable" "crate" "identifier" "self"))) 
 ("self" (:*unnamed* nil)) 
 ("self_parameter" (:*unnamed* ("lifetime" "self" "mutable_specifier"))) 
 ("shebang" (:*unnamed* nil)) 
 ("shorthand_field_identifier" (:*unnamed* nil)) 
 ("shorthand_field_initializer" (:*unnamed* ("identifier" "attribute_item"))) 
 ("slice_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("source_file" (:*unnamed* ("attribute_item" "inner_attribute_item" "macro_definition" "mod_item" "shebang" "foreign_mod_item" "struct_item" "static_item" "trait_item" "type_item" "let_declaration" "extern_crate_declaration" "enum_item" "union_item" "const_item" "associated_type" "macro_invocation" "empty_statement" "function_signature_item" "impl_item" "use_declaration" "expression_statement" "function_item"))) 
 ("static_item" (:*unnamed* ("mutable_specifier" "visibility_modifier") :name ("identifier") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("string_content" (:*unnamed* nil)) 
 ("string_literal" (:*unnamed* ("escape_sequence" "string_content"))) 
 ("struct_expression" (:*unnamed* nil :body ("field_initializer_list") :name ("generic_type_with_turbofish" "scoped_type_identifier" "type_identifier"))) 
 ("struct_item" (:*unnamed* ("where_clause" "visibility_modifier") :body ("field_declaration_list" "ordered_field_declaration_list") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("struct_pattern" (:*unnamed* ("remaining_field_pattern" "field_pattern") :type ("scoped_type_identifier" "type_identifier"))) 
 ("super" (:*unnamed* nil)) 
 ("token_binding_pattern" (:*unnamed* nil :name ("metavariable") :type ("fragment_specifier"))) 
 ("token_repetition" (:*unnamed* ("integer_literal" "char_literal" "primitive_type" "string_literal" "super" "boolean_literal" "mutable_specifier" "crate" "identifier" "self" "token_repetition" "token_tree" "metavariable" "float_literal" "raw_string_literal"))) 
 ("token_repetition_pattern" (:*unnamed* ("integer_literal" "char_literal" "string_literal" "self" "token_tree_pattern" "token_repetition_pattern" "raw_string_literal" "primitive_type" "super" "boolean_literal" "mutable_specifier" "crate" "identifier" "token_binding_pattern" "metavariable" "float_literal"))) 
 ("token_tree" (:*unnamed* ("integer_literal" "char_literal" "primitive_type" "string_literal" "super" "boolean_literal" "mutable_specifier" "crate" "identifier" "self" "token_repetition" "token_tree" "metavariable" "float_literal" "raw_string_literal"))) 
 ("token_tree_pattern" (:*unnamed* ("integer_literal" "char_literal" "string_literal" "self" "token_tree_pattern" "token_repetition_pattern" "raw_string_literal" "primitive_type" "super" "boolean_literal" "mutable_specifier" "crate" "identifier" "token_binding_pattern" "metavariable" "float_literal"))) 
 ("trait_bounds" (:*unnamed* ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "higher_ranked_trait_bound" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type" "lifetime"))) 
 ("trait_item" (:*unnamed* ("where_clause" "visibility_modifier") :body ("declaration_list") :bounds ("trait_bounds") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("try_block" (:*unnamed* ("block"))) 
 ("try_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("tuple_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "attribute_item" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("tuple_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "closure_expression" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("tuple_struct_pattern" (:*unnamed* ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern") :type ("scoped_identifier" "identifier" "generic_type"))) 
 ("tuple_type" (:*unnamed* ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type"))) 
 ("type_arguments" (:*unnamed* ("integer_literal" "char_literal" "string_literal" "type_binding" "scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "block" "tuple_type" "dynamic_type" "raw_string_literal" "never_type" "primitive_type" "boolean_literal" "function_type" "abstract_type" "trait_bounds" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type" "lifetime" "float_literal"))) 
 ("type_binding" (:*unnamed* nil :name ("type_identifier") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :type_arguments ("type_arguments"))) 
 ("type_cast_expression" (:*unnamed* nil :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :value ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("type_identifier" (:*unnamed* nil)) 
 ("type_item" (:*unnamed* ("where_clause" "visibility_modifier") :name ("type_identifier") :type ("scoped_type_identifier" "bounded_type" "generic_type" "removed_trait_bound" "tuple_type" "dynamic_type" "never_type" "primitive_type" "function_type" "abstract_type" "array_type" "macro_invocation" "type_identifier" "pointer_type" "metavariable" "unit_type" "reference_type") :type_parameters ("type_parameters"))) 
 ("type_parameters" (:*unnamed* ("constrained_type_parameter" "const_parameter" "type_identifier" "attribute_item" "metavariable" "lifetime" "optional_type_parameter"))) 
 ("unary_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("union_item" (:*unnamed* ("where_clause" "visibility_modifier") :body ("field_declaration_list") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("unit_expression" (:*unnamed* nil)) 
 ("unit_type" (:*unnamed* nil)) 
 ("unsafe_block" (:*unnamed* ("block"))) 
 ("use_as_clause" (:*unnamed* nil :alias ("identifier") :path ("scoped_identifier" "super" "metavariable" "crate" "identifier" "self"))) 
 ("use_declaration" (:*unnamed* ("visibility_modifier") :argument ("scoped_identifier" "use_list" "super" "use_wildcard" "crate" "identifier" "self" "scoped_use_list" "metavariable" "use_as_clause"))) 
 ("use_list" (:*unnamed* ("scoped_identifier" "use_list" "super" "use_wildcard" "crate" "identifier" "self" "scoped_use_list" "metavariable" "use_as_clause"))) 
 ("use_wildcard" (:*unnamed* ("scoped_identifier" "super" "metavariable" "crate" "identifier" "self"))) 
 ("variadic_parameter" (:*unnamed* ("mutable_specifier") :pattern ("integer_literal" "char_literal" "mut_pattern" "string_literal" "or_pattern" "tuple_pattern" "ref_pattern" "tuple_struct_pattern" "const_block" "reference_pattern" "captured_pattern" "negative_literal" "remaining_field_pattern" "raw_string_literal" "scoped_identifier" "boolean_literal" "struct_pattern" "slice_pattern" "identifier" "macro_invocation" "float_literal" "range_pattern"))) 
 ("visibility_modifier" (:*unnamed* ("scoped_identifier" "super" "metavariable" "crate" "identifier" "self"))) 
 ("where_clause" (:*unnamed* ("where_predicate"))) 
 ("where_predicate" (:*unnamed* nil :bounds ("trait_bounds") :left ("primitive_type" "tuple_type" "scoped_type_identifier" "array_type" "generic_type" "pointer_type" "type_identifier" "higher_ranked_trait_bound" "reference_type" "lifetime"))) 
 ("while_expression" (:*unnamed* ("label") :body ("block") :condition ("let_chain" "index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
 ("yield_expression" (:*unnamed* ("index_expression" "continue_expression" "type_cast_expression" "match_expression" "const_block" "try_expression" "range_expression" "array_expression" "while_expression" "async_block" "field_expression" "assignment_expression" "yield_expression" "closure_expression" "if_expression" "macro_invocation" "call_expression" "break_expression" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "for_expression" "unsafe_block" "binary_expression" "self" "tuple_expression" "compound_assignment_expr" "reference_expression" "unit_expression" "block" "loop_expression" "struct_expression" "scoped_identifier" "unary_expression" "identifier" "metavariable" "try_block"))) 
))
;; END Production rules for rust
;; START Inverse production rules for rust
(defconst combobulate-rules-rust-inverse 
 '(("abstract_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "pointer_type" "reference_type" "parameter"))
   ("arguments" ("call_expression"))
   ("array_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("array_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "where_predicate" "pointer_type" "reference_type" "parameter"))
   ("assignment_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("associated_type" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("async_block" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("attribute" ("inner_attribute_item" "attribute_item"))
   ("attribute_item" ("match_arm" "enum_variant_list" "field_initializer" "tuple_expression" "shorthand_field_initializer" "declaration_list" "field_declaration_list" "block" "ordered_field_declaration_list" "type_parameters" "source_file" "parameters" "array_expression" "_declaration_statement" "arguments"))
   ("await_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("base_field_initializer" ("field_initializer_list"))
   ("binary_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("block" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "const_block" "try_expression" "_expression" "range_expression" "type_arguments" "attribute" "array_expression" "while_expression" "async_block" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "else_clause" "call_expression" "break_expression" "arguments" "function_item" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "unsafe_block" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "loop_expression" "unary_expression" "base_field_initializer" "expression_statement" "try_block"))
   ("boolean_literal" ("mut_pattern" "match_pattern" "tuple_struct_pattern" "closure_parameters" "captured_pattern" "token_repetition_pattern" "type_arguments" "let_declaration" "_pattern" "slice_pattern" "variadic_parameter" "call_expression" "tuple_pattern" "or_pattern" "let_condition" "field_pattern" "for_expression" "ref_pattern" "token_repetition" "reference_pattern" "token_tree_pattern" "_literal_pattern" "token_tree" _literal "parameter" "range_pattern"))
   ("bounded_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "pointer_type" "reference_type" "parameter"))
   ("bracketed_type" ("scoped_identifier" "scoped_type_identifier"))
   ("break_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("call_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("captured_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("char_literal" ("mut_pattern" "match_pattern" "tuple_struct_pattern" "closure_parameters" "captured_pattern" "token_repetition_pattern" "type_arguments" "let_declaration" "_pattern" "slice_pattern" "variadic_parameter" "call_expression" "tuple_pattern" "or_pattern" "let_condition" "field_pattern" "for_expression" "ref_pattern" "token_repetition" "reference_pattern" "token_tree_pattern" "_literal_pattern" "token_tree" _literal "parameter" "range_pattern"))
   ("closure_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "tuple_pattern" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("closure_parameters" ("closure_expression"))
   ("compound_assignment_expr" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("const_block" ("let_chain" "mut_pattern" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "tuple_struct_pattern" "try_expression" "closure_parameters" "_expression" "captured_pattern" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "_pattern" "assignment_expression" "slice_pattern" "closure_expression" "yield_expression" "const_item" "array_type" "if_expression" "enum_variant" "variadic_parameter" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "or_pattern" "await_expression" "let_condition" "field_pattern" "for_expression" "tuple_pattern" "ref_pattern" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "reference_pattern" "static_item" "unary_expression" "base_field_initializer" "parameter" "expression_statement"))
   ("const_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("const_parameter" ("type_parameters"))
   ("constrained_type_parameter" ("type_parameters" "optional_type_parameter"))
   ("continue_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("crate" ("scoped_identifier" "use_list" "visibility_modifier" "extern_crate_declaration" "use_wildcard" "scoped_type_identifier" "scoped_use_list" "token_repetition" "token_tree" "use_declaration" "token_tree_pattern" "token_repetition_pattern" "attribute" "use_as_clause" "range_pattern"))
   ("declaration_list" ("trait_item" "mod_item" "foreign_mod_item" "impl_item"))
   ("doc_comment" ("block_comment" "line_comment"))
   ("dynamic_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "pointer_type" "reference_type" "parameter"))
   ("else_clause" ("if_expression"))
   ("empty_statement" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("enum_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("enum_variant" ("enum_variant_list"))
   ("enum_variant_list" ("enum_item"))
   ("escape_sequence" ("string_literal"))
   ("expression_statement" ("source_file" "block"))
   ("extern_crate_declaration" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("extern_modifier" ("foreign_mod_item" "function_modifiers"))
   ("field_declaration" ("field_declaration_list"))
   ("field_declaration_list" ("enum_variant" "union_item" "struct_item"))
   ("field_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "generic_function" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("field_identifier" ("field_expression" "field_initializer" "field_declaration" "field_pattern"))
   ("field_initializer" ("field_initializer_list"))
   ("field_initializer_list" ("struct_expression"))
   ("field_pattern" ("struct_pattern"))
   ("float_literal" ("mut_pattern" "match_pattern" "tuple_struct_pattern" "closure_parameters" "captured_pattern" "token_repetition_pattern" "type_arguments" "let_declaration" "_pattern" "slice_pattern" "variadic_parameter" "call_expression" "tuple_pattern" "or_pattern" "let_condition" "field_pattern" "for_expression" "ref_pattern" "token_repetition" "reference_pattern" "token_tree_pattern" "negative_literal" "_literal_pattern" "token_tree" _literal "parameter" "range_pattern"))
   ("for_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("for_lifetimes" ("function_type"))
   ("foreign_mod_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("fragment_specifier" ("token_binding_pattern"))
   ("function_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("function_modifiers" ("function_type" "function_signature_item" "function_item"))
   ("function_signature_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("function_type" ("type_binding" "type_cast_expression" "bounded_type" "dynamic_type" "type_arguments" "let_declaration" "abstract_type" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "pointer_type" "reference_type" "parameter"))
   ("generic_function" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("generic_type" ("type_binding" "scoped_type_identifier" "type_cast_expression" "tuple_struct_pattern" "bounded_type" "dynamic_type" "type_arguments" "let_declaration" "abstract_type" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "scoped_identifier" "function_type" "trait_bounds" "where_predicate" "pointer_type" "reference_type" "parameter"))
   ("generic_type_with_turbofish" ("struct_expression"))
   ("higher_ranked_trait_bound" ("where_predicate" "dynamic_type" "trait_bounds"))
   ("identifier" ("mut_pattern" "match_arm" "try_expression" "closure_parameters" "_expression" "captured_pattern" "use_list" "macro_invocation" "break_expression" "use_as_clause" "tuple_pattern" "field_pattern" "token_repetition" "compound_assignment_expr" "block" "token_tree_pattern" "unary_expression" "let_chain" "use_wildcard" "macro_definition" "type_cast_expression" "tuple_struct_pattern" "token_repetition_pattern" "while_expression" "slice_pattern" "array_type" "function_signature_item" "return_expression" "arguments" "parenthesized_expression" "field_initializer" "binary_expression" "reference_expression" "static_item" "scoped_identifier" "scoped_use_list" "expression_statement" "range_pattern" "index_expression" "match_pattern" "scoped_type_identifier" "range_expression" "field_expression" "let_declaration" "_pattern" "assignment_expression" "extern_crate_declaration" "yield_expression" "const_item" "use_declaration" "enum_variant" "call_expression" "generic_function" "await_expression" "tuple_expression" "reference_pattern" "base_field_initializer" "visibility_modifier" "mod_item" "match_expression" "attribute" "array_expression" "closure_expression" "if_expression" "const_parameter" "variadic_parameter" "lifetime" "shorthand_field_initializer" "function_item" "or_pattern" "let_condition" "for_expression" "ref_pattern" "label" "generic_type" "token_tree" "parameter"))
   ("if_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "else_clause" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("impl_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("index_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("inner_attribute_item" ("match_arm" "declaration_list" "block" "source_file" "_declaration_statement"))
   ("inner_doc_comment_marker" ("block_comment" "line_comment"))
   ("integer_literal" ("mut_pattern" "match_pattern" "tuple_struct_pattern" "closure_parameters" "captured_pattern" "token_repetition_pattern" "type_arguments" "field_expression" "let_declaration" "_pattern" "slice_pattern" "variadic_parameter" "call_expression" "tuple_pattern" "or_pattern" "let_condition" "field_pattern" "for_expression" "ref_pattern" "field_initializer" "token_repetition" "reference_pattern" "token_tree_pattern" "negative_literal" "_literal_pattern" "token_tree" _literal "parameter" "range_pattern"))
   ("label" ("loop_expression" "for_expression" "continue_expression" "block" "break_expression" "while_expression"))
   ("let_chain" ("while_expression" "match_pattern" "if_expression"))
   ("let_condition" ("let_chain" "while_expression" "match_pattern" "if_expression"))
   ("let_declaration" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("lifetime" ("constrained_type_parameter" "trait_bounds" "where_predicate" "for_lifetimes" "type_parameters" "bounded_type" "reference_type" "type_arguments" "self_parameter"))
   ("loop_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("macro_definition" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("macro_invocation" ("mut_pattern" "match_arm" "try_expression" "closure_parameters" "_expression" "captured_pattern" "ordered_field_declaration_list" "break_expression" "bracketed_type" "qualified_type" "tuple_pattern" "field_pattern" "compound_assignment_expr" "block" "tuple_type" "unary_expression" "trait_bounds" "pointer_type" "let_chain" "type_binding" "type_cast_expression" "tuple_struct_pattern" "type_arguments" "while_expression" "slice_pattern" "array_type" "declaration_list" "function_signature_item" "return_expression" "_declaration_statement" "arguments" "parenthesized_expression" "field_initializer" "binary_expression" "reference_expression" "removed_trait_bound" "static_item" "function_type" "reference_type" "expression_statement" "index_expression" "match_pattern" "range_expression" "field_expression" "let_declaration" "_pattern" "assignment_expression" "yield_expression" "const_item" "enum_variant" "parameters" "call_expression" "await_expression" "optional_type_parameter" "_type" "field_declaration" "tuple_expression" "higher_ranked_trait_bound" "reference_pattern" "base_field_initializer" "match_expression" "bounded_type" "attribute" "array_expression" "closure_expression" "if_expression" "const_parameter" "impl_item" "variadic_parameter" "function_item" "or_pattern" "let_condition" "for_expression" "ref_pattern" "source_file" "type_item" "parameter"))
   ("macro_rule" ("macro_definition"))
   ("match_arm" ("match_block"))
   ("match_block" ("match_expression"))
   ("match_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("match_pattern" ("match_arm"))
   ("metavariable" ("match_arm" "try_expression" "_expression" "use_list" "token_binding_pattern" "ordered_field_declaration_list" "break_expression" "bracketed_type" "qualified_type" "use_as_clause" "token_repetition" "compound_assignment_expr" "block" "tuple_type" "token_tree_pattern" "unary_expression" "trait_bounds" "pointer_type" "let_chain" "type_binding" "use_wildcard" "type_cast_expression" "token_repetition_pattern" "type_arguments" "while_expression" "array_type" "function_signature_item" "return_expression" "arguments" "parenthesized_expression" "field_initializer" "binary_expression" "reference_expression" "removed_trait_bound" "static_item" "scoped_identifier" "function_type" "scoped_use_list" "reference_type" "expression_statement" "range_pattern" "index_expression" "match_pattern" "scoped_type_identifier" "range_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "const_item" "use_declaration" "enum_variant" "parameters" "call_expression" "await_expression" "optional_type_parameter" "_type" "field_declaration" "tuple_expression" "higher_ranked_trait_bound" "base_field_initializer" "visibility_modifier" "type_parameters" "match_expression" "bounded_type" "attribute" "array_expression" "closure_expression" "if_expression" "const_parameter" "impl_item" "function_item" "let_condition" "for_expression" "type_item" "token_tree" "parameter"))
   ("mod_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("mut_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("mutable_specifier" ("let_declaration" "mut_pattern" "field_pattern" "self_parameter" "static_item" "token_repetition" "reference_expression" "token_tree" "pointer_type" "variadic_parameter" "reference_pattern" "reference_type" "token_repetition_pattern" "parameter" "token_tree_pattern"))
   ("negative_literal" ("mut_pattern" "match_pattern" "tuple_struct_pattern" "closure_parameters" "captured_pattern" "let_declaration" "_pattern" "slice_pattern" "variadic_parameter" "tuple_pattern" "or_pattern" "let_condition" "field_pattern" "for_expression" "ref_pattern" "reference_pattern" "_literal_pattern" "parameter" "range_pattern"))
   ("never_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "pointer_type" "reference_type" "parameter"))
   ("optional_type_parameter" ("type_parameters"))
   ("or_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("ordered_field_declaration_list" ("enum_variant" "struct_item"))
   ("outer_doc_comment_marker" ("block_comment" "line_comment"))
   ("parameter" ("parameters" "closure_parameters"))
   ("parameters" ("function_type" "function_signature_item" "function_item"))
   ("parenthesized_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("pointer_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "where_predicate" "pointer_type" "reference_type" "parameter"))
   ("primitive_type" ("type_binding" "type_cast_expression" "bounded_type" "token_repetition_pattern" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "token_repetition" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "token_tree_pattern" "tuple_type" "type_item" "function_type" "trait_bounds" "where_predicate" "token_tree" "pointer_type" "reference_type" "parameter"))
   ("qualified_type" ("bracketed_type"))
   ("range_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "return_expression" "break_expression" "arguments" "parenthesized_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("range_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("raw_string_literal" ("mut_pattern" "match_pattern" "tuple_struct_pattern" "closure_parameters" "captured_pattern" "token_repetition_pattern" "type_arguments" "let_declaration" "_pattern" "slice_pattern" "variadic_parameter" "call_expression" "tuple_pattern" "or_pattern" "let_condition" "field_pattern" "for_expression" "ref_pattern" "token_repetition" "reference_pattern" "token_tree_pattern" "_literal_pattern" "token_tree" _literal "parameter" "range_pattern"))
   ("ref_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("reference_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("reference_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("reference_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "where_predicate" "pointer_type" "reference_type" "parameter"))
   ("remaining_field_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "struct_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("removed_trait_bound" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "abstract_type" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "pointer_type" "reference_type" "parameter"))
   ("return_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("scoped_identifier" ("let_chain" "mut_pattern" "index_expression" "match_arm" "match_pattern" "use_wildcard" "scoped_type_identifier" "type_cast_expression" "match_expression" "tuple_struct_pattern" "try_expression" "return_expression" "closure_parameters" "_expression" "captured_pattern" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "use_list" "_pattern" "assignment_expression" "slice_pattern" "closure_expression" "yield_expression" "const_item" "array_type" "if_expression" "macro_invocation" "use_declaration" "enum_variant" "variadic_parameter" "call_expression" "break_expression" "arguments" "generic_function" "parenthesized_expression" "or_pattern" "await_expression" "let_condition" "field_pattern" "for_expression" "tuple_pattern" "use_as_clause" "ref_pattern" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "generic_type" "reference_pattern" "static_item" "scoped_identifier" "unary_expression" "base_field_initializer" "visibility_modifier" "scoped_use_list" "generic_type_with_turbofish" "parameter" "expression_statement" "range_pattern"))
   ("scoped_type_identifier" ("type_binding" "type_cast_expression" "bounded_type" "dynamic_type" "type_arguments" "let_declaration" "abstract_type" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "generic_type" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "struct_expression" "struct_pattern" "function_type" "trait_bounds" "where_predicate" "pointer_type" "reference_type" "parameter"))
   ("scoped_use_list" ("use_list" "use_declaration"))
   ("self" ("let_chain" "index_expression" "match_arm" "match_pattern" "use_wildcard" "scoped_type_identifier" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "token_repetition_pattern" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "use_list" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "use_declaration" "enum_variant" "self_parameter" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "use_as_clause" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "token_repetition" "compound_assignment_expr" "reference_expression" "block" "static_item" "token_tree_pattern" "scoped_identifier" "unary_expression" "base_field_initializer" "visibility_modifier" "scoped_use_list" "token_tree" "parameter" "expression_statement" "range_pattern"))
   ("self_parameter" ("parameters"))
   ("shebang" ("source_file"))
   ("shorthand_field_identifier" ("field_pattern"))
   ("shorthand_field_initializer" ("field_initializer_list"))
   ("slice_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("static_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("string_content" ("string_literal" "raw_string_literal"))
   ("string_literal" ("mut_pattern" "match_pattern" "extern_modifier" "tuple_struct_pattern" "closure_parameters" "captured_pattern" "token_repetition_pattern" "type_arguments" "let_declaration" "_pattern" "slice_pattern" "variadic_parameter" "call_expression" "tuple_pattern" "or_pattern" "let_condition" "field_pattern" "for_expression" "ref_pattern" "token_repetition" "reference_pattern" "token_tree_pattern" "_literal_pattern" "token_tree" _literal "parameter" "range_pattern"))
   ("struct_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("struct_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("struct_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("super" ("scoped_identifier" "use_list" "visibility_modifier" "use_wildcard" "scoped_type_identifier" "scoped_use_list" "token_repetition" "token_tree" "use_declaration" "token_tree_pattern" "token_repetition_pattern" "attribute" "use_as_clause" "range_pattern"))
   ("token_binding_pattern" ("token_tree_pattern" "token_repetition_pattern"))
   ("token_repetition" ("token_tree" "token_repetition"))
   ("token_repetition_pattern" ("token_tree_pattern" "token_repetition_pattern"))
   ("token_tree" ("token_repetition" "macro_rule" "macro_invocation" "token_tree" "attribute"))
   ("token_tree_pattern" ("token_tree_pattern" "token_repetition_pattern" "macro_rule"))
   ("trait_bounds" ("constrained_type_parameter" "where_predicate" "associated_type" "trait_item" "type_arguments"))
   ("trait_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("try_block" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("try_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("tuple_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("tuple_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("tuple_struct_pattern" ("let_declaration" "mut_pattern" "let_condition" "or_pattern" "_pattern" "for_expression" "field_pattern" "match_pattern" "ref_pattern" "slice_pattern" "tuple_struct_pattern" "tuple_pattern" "closure_parameters" "variadic_parameter" "reference_pattern" "captured_pattern" "parameter"))
   ("tuple_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "abstract_type" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "where_predicate" "pointer_type" "reference_type" "parameter"))
   ("type_arguments" ("generic_type_with_turbofish" "type_binding" "generic_type" "generic_function"))
   ("type_binding" ("type_arguments"))
   ("type_cast_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("type_identifier" ("type_binding" "scoped_type_identifier" "type_cast_expression" "bounded_type" "struct_item" "trait_item" "dynamic_type" "type_arguments" "constrained_type_parameter" "let_declaration" "abstract_type" "enum_item" "closure_expression" "const_item" "array_type" "associated_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "generic_type" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "struct_expression" "struct_pattern" "function_type" "trait_bounds" "union_item" "where_predicate" "generic_type_with_turbofish" "type_parameters" "pointer_type" "reference_type" "parameter"))
   ("type_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("type_parameters" ("struct_item" "abstract_type" "enum_item" "union_item" "associated_type" "function_signature_item" "impl_item" "higher_ranked_trait_bound" "trait_item" "type_item" "function_item"))
   ("unary_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("union_item" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("unit_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("unit_type" ("type_binding" "type_cast_expression" "bounded_type" "type_arguments" "let_declaration" "closure_expression" "const_item" "array_type" "const_parameter" "function_signature_item" "impl_item" "ordered_field_declaration_list" "parameters" "qualified_type" "function_item" "bracketed_type" "optional_type_parameter" "_type" "field_declaration" "removed_trait_bound" "higher_ranked_trait_bound" "static_item" "tuple_type" "type_item" "function_type" "trait_bounds" "pointer_type" "reference_type" "parameter"))
   ("unsafe_block" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("use_as_clause" ("use_list" "use_declaration"))
   ("use_declaration" ("source_file" "declaration_list" "block" "_declaration_statement"))
   ("use_list" ("use_list" "use_declaration" "scoped_use_list"))
   ("use_wildcard" ("use_list" "use_declaration"))
   ("variadic_parameter" ("parameters"))
   ("visibility_modifier" ("struct_item" "extern_crate_declaration" "enum_item" "union_item" "mod_item" "static_item" "const_item" "field_declaration" "foreign_mod_item" "enum_variant" "function_signature_item" "ordered_field_declaration_list" "use_declaration" "trait_item" "type_item" "function_item"))
   ("where_clause" ("enum_item" "union_item" "associated_type" "function_signature_item" "impl_item" "struct_item" "trait_item" "type_item" "function_item"))
   ("where_predicate" ("where_clause"))
   ("while_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
   ("yield_expression" ("let_chain" "index_expression" "match_arm" "match_pattern" "type_cast_expression" "match_expression" "try_expression" "_expression" "range_expression" "attribute" "array_expression" "while_expression" "field_expression" "let_declaration" "assignment_expression" "yield_expression" "closure_expression" "const_item" "array_type" "if_expression" "enum_variant" "call_expression" "break_expression" "arguments" "parenthesized_expression" "return_expression" "await_expression" "let_condition" "for_expression" "field_initializer" "binary_expression" "tuple_expression" "compound_assignment_expr" "reference_expression" "block" "static_item" "unary_expression" "base_field_initializer" "expression_statement"))
  ) 
)
;; END Inverse production rules for rust
;; START All node types in rust
(defconst combobulate-rules-rust-types 
 '("_declaration_statement" "_expression" _literal "_literal_pattern" "_pattern" "_type" "abstract_type" "arguments" "array_expression" "array_type" "assignment_expression" "associated_type" "async_block" "attribute" "attribute_item" "await_expression" "base_field_initializer" "binary_expression" "block" "block_comment" "boolean_literal" "bounded_type" "bracketed_type" "break_expression" "call_expression" "captured_pattern" "char_literal" "closure_expression" "closure_parameters" "compound_assignment_expr" "const_block" "const_item" "const_parameter" "constrained_type_parameter" "continue_expression" "crate" "declaration_list" "doc_comment" "dynamic_type" "else_clause" "empty_statement" "enum_item" "enum_variant" "enum_variant_list" "escape_sequence" "expression_statement" "extern_crate_declaration" "extern_modifier" "field_declaration" "field_declaration_list" "field_expression" "field_identifier" "field_initializer" "field_initializer_list" "field_pattern" "float_literal" "for_expression" "for_lifetimes" "foreign_mod_item" "fragment_specifier" "function_item" "function_modifiers" "function_signature_item" "function_type" "generic_function" "generic_type" "generic_type_with_turbofish" "higher_ranked_trait_bound" "identifier" "if_expression" "impl_item" "index_expression" "inner_attribute_item" "inner_doc_comment_marker" "integer_literal" "label" "let_chain" "let_condition" "let_declaration" "lifetime" "line_comment" "loop_expression" "macro_definition" "macro_invocation" "macro_rule" "match_arm" "match_block" "match_expression" "match_pattern" "metavariable" "mod_item" "mut_pattern" "mutable_specifier" "negative_literal" "never_type" "optional_type_parameter" "or_pattern" "ordered_field_declaration_list" "outer_doc_comment_marker" "parameter" "parameters" "parenthesized_expression" "pointer_type" "primitive_type" "qualified_type" "range_expression" "range_pattern" "raw_string_literal" "ref_pattern" "reference_expression" "reference_pattern" "reference_type" "remaining_field_pattern" "removed_trait_bound" "return_expression" "scoped_identifier" "scoped_type_identifier" "scoped_use_list" "self" "self_parameter" "shebang" "shorthand_field_identifier" "shorthand_field_initializer" "slice_pattern" "source_file" "static_item" "string_content" "string_literal" "struct_expression" "struct_item" "struct_pattern" "super" "token_binding_pattern" "token_repetition" "token_repetition_pattern" "token_tree" "token_tree_pattern" "trait_bounds" "trait_item" "try_block" "try_expression" "tuple_expression" "tuple_pattern" "tuple_struct_pattern" "tuple_type" "type_arguments" "type_binding" "type_cast_expression" "type_identifier" "type_item" "type_parameters" "unary_expression" "union_item" "unit_expression" "unit_type" "unsafe_block" "use_as_clause" "use_declaration" "use_list" "use_wildcard" "variadic_parameter" "visibility_modifier" "where_clause" "where_predicate" "while_expression" "yield_expression") 
)
;; END All node types in rust
;; START All supertypes in rust
(defconst combobulate-rules-rust-supertypes 
 '("_declaration_statement" "_expression" "_literal" "_literal_pattern" "_pattern" "_type") 
)
;; END All supertypes in rust

;; START Production rules for cpp
(defconst combobulate-rules-cpp 
 '(("_abstract_declarator" (:*unnamed* ("abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "abstract_array_declarator" "abstract_pointer_declarator"))) 
 ("_declarator" (:*unnamed* ("pointer_declarator" "destructor_name" "operator_name" "identifier" "template_function" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "qualified_identifier" "function_declarator"))) 
 ("_expression" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("_field_declarator" (:*unnamed* ("template_method" "pointer_declarator" "operator_name" "field_identifier" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "function_declarator"))) 
 ("_statement" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("_type_declarator" (:*unnamed* ("primitive_type" "pointer_declarator" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_identifier" "function_declarator"))) 
 ("_type_specifier" (:*unnamed* ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("abstract_array_declarator" (:*unnamed* ("type_qualifier") :declarator ("abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "abstract_array_declarator" "abstract_pointer_declarator") :size ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("abstract_function_declarator" (:*unnamed* ("throw_specifier" "trailing_return_type" "type_qualifier" "ref_qualifier" "attribute_declaration" "attribute_specifier" "gnu_asm_expression" "requires_clause" "noexcept" "virtual_specifier") :declarator ("abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "abstract_array_declarator" "abstract_pointer_declarator") :parameters ("parameter_list"))) 
 ("abstract_parenthesized_declarator" (:*unnamed* ("abstract_parenthesized_declarator" "abstract_function_declarator" "ms_call_modifier" "abstract_reference_declarator" "abstract_array_declarator" "abstract_pointer_declarator"))) 
 ("abstract_pointer_declarator" (:*unnamed* ("type_qualifier" "ms_pointer_modifier") :declarator ("abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "abstract_array_declarator" "abstract_pointer_declarator"))) 
 ("abstract_reference_declarator" (:*unnamed* ("abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "abstract_array_declarator" "abstract_pointer_declarator"))) 
 ("access_specifier" (:*unnamed* nil)) 
 ("alias_declaration" (:*unnamed* ("attribute_declaration") :name ("type_identifier") :type ("type_descriptor"))) 
 ("alignas_specifier" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "primitive_type" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("alignof_expression" (:*unnamed* nil :type ("type_descriptor"))) 
 ("argument_list" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "compound_statement" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "preproc_defined" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("array_declarator" (:*unnamed* ("type_qualifier") :declarator ("template_method" "pointer_declarator" "field_identifier" "template_function" "array_declarator" "function_declarator" "primitive_type" "destructor_name" "operator_name" "identifier" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "type_identifier" "qualified_identifier" "reference_declarator") :size ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("assignment_expression" (:*unnamed* nil :left ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil :right ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("attribute" (:*unnamed* ("argument_list") :name ("identifier") :prefix ("identifier"))) 
 ("attribute_declaration" (:*unnamed* ("attribute"))) 
 ("attribute_specifier" (:*unnamed* ("argument_list"))) 
 ("attributed_declarator" (:*unnamed* ("template_method" "pointer_declarator" "field_identifier" "template_function" "attribute_declaration" "array_declarator" "function_declarator" "primitive_type" "destructor_name" "operator_name" "identifier" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "type_identifier" "qualified_identifier" "reference_declarator"))) 
 ("attributed_statement" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "attribute_declaration" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("auto" (:*unnamed* nil)) 
 ("base_class_clause" (:*unnamed* ("access_specifier" "type_identifier" "attribute_declaration" "virtual" "qualified_identifier" "template_type"))) 
 ("binary_expression" (:*unnamed* nil :left ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "preproc_defined" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil :right ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "preproc_defined" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("bitfield_clause" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("break_statement" (:*unnamed* nil)) 
 ("call_expression" (:*unnamed* nil :arguments ("argument_list") :function ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "primitive_type" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("case_statement" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "type_definition" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "declaration" "do_statement" "for_range_loop" "throw_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("cast_expression" (:*unnamed* nil :type ("type_descriptor") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("catch_clause" (:*unnamed* nil :body ("compound_statement") :parameters ("parameter_list"))) 
 ("char_literal" (:*unnamed* ("escape_sequence" "character"))) 
 ("character" (:*unnamed* nil)) 
 ("class_specifier" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "base_class_clause" "alignas_specifier" "virtual_specifier" "attribute_declaration") :body ("field_declaration_list") :name ("type_identifier" "template_type" "qualified_identifier"))) 
 ("co_await_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil)) 
 ("co_return_statement" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("co_yield_statement" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("comma_expression" (:*unnamed* nil :left ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :right ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("comment" (:*unnamed* nil)) 
 ("compound_literal_expression" (:*unnamed* nil :type ("primitive_type" "type_identifier" "qualified_identifier" "type_descriptor" "template_type") :value ("initializer_list"))) 
 ("compound_requirement" (:*unnamed* ("char_literal" "string_literal" "trailing_return_type" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("compound_statement" (:*unnamed* ("labeled_statement" "seh_leave_statement" "try_statement" "attributed_statement" "preproc_call" "decltype" "type_definition" "preproc_if" "namespace_alias_definition" "compound_statement" "function_definition" "namespace_definition" "template_declaration" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "template_type" "preproc_ifdef" "throw_statement" "type_identifier" "case_statement" "for_statement" "dependent_type" "return_statement" "preproc_def" "while_statement" "using_declaration" "sized_type_specifier" "alias_declaration" "static_assert_declaration" "co_yield_statement" "preproc_function_def" "switch_statement" "placeholder_type_specifier" "concept_definition" "union_specifier" "break_statement" "class_specifier" "primitive_type" "template_instantiation" "co_return_statement" "seh_try_statement" "do_statement" "struct_specifier" "for_range_loop" "goto_statement" "qualified_identifier" "if_statement" "expression_statement"))) 
 ("concatenated_string" (:*unnamed* ("identifier" "string_literal" "raw_string_literal"))) 
 ("concept_definition" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :name ("identifier"))) 
 ("condition_clause" (:*unnamed* nil :initializer ("init_statement") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "declaration" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("conditional_expression" (:*unnamed* nil :alternative ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :condition ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :consequence ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("constraint_conjunction" (:*unnamed* nil :left ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "constraint_conjunction" "new_expression" "template_type" "number_literal" "delete_expression" "type_identifier" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "constraint_disjunction" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil :right ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "constraint_conjunction" "new_expression" "template_type" "number_literal" "delete_expression" "type_identifier" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "constraint_disjunction" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("constraint_disjunction" (:*unnamed* nil :left ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "constraint_conjunction" "new_expression" "template_type" "number_literal" "delete_expression" "type_identifier" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "constraint_disjunction" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil :right ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "constraint_conjunction" "new_expression" "template_type" "number_literal" "delete_expression" "type_identifier" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "constraint_disjunction" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("continue_statement" (:*unnamed* nil)) 
 ("declaration" (:*unnamed* ("ms_declspec_modifier" "virtual" "type_qualifier" "attribute_declaration" "attribute_specifier" "storage_class_specifier" "explicit_function_specifier" "alignas_specifier") :declarator ("pointer_declarator" "destructor_name" "operator_name" "init_declarator" "identifier" "template_function" "reference_declarator" "array_declarator" "parenthesized_declarator" "gnu_asm_expression" "attributed_declarator" "structured_binding_declarator" "qualified_identifier" "operator_cast" "function_declarator") :default_value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("declaration_list" (:*unnamed* ("labeled_statement" "seh_leave_statement" "try_statement" "attributed_statement" "preproc_call" "decltype" "type_definition" "preproc_if" "namespace_alias_definition" "compound_statement" "function_definition" "namespace_definition" "template_declaration" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "template_type" "preproc_ifdef" "throw_statement" "type_identifier" "case_statement" "for_statement" "dependent_type" "return_statement" "preproc_def" "while_statement" "using_declaration" "sized_type_specifier" "alias_declaration" "static_assert_declaration" "co_yield_statement" "preproc_function_def" "switch_statement" "placeholder_type_specifier" "concept_definition" "union_specifier" "break_statement" "class_specifier" "primitive_type" "template_instantiation" "co_return_statement" "seh_try_statement" "do_statement" "struct_specifier" "for_range_loop" "goto_statement" "qualified_identifier" "if_statement" "expression_statement"))) 
 ("decltype" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "auto" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("default_method_clause" (:*unnamed* nil)) 
 ("delete_expression" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("delete_method_clause" (:*unnamed* nil)) 
 ("dependent_name" (:*unnamed* ("template_method" "template_function" "template_type"))) 
 ("dependent_type" (:*unnamed* ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("destructor_name" (:*unnamed* ("identifier"))) 
 ("do_statement" (:*unnamed* nil :body ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("enum_specifier" (:*unnamed* ("attribute_specifier") :base ("primitive_type" "sized_type_specifier" "type_identifier" "qualified_identifier") :body ("enumerator_list") :name ("type_identifier" "template_type" "qualified_identifier"))) 
 ("enumerator" (:*unnamed* nil :name ("identifier") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("enumerator_list" (:*unnamed* ("enumerator" "preproc_if" "preproc_call" "preproc_ifdef"))) 
 ("escape_sequence" (:*unnamed* nil)) 
 ("explicit_function_specifier" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("expression_statement" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("false" (:*unnamed* nil)) 
 ("field_declaration" (:*unnamed* ("ms_declspec_modifier" "bitfield_clause" "virtual" "type_qualifier" "attribute_declaration" "attribute_specifier" "storage_class_specifier" "alignas_specifier") :declarator ("template_method" "pointer_declarator" "operator_name" "field_identifier" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "function_declarator") :default_value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("field_declaration_list" (:*unnamed* ("preproc_def" "function_definition" "template_declaration" "using_declaration" "friend_declaration" "alias_declaration" "static_assert_declaration" "preproc_function_def" "declaration" "field_declaration" "preproc_ifdef" "access_specifier" "preproc_call" "type_definition" "preproc_if"))) 
 ("field_designator" (:*unnamed* ("field_identifier"))) 
 ("field_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :field ("template_method" "dependent_name" "destructor_name" "field_identifier" "qualified_identifier") :operator nil)) 
 ("field_identifier" (:*unnamed* nil)) 
 ("field_initializer" (:*unnamed* ("template_method" "initializer_list" "qualified_identifier" "argument_list" "field_identifier"))) 
 ("field_initializer_list" (:*unnamed* ("field_initializer"))) 
 ("fold_expression" (:*unnamed* nil :left ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil :right ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("for_range_loop" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "virtual" "type_qualifier" "storage_class_specifier" "alignas_specifier" "attribute_declaration") :body ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :declarator ("pointer_declarator" "destructor_name" "operator_name" "identifier" "template_function" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "qualified_identifier" "function_declarator") :initializer ("init_statement") :right ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("for_statement" (:*unnamed* nil :body ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :condition ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :initializer ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "declaration" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :update ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("friend_declaration" (:*unnamed* ("function_definition" "type_identifier" "qualified_identifier" "declaration" "template_type"))) 
 ("function_declarator" (:*unnamed* ("throw_specifier" "trailing_return_type" "type_qualifier" "ref_qualifier" "attribute_declaration" "attribute_specifier" "gnu_asm_expression" "requires_clause" "noexcept" "virtual_specifier") :declarator ("template_method" "pointer_declarator" "field_identifier" "template_function" "array_declarator" "function_declarator" "primitive_type" "destructor_name" "operator_name" "identifier" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "type_identifier" "qualified_identifier" "reference_declarator") :parameters ("parameter_list"))) 
 ("function_definition" (:*unnamed* ("ms_declspec_modifier" "delete_method_clause" "pure_virtual_clause" "type_qualifier" "virtual" "attribute_declaration" "try_statement" "attribute_specifier" "ms_call_modifier" "default_method_clause" "storage_class_specifier" "explicit_function_specifier" "field_initializer_list" "alignas_specifier") :body ("compound_statement" "try_statement") :declarator ("template_method" "pointer_declarator" "destructor_name" "operator_name" "identifier" "field_identifier" "template_function" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "qualified_identifier" "operator_cast" "function_declarator") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("generic_expression" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "type_descriptor" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("gnu_asm_clobber_list" (:*unnamed* nil :register ("concatenated_string" "string_literal"))) 
 ("gnu_asm_expression" (:*unnamed* ("gnu_asm_qualifier") :assembly_code ("concatenated_string" "string_literal") :clobbers ("gnu_asm_clobber_list") :goto_labels ("gnu_asm_goto_list") :input_operands ("gnu_asm_input_operand_list") :output_operands ("gnu_asm_output_operand_list"))) 
 ("gnu_asm_goto_list" (:*unnamed* nil :label ("identifier"))) 
 ("gnu_asm_input_operand" (:*unnamed* nil :constraint ("string_literal") :symbol ("identifier") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("gnu_asm_input_operand_list" (:*unnamed* nil :operand ("gnu_asm_input_operand"))) 
 ("gnu_asm_output_operand" (:*unnamed* nil :constraint ("string_literal") :symbol ("identifier") :value ("identifier"))) 
 ("gnu_asm_output_operand_list" (:*unnamed* nil :operand ("gnu_asm_output_operand"))) 
 ("gnu_asm_qualifier" (:*unnamed* nil)) 
 ("goto_statement" (:*unnamed* nil :label ("statement_identifier"))) 
 ("identifier" (:*unnamed* nil)) 
 ("if_statement" (:*unnamed* nil :alternative ("else_clause") :condition ("condition_clause") :consequence ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement"))) 
 ("init_declarator" (:*unnamed* nil :declarator ("pointer_declarator" "destructor_name" "operator_name" "identifier" "template_function" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "qualified_identifier" "function_declarator") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "argument_list" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("init_statement" (:*unnamed* ("alias_declaration" "type_definition" "declaration" "expression_statement"))) 
 ("initializer_list" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression" "initializer_pair"))) 
 ("initializer_pair" (:*unnamed* nil :designator ("subscript_designator" "field_designator" "field_identifier" "subscript_range_designator") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("labeled_statement" (:*unnamed* ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :label ("statement_identifier"))) 
 ("lambda_capture_specifier" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "lambda_default_capture" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("lambda_default_capture" (:*unnamed* nil)) 
 ("lambda_expression" (:*unnamed* nil :body ("compound_statement") :captures ("lambda_capture_specifier") :constraint ("requires_clause") :declarator ("abstract_function_declarator") :template_parameters ("template_parameter_list"))) 
 ("linkage_specification" (:*unnamed* nil :body ("function_definition" "declaration_list" "declaration") :value ("string_literal"))) 
 ("literal_suffix" (:*unnamed* nil)) 
 ("ms_based_modifier" (:*unnamed* ("argument_list"))) 
 ("ms_call_modifier" (:*unnamed* nil)) 
 ("ms_declspec_modifier" (:*unnamed* ("identifier"))) 
 ("ms_pointer_modifier" (:*unnamed* ("ms_unsigned_ptr_modifier" "ms_unaligned_ptr_modifier" "ms_restrict_modifier" "ms_signed_ptr_modifier"))) 
 ("ms_restrict_modifier" (:*unnamed* nil)) 
 ("ms_signed_ptr_modifier" (:*unnamed* nil)) 
 ("ms_unaligned_ptr_modifier" (:*unnamed* nil)) 
 ("ms_unsigned_ptr_modifier" (:*unnamed* nil)) 
 ("namespace_alias_definition" (:*unnamed* ("namespace_identifier" "nested_namespace_specifier") :name ("namespace_identifier"))) 
 ("namespace_definition" (:*unnamed* ("attribute_declaration") :body ("declaration_list") :name ("namespace_identifier" "nested_namespace_specifier"))) 
 ("namespace_identifier" (:*unnamed* nil)) 
 ("nested_namespace_specifier" (:*unnamed* ("namespace_identifier" "nested_namespace_specifier"))) 
 ("new_declarator" (:*unnamed* ("new_declarator") :length ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("new_expression" (:*unnamed* nil :arguments ("initializer_list" "argument_list") :declarator ("new_declarator") :placement ("argument_list") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("noexcept" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("null" (:*unnamed* nil)) 
 ("number_literal" (:*unnamed* nil)) 
 ("offsetof_expression" (:*unnamed* nil :member ("field_identifier") :type ("type_descriptor"))) 
 ("operator_cast" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "virtual" "type_qualifier" "storage_class_specifier" "alignas_specifier" "attribute_declaration") :declarator ("abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "abstract_array_declarator" "abstract_pointer_declarator") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("operator_name" (:*unnamed* ("identifier"))) 
 ("optional_parameter_declaration" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "virtual" "type_qualifier" "storage_class_specifier" "alignas_specifier" "attribute_declaration") :declarator ("abstract_reference_declarator" "pointer_declarator" "destructor_name" "operator_name" "identifier" "template_function" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "qualified_identifier" "function_declarator") :default_value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("optional_type_parameter_declaration" (:*unnamed* nil :default_type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier") :name ("type_identifier"))) 
 ("parameter_declaration" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "virtual" "type_qualifier" "storage_class_specifier" "alignas_specifier" "attribute_declaration") :declarator ("pointer_declarator" "template_function" "abstract_parenthesized_declarator" "array_declarator" "abstract_array_declarator" "function_declarator" "qualified_identifier" "destructor_name" "operator_name" "identifier" "abstract_pointer_declarator" "parenthesized_declarator" "abstract_function_declarator" "attributed_declarator" "structured_binding_declarator" "abstract_reference_declarator" "reference_declarator") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("parameter_list" (:*unnamed* ("optional_parameter_declaration" "variadic_parameter" "variadic_parameter_declaration" "identifier" "parameter_declaration"))) 
 ("parameter_pack_expansion" (:*unnamed* nil :pattern ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "type_descriptor" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("parenthesized_declarator" (:*unnamed* ("template_method" "pointer_declarator" "field_identifier" "template_function" "array_declarator" "function_declarator" "primitive_type" "destructor_name" "operator_name" "identifier" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "type_identifier" "ms_call_modifier" "qualified_identifier" "reference_declarator"))) 
 ("parenthesized_expression" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "preproc_defined" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("placeholder_type_specifier" (:*unnamed* ("decltype" "auto") :constraint ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("pointer_declarator" (:*unnamed* ("type_qualifier" "ms_based_modifier" "ms_pointer_modifier") :declarator ("template_method" "pointer_declarator" "field_identifier" "template_function" "array_declarator" "function_declarator" "primitive_type" "destructor_name" "operator_name" "identifier" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "type_identifier" "qualified_identifier" "reference_declarator"))) 
 ("pointer_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil)) 
 ("pointer_type_declarator" (:*unnamed* ("type_qualifier" "ms_based_modifier" "ms_pointer_modifier") :declarator ("primitive_type" "pointer_declarator" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_identifier" "function_declarator"))) 
 ("preproc_arg" (:*unnamed* nil)) 
 ("preproc_call" (:*unnamed* nil :argument ("preproc_arg") :directive ("preproc_directive"))) 
 ("preproc_def" (:*unnamed* nil :name ("identifier") :value ("preproc_arg"))) 
 ("preproc_defined" (:*unnamed* ("identifier"))) 
 ("preproc_directive" (:*unnamed* nil)) 
 ("preproc_elif" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "try_statement" "attributed_statement" "preproc_call" "decltype" "type_definition" "preproc_if" "namespace_alias_definition" "compound_statement" "function_definition" "namespace_definition" "template_declaration" "continue_statement" "linkage_specification" "friend_declaration" "preproc_include" "enum_specifier" "declaration" "template_type" "preproc_ifdef" "throw_statement" "type_identifier" "case_statement" "for_statement" "dependent_type" "return_statement" "preproc_def" "while_statement" "using_declaration" "sized_type_specifier" "alias_declaration" "static_assert_declaration" "co_yield_statement" "preproc_function_def" "field_declaration" "switch_statement" "access_specifier" "placeholder_type_specifier" "concept_definition" "union_specifier" "break_statement" "class_specifier" "primitive_type" "template_instantiation" "co_return_statement" "seh_try_statement" "do_statement" "struct_specifier" "for_range_loop" "goto_statement" "qualified_identifier" "if_statement" "expression_statement") :alternative ("preproc_elif" "preproc_else") :condition ("char_literal" "unary_expression" "identifier" "binary_expression" "number_literal" "preproc_defined" "call_expression" "parenthesized_expression"))) 
 ("preproc_elifdef" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "try_statement" "attributed_statement" "preproc_call" "decltype" "type_definition" "preproc_if" "namespace_alias_definition" "compound_statement" "function_definition" "namespace_definition" "template_declaration" "continue_statement" "linkage_specification" "friend_declaration" "preproc_include" "enum_specifier" "declaration" "template_type" "preproc_ifdef" "throw_statement" "type_identifier" "case_statement" "for_statement" "dependent_type" "return_statement" "preproc_def" "while_statement" "using_declaration" "sized_type_specifier" "alias_declaration" "static_assert_declaration" "co_yield_statement" "preproc_function_def" "field_declaration" "switch_statement" "access_specifier" "placeholder_type_specifier" "concept_definition" "union_specifier" "break_statement" "class_specifier" "primitive_type" "template_instantiation" "co_return_statement" "seh_try_statement" "do_statement" "struct_specifier" "for_range_loop" "goto_statement" "qualified_identifier" "if_statement" "expression_statement") :alternative ("preproc_elif" "preproc_else") :name ("identifier"))) 
 ("preproc_else" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "try_statement" "attributed_statement" "preproc_call" "decltype" "type_definition" "preproc_if" "namespace_alias_definition" "compound_statement" "function_definition" "namespace_definition" "template_declaration" "continue_statement" "linkage_specification" "friend_declaration" "preproc_include" "enum_specifier" "declaration" "template_type" "preproc_ifdef" "throw_statement" "type_identifier" "case_statement" "for_statement" "dependent_type" "return_statement" "preproc_def" "while_statement" "using_declaration" "sized_type_specifier" "alias_declaration" "static_assert_declaration" "co_yield_statement" "preproc_function_def" "field_declaration" "switch_statement" "access_specifier" "placeholder_type_specifier" "concept_definition" "union_specifier" "break_statement" "class_specifier" "primitive_type" "template_instantiation" "co_return_statement" "seh_try_statement" "do_statement" "struct_specifier" "for_range_loop" "goto_statement" "qualified_identifier" "if_statement" "expression_statement"))) 
 ("preproc_function_def" (:*unnamed* nil :name ("identifier") :parameters ("preproc_params") :value ("preproc_arg"))) 
 ("preproc_if" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "try_statement" "attributed_statement" "preproc_call" "decltype" "type_definition" "preproc_if" "namespace_alias_definition" "compound_statement" "function_definition" "namespace_definition" "template_declaration" "continue_statement" "linkage_specification" "friend_declaration" "preproc_include" "enum_specifier" "declaration" "template_type" "preproc_ifdef" "throw_statement" "type_identifier" "case_statement" "for_statement" "dependent_type" "return_statement" "preproc_def" "while_statement" "using_declaration" "sized_type_specifier" "alias_declaration" "static_assert_declaration" "co_yield_statement" "preproc_function_def" "field_declaration" "switch_statement" "access_specifier" "placeholder_type_specifier" "concept_definition" "union_specifier" "break_statement" "class_specifier" "primitive_type" "template_instantiation" "co_return_statement" "seh_try_statement" "do_statement" "struct_specifier" "for_range_loop" "goto_statement" "qualified_identifier" "if_statement" "expression_statement") :alternative ("preproc_elif" "preproc_else") :condition ("char_literal" "unary_expression" "identifier" "binary_expression" "number_literal" "preproc_defined" "call_expression" "parenthesized_expression"))) 
 ("preproc_ifdef" (:*unnamed* ("enumerator" "labeled_statement" "seh_leave_statement" "try_statement" "attributed_statement" "preproc_call" "decltype" "type_definition" "preproc_if" "namespace_alias_definition" "compound_statement" "function_definition" "namespace_definition" "template_declaration" "continue_statement" "linkage_specification" "friend_declaration" "preproc_include" "enum_specifier" "declaration" "template_type" "preproc_ifdef" "throw_statement" "type_identifier" "case_statement" "for_statement" "dependent_type" "return_statement" "preproc_def" "while_statement" "using_declaration" "sized_type_specifier" "alias_declaration" "static_assert_declaration" "co_yield_statement" "preproc_function_def" "field_declaration" "switch_statement" "access_specifier" "placeholder_type_specifier" "concept_definition" "union_specifier" "break_statement" "class_specifier" "primitive_type" "template_instantiation" "co_return_statement" "seh_try_statement" "do_statement" "struct_specifier" "for_range_loop" "goto_statement" "qualified_identifier" "if_statement" "expression_statement") :alternative ("preproc_elifdef" "preproc_elif" "preproc_else") :name ("identifier"))) 
 ("preproc_include" (:*unnamed* nil :path ("identifier" "string_literal" "call_expression" "system_lib_string"))) 
 ("preproc_params" (:*unnamed* ("identifier"))) 
 ("primitive_type" (:*unnamed* nil)) 
 ("pure_virtual_clause" (:*unnamed* nil)) 
 ("qualified_identifier" (:*unnamed* nil :name ("template_method" "dependent_name" "destructor_name" "operator_name" "identifier" "field_identifier" "pointer_type_declarator" "template_function" "template_type" "type_identifier" "qualified_identifier" "operator_cast") :scope ("decltype" "namespace_identifier" "dependent_name" "template_type"))) 
 ("raw_string_content" (:*unnamed* nil)) 
 ("raw_string_delimiter" (:*unnamed* nil)) 
 ("raw_string_literal" (:*unnamed* ("raw_string_content" "raw_string_delimiter") :delimiter ("raw_string_delimiter"))) 
 ("ref_qualifier" (:*unnamed* nil)) 
 ("reference_declarator" (:*unnamed* ("template_method" "pointer_declarator" "field_identifier" "template_function" "array_declarator" "variadic_declarator" "function_declarator" "primitive_type" "destructor_name" "operator_name" "identifier" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "type_identifier" "qualified_identifier" "reference_declarator"))) 
 ("requirement_seq" (:*unnamed* ("type_requirement" "simple_requirement" "compound_requirement"))) 
 ("requires_clause" (:*unnamed* nil :constraint ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "constraint_conjunction" "new_expression" "template_type" "number_literal" "delete_expression" "type_identifier" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "constraint_disjunction" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("requires_expression" (:*unnamed* nil :parameters ("parameter_list") :requirements ("requirement_seq"))) 
 ("return_statement" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("seh_except_clause" (:*unnamed* nil :body ("compound_statement") :filter ("parenthesized_expression"))) 
 ("seh_finally_clause" (:*unnamed* nil :body ("compound_statement"))) 
 ("seh_leave_statement" (:*unnamed* nil)) 
 ("seh_try_statement" (:*unnamed* ("seh_except_clause" "seh_finally_clause") :body ("compound_statement"))) 
 ("simple_requirement" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "comma_expression" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("sized_type_specifier" (:*unnamed* nil :type ("primitive_type" "type_identifier"))) 
 ("sizeof_expression" (:*unnamed* nil :type ("type_descriptor") :value ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("statement_identifier" (:*unnamed* nil)) 
 ("static_assert_declaration" (:*unnamed* nil :condition ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :message ("concatenated_string" "string_literal" "raw_string_literal"))) 
 ("storage_class_specifier" (:*unnamed* nil)) 
 ("string_content" (:*unnamed* nil)) 
 ("string_literal" (:*unnamed* ("escape_sequence" "string_content"))) 
 ("struct_specifier" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "base_class_clause" "alignas_specifier" "virtual_specifier" "attribute_declaration") :body ("field_declaration_list") :name ("type_identifier" "template_type" "qualified_identifier"))) 
 ("structured_binding_declarator" (:*unnamed* ("identifier"))) 
 ("subscript_argument_list" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "initializer_list" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("subscript_designator" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("subscript_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :indices ("subscript_argument_list"))) 
 ("subscript_range_designator" (:*unnamed* nil :end ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :start ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("switch_statement" (:*unnamed* nil :body ("compound_statement") :condition ("condition_clause"))) 
 ("system_lib_string" (:*unnamed* nil)) 
 ("template_argument_list" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "type_descriptor" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("template_declaration" (:*unnamed* ("sized_type_specifier" "alias_declaration" "requires_clause" "placeholder_type_specifier" "decltype" "concept_definition" "union_specifier" "class_specifier" "function_definition" "primitive_type" "template_declaration" "friend_declaration" "enum_specifier" "declaration" "template_type" "struct_specifier" "type_identifier" "qualified_identifier" "dependent_type") :parameters ("template_parameter_list"))) 
 ("template_function" (:*unnamed* nil :arguments ("template_argument_list") :name ("identifier"))) 
 ("template_instantiation" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "virtual" "type_qualifier" "storage_class_specifier" "alignas_specifier" "attribute_declaration") :declarator ("pointer_declarator" "destructor_name" "operator_name" "identifier" "template_function" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "structured_binding_declarator" "qualified_identifier" "function_declarator") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("template_method" (:*unnamed* nil :arguments ("template_argument_list") :name ("operator_name" "field_identifier"))) 
 ("template_parameter_list" (:*unnamed* ("template_template_parameter_declaration" "optional_type_parameter_declaration" "optional_parameter_declaration" "variadic_type_parameter_declaration" "type_parameter_declaration" "variadic_parameter_declaration" "parameter_declaration"))) 
 ("template_template_parameter_declaration" (:*unnamed* ("optional_type_parameter_declaration" "variadic_type_parameter_declaration" "type_parameter_declaration") :parameters ("template_parameter_list"))) 
 ("template_type" (:*unnamed* nil :arguments ("template_argument_list") :name ("type_identifier"))) 
 ("this" (:*unnamed* nil)) 
 ("throw_specifier" (:*unnamed* ("type_descriptor"))) 
 ("throw_statement" (:*unnamed* ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression"))) 
 ("trailing_return_type" (:*unnamed* ("type_descriptor"))) 
 ("translation_unit" (:*unnamed* ("labeled_statement" "try_statement" "attributed_statement" "preproc_call" "decltype" "preproc_if" "type_definition" "namespace_alias_definition" "compound_statement" "function_definition" "namespace_definition" "template_declaration" "continue_statement" "linkage_specification" "preproc_include" "enum_specifier" "declaration" "template_type" "preproc_ifdef" "type_identifier" "throw_statement" "case_statement" "for_statement" "dependent_type" "return_statement" "preproc_def" "while_statement" "using_declaration" "sized_type_specifier" "alias_declaration" "static_assert_declaration" "co_yield_statement" "preproc_function_def" "switch_statement" "placeholder_type_specifier" "concept_definition" "union_specifier" "break_statement" "class_specifier" "primitive_type" "template_instantiation" "co_return_statement" "do_statement" "struct_specifier" "for_range_loop" "goto_statement" "qualified_identifier" "if_statement" "expression_statement"))) 
 ("true" (:*unnamed* nil)) 
 ("try_statement" (:*unnamed* ("field_initializer_list" "catch_clause") :body ("compound_statement"))) 
 ("type_definition" (:*unnamed* ("attribute_specifier" "type_qualifier") :declarator ("primitive_type" "pointer_declarator" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "type_identifier" "function_declarator") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("type_descriptor" (:*unnamed* ("type_qualifier") :declarator ("abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "abstract_array_declarator" "abstract_pointer_declarator") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("type_identifier" (:*unnamed* nil)) 
 ("type_parameter_declaration" (:*unnamed* ("type_identifier"))) 
 ("type_qualifier" (:*unnamed* nil)) 
 ("type_requirement" (:*unnamed* ("type_identifier" "template_type" "qualified_identifier"))) 
 ("unary_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "preproc_defined" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil)) 
 ("union_specifier" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "base_class_clause" "alignas_specifier" "virtual_specifier" "attribute_declaration") :body ("field_declaration_list") :name ("type_identifier" "template_type" "qualified_identifier"))) 
 ("update_expression" (:*unnamed* nil :argument ("char_literal" "string_literal" "requires_expression" "false" "pointer_expression" "true" "offsetof_expression" "co_await_expression" "raw_string_literal" "field_expression" "assignment_expression" "null" "new_expression" "number_literal" "delete_expression" "cast_expression" "call_expression" "alignof_expression" "parenthesized_expression" "conditional_expression" "template_function" "binary_expression" "requires_clause" "update_expression" "generic_expression" "concatenated_string" "fold_expression" "unary_expression" "sizeof_expression" "identifier" "gnu_asm_expression" "this" "parameter_pack_expansion" "user_defined_literal" "qualified_identifier" "lambda_expression" "subscript_expression" "compound_literal_expression") :operator nil)) 
 ("user_defined_literal" (:*unnamed* ("char_literal" "concatenated_string" "string_literal" "number_literal" "literal_suffix" "raw_string_literal"))) 
 ("using_declaration" (:*unnamed* ("identifier" "qualified_identifier"))) 
 ("variadic_declarator" (:*unnamed* ("identifier"))) 
 ("variadic_parameter" (:*unnamed* nil)) 
 ("variadic_parameter_declaration" (:*unnamed* ("ms_declspec_modifier" "attribute_specifier" "virtual" "type_qualifier" "storage_class_specifier" "alignas_specifier" "attribute_declaration") :declarator ("variadic_declarator" "reference_declarator") :type ("class_specifier" "primitive_type" "union_specifier" "sized_type_specifier" "enum_specifier" "template_type" "struct_specifier" "type_identifier" "placeholder_type_specifier" "decltype" "dependent_type" "qualified_identifier"))) 
 ("variadic_type_parameter_declaration" (:*unnamed* ("type_identifier"))) 
 ("virtual" (:*unnamed* nil)) 
 ("virtual_specifier" (:*unnamed* nil)) 
 ("while_statement" (:*unnamed* nil :body ("while_statement" "labeled_statement" "seh_leave_statement" "co_yield_statement" "try_statement" "switch_statement" "attributed_statement" "break_statement" "compound_statement" "continue_statement" "co_return_statement" "seh_try_statement" "do_statement" "for_range_loop" "throw_statement" "case_statement" "goto_statement" "for_statement" "if_statement" "expression_statement" "return_statement") :condition ("condition_clause"))) 
))
;; END Production rules for cpp
;; START Inverse production rules for cpp
(defconst combobulate-rules-cpp-inverse 
 '(("abstract_array_declarator" ("type_descriptor" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "operator_cast" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("abstract_function_declarator" ("type_descriptor" "operator_cast" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "lambda_expression" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("abstract_parenthesized_declarator" ("type_descriptor" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "operator_cast" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("abstract_pointer_declarator" ("type_descriptor" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_function_declarator" "abstract_reference_declarator" "operator_cast" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("abstract_reference_declarator" ("type_descriptor" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "optional_parameter_declaration" "abstract_function_declarator" "abstract_reference_declarator" "operator_cast" "abstract_array_declarator" "_abstract_declarator" "parameter_declaration"))
   ("access_specifier" ("preproc_elifdef" "preproc_ifdef" "field_declaration_list" "preproc_elif" "preproc_else" "base_class_clause" "preproc_if"))
   ("alias_declaration" ("preproc_elifdef" "template_declaration" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "init_statement" "compound_statement"))
   ("alignas_specifier" ("class_specifier" "function_definition" "template_instantiation" "variadic_parameter_declaration" "declaration" "field_declaration" "struct_specifier" "for_range_loop" "optional_parameter_declaration" "operator_cast" "union_specifier" "parameter_declaration"))
   ("alignof_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("argument_list" ("init_declarator" "field_initializer" "new_expression" "attribute_specifier" "attribute" "call_expression" "ms_based_modifier"))
   ("array_declarator" ("_type_declarator" "type_definition" "function_definition" "declaration" "parenthesized_declarator" "attributed_declarator" "pointer_type_declarator" "parameter_declaration" "_field_declarator" "pointer_declarator" "init_declarator" "field_declaration" "array_declarator" "optional_parameter_declaration" "function_declarator" "template_instantiation" "_declarator" "for_range_loop" "reference_declarator"))
   ("assignment_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("attribute" ("attribute_declaration"))
   ("attribute_declaration" ("attributed_statement" "function_definition" "namespace_definition" "variadic_parameter_declaration" "declaration" "attributed_declarator" "abstract_function_declarator" "base_class_clause" "parameter_declaration" "alias_declaration" "field_declaration" "optional_parameter_declaration" "operator_cast" "union_specifier" "function_declarator" "class_specifier" "template_instantiation" "struct_specifier" "for_range_loop"))
   ("attribute_specifier" ("class_specifier" "function_definition" "template_instantiation" "variadic_parameter_declaration" "enum_specifier" "type_definition" "declaration" "field_declaration" "struct_specifier" "for_range_loop" "optional_parameter_declaration" "abstract_function_declarator" "operator_cast" "union_specifier" "function_declarator" "parameter_declaration"))
   ("attributed_declarator" ("_type_declarator" "type_definition" "function_definition" "declaration" "parenthesized_declarator" "attributed_declarator" "pointer_type_declarator" "parameter_declaration" "_field_declarator" "pointer_declarator" "init_declarator" "field_declaration" "array_declarator" "optional_parameter_declaration" "function_declarator" "template_instantiation" "_declarator" "for_range_loop" "reference_declarator"))
   ("attributed_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("auto" ("decltype" "placeholder_type_specifier"))
   ("base_class_clause" ("class_specifier" "union_specifier" "struct_specifier"))
   ("binary_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "preproc_if" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "preproc_elif" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("bitfield_clause" ("field_declaration"))
   ("break_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("call_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "preproc_if" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "preproc_include" "declaration" "constraint_conjunction" "delete_expression" "preproc_elif" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("case_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("cast_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("catch_clause" ("try_statement"))
   ("char_literal" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "preproc_if" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "preproc_elif" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "user_defined_literal" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("character" ("char_literal"))
   ("class_specifier" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "declaration" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "dependent_type" "parameter_declaration" "preproc_elifdef" "_type_specifier" "field_declaration" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop"))
   ("co_await_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("co_return_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("co_yield_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("comma_expression" ("condition_clause" "simple_requirement" "comma_expression" "conditional_expression" "return_statement" "for_statement" "expression_statement" "parenthesized_expression"))
   ("compound_literal_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("compound_requirement" ("requirement_seq"))
   ("compound_statement" ("seh_finally_clause" "labeled_statement" "translation_unit" "try_statement" "attributed_statement" "_statement" "seh_except_clause" "preproc_if" "compound_statement" "function_definition" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "catch_clause" "case_statement" "for_statement" "else_clause" "preproc_elifdef" "while_statement" "switch_statement" "argument_list" "seh_try_statement" "do_statement" "for_range_loop" "lambda_expression" "if_statement"))
   ("concatenated_string" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "gnu_asm_clobber_list" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "gnu_asm_expression" "subscript_designator" "parameter_pack_expansion" "user_defined_literal" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("concept_definition" ("preproc_elifdef" "template_declaration" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("condition_clause" ("switch_statement" "while_statement" "if_statement"))
   ("conditional_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("constraint_conjunction" ("constraint_disjunction" "requires_clause" "constraint_conjunction"))
   ("constraint_disjunction" ("constraint_disjunction" "requires_clause" "constraint_conjunction"))
   ("continue_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("declaration" ("preproc_elifdef" "condition_clause" "template_declaration" "linkage_specification" "friend_declaration" "preproc_if" "translation_unit" "preproc_ifdef" "field_declaration_list" "declaration_list" "preproc_elif" "preproc_else" "case_statement" "for_statement" "init_statement" "compound_statement"))
   ("declaration_list" ("namespace_definition" "linkage_specification"))
   ("decltype" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "declaration" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "dependent_type" "parameter_declaration" "preproc_elifdef" "_type_specifier" "field_declaration" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop" "qualified_identifier"))
   ("default_method_clause" ("function_definition"))
   ("delete_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("delete_method_clause" ("function_definition"))
   ("dependent_name" ("field_expression" "qualified_identifier"))
   ("dependent_type" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "declaration" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "dependent_type" "parameter_declaration" "preproc_elifdef" "_type_specifier" "field_declaration" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop"))
   ("destructor_name" ("field_expression" "function_definition" "template_instantiation" "pointer_declarator" "_declarator" "init_declarator" "declaration" "reference_declarator" "array_declarator" "for_range_loop" "optional_parameter_declaration" "attributed_declarator" "parenthesized_declarator" "qualified_identifier" "function_declarator" "parameter_declaration"))
   ("do_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("else_clause" ("if_statement"))
   ("enum_specifier" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "declaration" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "dependent_type" "parameter_declaration" "preproc_elifdef" "_type_specifier" "field_declaration" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop"))
   ("enumerator" ("preproc_elifdef" "enumerator_list" "preproc_ifdef" "preproc_elif" "preproc_else" "preproc_if"))
   ("enumerator_list" ("enum_specifier"))
   ("escape_sequence" ("char_literal" "string_literal"))
   ("explicit_function_specifier" ("function_definition" "declaration"))
   ("expression_statement" ("labeled_statement" "translation_unit" "attributed_statement" "_statement" "preproc_if" "compound_statement" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "case_statement" "for_statement" "else_clause" "preproc_elifdef" "while_statement" "init_statement" "do_statement" "for_range_loop" "if_statement"))
   ("false" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("field_declaration" ("preproc_elifdef" "preproc_ifdef" "field_declaration_list" "preproc_elif" "preproc_else" "preproc_if"))
   ("field_declaration_list" ("class_specifier" "union_specifier" "struct_specifier"))
   ("field_designator" ("initializer_pair"))
   ("field_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("field_identifier" ("field_expression" "function_definition" "template_method" "_field_declarator" "pointer_declarator" "field_initializer" "field_declaration" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "qualified_identifier" "offsetof_expression" "field_designator" "function_declarator" "initializer_pair"))
   ("field_initializer" ("field_initializer_list"))
   ("field_initializer_list" ("function_definition" "try_statement"))
   ("fold_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("for_range_loop" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("for_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("friend_declaration" ("preproc_elifdef" "template_declaration" "preproc_ifdef" "field_declaration_list" "preproc_elif" "preproc_else" "preproc_if"))
   ("function_declarator" ("_type_declarator" "type_definition" "function_definition" "declaration" "parenthesized_declarator" "attributed_declarator" "pointer_type_declarator" "parameter_declaration" "_field_declarator" "pointer_declarator" "init_declarator" "field_declaration" "array_declarator" "optional_parameter_declaration" "function_declarator" "template_instantiation" "_declarator" "for_range_loop" "reference_declarator"))
   ("function_definition" ("preproc_elifdef" "template_declaration" "linkage_specification" "friend_declaration" "translation_unit" "preproc_ifdef" "declaration_list" "field_declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("generic_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("gnu_asm_clobber_list" ("gnu_asm_expression"))
   ("gnu_asm_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "abstract_function_declarator" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "function_declarator" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("gnu_asm_goto_list" ("gnu_asm_expression"))
   ("gnu_asm_input_operand" ("gnu_asm_input_operand_list"))
   ("gnu_asm_input_operand_list" ("gnu_asm_expression"))
   ("gnu_asm_output_operand" ("gnu_asm_output_operand_list"))
   ("gnu_asm_output_operand_list" ("gnu_asm_expression"))
   ("gnu_asm_qualifier" ("gnu_asm_expression"))
   ("goto_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("identifier" ("_expression" "decltype" "abstract_array_declarator" "operator_name" "delete_expression" "attributed_declarator" "throw_statement" "parameter_declaration" "return_statement" "preproc_elifdef" "subscript_range_designator" "conditional_expression" "argument_list" "variadic_declarator" "alignas_specifier" "function_declarator" "preproc_params" "unary_expression" "comma_expression" "explicit_function_specifier" "enumerator" "gnu_asm_input_operand" "function_definition" "destructor_name" "preproc_include" "parenthesized_declarator" "case_statement" "cast_expression" "for_statement" "parenthesized_expression" "preproc_function_def" "template_function" "binary_expression" "template_argument_list" "concatenated_string" "fold_expression" "bitfield_clause" "_declarator" "for_range_loop" "expression_statement" "pointer_expression" "co_await_expression" "field_expression" "assignment_expression" "parameter_list" "noexcept" "call_expression" "preproc_def" "constraint_disjunction" "field_declaration" "array_declarator" "optional_parameter_declaration" "update_expression" "generic_expression" "simple_requirement" "structured_binding_declarator" "preproc_defined" "qualified_identifier" "subscript_expression" "reference_declarator" "initializer_pair" "ms_declspec_modifier" "condition_clause" "new_declarator" "preproc_if" "compound_requirement" "attribute" "declaration" "constraint_conjunction" "preproc_ifdef" "preproc_elif" "subscript_argument_list" "using_declaration" "pointer_declarator" "static_assert_declaration" "init_declarator" "co_yield_statement" "lambda_capture_specifier" "requires_clause" "concept_definition" "initializer_list" "gnu_asm_output_operand" "gnu_asm_goto_list" "sizeof_expression" "template_instantiation" "co_return_statement" "subscript_designator" "parameter_pack_expansion"))
   ("if_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("init_declarator" ("declaration"))
   ("init_statement" ("for_range_loop" "condition_clause"))
   ("initializer_list" ("initializer_list" "subscript_argument_list" "assignment_expression" "init_declarator" "declaration" "field_declaration" "field_initializer" "new_expression" "for_range_loop" "return_statement" "argument_list" "compound_literal_expression" "initializer_pair"))
   ("initializer_pair" ("initializer_list"))
   ("labeled_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("lambda_capture_specifier" ("lambda_expression"))
   ("lambda_default_capture" ("lambda_capture_specifier"))
   ("lambda_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("linkage_specification" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("literal_suffix" ("user_defined_literal"))
   ("ms_based_modifier" ("pointer_type_declarator" "pointer_declarator"))
   ("ms_call_modifier" ("abstract_parenthesized_declarator" "function_definition" "parenthesized_declarator"))
   ("ms_declspec_modifier" ("class_specifier" "function_definition" "template_instantiation" "variadic_parameter_declaration" "declaration" "field_declaration" "struct_specifier" "for_range_loop" "optional_parameter_declaration" "operator_cast" "union_specifier" "parameter_declaration"))
   ("ms_pointer_modifier" ("pointer_type_declarator" "pointer_declarator" "abstract_pointer_declarator"))
   ("ms_restrict_modifier" ("ms_pointer_modifier"))
   ("ms_signed_ptr_modifier" ("ms_pointer_modifier"))
   ("ms_unaligned_ptr_modifier" ("ms_pointer_modifier"))
   ("ms_unsigned_ptr_modifier" ("ms_pointer_modifier"))
   ("namespace_alias_definition" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("namespace_definition" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("namespace_identifier" ("nested_namespace_specifier" "namespace_definition" "namespace_alias_definition" "qualified_identifier"))
   ("nested_namespace_specifier" ("nested_namespace_specifier" "namespace_definition" "namespace_alias_definition"))
   ("new_declarator" ("new_declarator" "new_expression"))
   ("new_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("noexcept" ("abstract_function_declarator" "function_declarator"))
   ("null" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("number_literal" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "preproc_if" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "preproc_elif" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "user_defined_literal" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("offsetof_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("operator_cast" ("function_definition" "declaration" "qualified_identifier"))
   ("operator_name" ("template_method" "function_definition" "template_instantiation" "_field_declarator" "pointer_declarator" "_declarator" "init_declarator" "declaration" "field_declaration" "reference_declarator" "array_declarator" "for_range_loop" "optional_parameter_declaration" "attributed_declarator" "parenthesized_declarator" "qualified_identifier" "function_declarator" "parameter_declaration"))
   ("optional_parameter_declaration" ("parameter_list" "template_parameter_list"))
   ("optional_type_parameter_declaration" ("template_template_parameter_declaration" "template_parameter_list"))
   ("parameter_declaration" ("parameter_list" "template_parameter_list"))
   ("parameter_list" ("requires_expression" "abstract_function_declarator" "function_declarator" "catch_clause"))
   ("parameter_pack_expansion" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("parenthesized_declarator" ("_type_declarator" "type_definition" "function_definition" "declaration" "parenthesized_declarator" "attributed_declarator" "pointer_type_declarator" "parameter_declaration" "_field_declarator" "pointer_declarator" "init_declarator" "field_declaration" "array_declarator" "optional_parameter_declaration" "function_declarator" "template_instantiation" "_declarator" "for_range_loop" "reference_declarator"))
   ("parenthesized_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "preproc_if" "abstract_array_declarator" "compound_requirement" "co_await_expression" "seh_except_clause" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "preproc_elif" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "do_statement" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("placeholder_type_specifier" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "declaration" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "dependent_type" "parameter_declaration" "preproc_elifdef" "_type_specifier" "field_declaration" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop"))
   ("pointer_declarator" ("_type_declarator" "type_definition" "function_definition" "declaration" "parenthesized_declarator" "attributed_declarator" "pointer_type_declarator" "parameter_declaration" "_field_declarator" "pointer_declarator" "init_declarator" "field_declaration" "array_declarator" "optional_parameter_declaration" "function_declarator" "template_instantiation" "_declarator" "for_range_loop" "reference_declarator"))
   ("pointer_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("pointer_type_declarator" ("qualified_identifier"))
   ("preproc_arg" ("preproc_def" "preproc_function_def" "preproc_call"))
   ("preproc_call" ("preproc_elifdef" "enumerator_list" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_def" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_defined" ("unary_expression" "binary_expression" "preproc_elif" "preproc_if" "argument_list" "parenthesized_expression"))
   ("preproc_directive" ("preproc_call"))
   ("preproc_elif" ("preproc_elifdef" "preproc_if" "preproc_elif" "preproc_ifdef"))
   ("preproc_elifdef" ("preproc_ifdef"))
   ("preproc_else" ("preproc_elifdef" "preproc_if" "preproc_elif" "preproc_ifdef"))
   ("preproc_function_def" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_if" ("preproc_elifdef" "enumerator_list" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_ifdef" ("preproc_elifdef" "enumerator_list" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_include" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("preproc_params" ("preproc_function_def"))
   ("primitive_type" ("_type_declarator" "translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "enum_specifier" "declaration" "new_expression" "preproc_ifdef" "parenthesized_declarator" "declaration_list" "attributed_declarator" "preproc_elif" "preproc_else" "pointer_type_declarator" "dependent_type" "call_expression" "parameter_declaration" "preproc_elifdef" "pointer_declarator" "sized_type_specifier" "_type_specifier" "field_declaration" "array_declarator" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "alignas_specifier" "function_declarator" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop" "reference_declarator" "compound_literal_expression"))
   ("pure_virtual_clause" ("function_definition"))
   ("qualified_identifier" ("_expression" "decltype" "type_definition" "abstract_array_declarator" "enum_specifier" "delete_expression" "attributed_declarator" "throw_statement" "base_class_clause" "parameter_declaration" "return_statement" "preproc_elifdef" "subscript_range_designator" "conditional_expression" "operator_cast" "argument_list" "alignas_specifier" "function_declarator" "unary_expression" "comma_expression" "explicit_function_specifier" "compound_literal_expression" "enumerator" "gnu_asm_input_operand" "function_definition" "parenthesized_declarator" "declaration_list" "preproc_else" "case_statement" "cast_expression" "for_statement" "parenthesized_expression" "field_initializer" "binary_expression" "template_argument_list" "class_specifier" "fold_expression" "bitfield_clause" "_declarator" "for_range_loop" "expression_statement" "translation_unit" "pointer_expression" "co_await_expression" "field_expression" "assignment_expression" "template_declaration" "new_expression" "noexcept" "dependent_type" "call_expression" "constraint_disjunction" "_type_specifier" "field_declaration" "array_declarator" "optional_parameter_declaration" "type_requirement" "update_expression" "generic_expression" "optional_type_parameter_declaration" "simple_requirement" "type_descriptor" "struct_specifier" "qualified_identifier" "subscript_expression" "reference_declarator" "initializer_pair" "condition_clause" "new_declarator" "preproc_if" "compound_requirement" "compound_statement" "friend_declaration" "variadic_parameter_declaration" "declaration" "constraint_conjunction" "preproc_ifdef" "preproc_elif" "subscript_argument_list" "using_declaration" "pointer_declarator" "static_assert_declaration" "init_declarator" "co_yield_statement" "lambda_capture_specifier" "requires_clause" "placeholder_type_specifier" "concept_definition" "initializer_list" "union_specifier" "sizeof_expression" "template_instantiation" "co_return_statement" "subscript_designator" "parameter_pack_expansion"))
   ("raw_string_content" ("raw_string_literal"))
   ("raw_string_delimiter" ("raw_string_literal"))
   ("raw_string_literal" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "concatenated_string" "fold_expression" "simple_requirement" "bitfield_clause" "sizeof_expression" "unary_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "user_defined_literal" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("ref_qualifier" ("abstract_function_declarator" "function_declarator"))
   ("reference_declarator" ("_type_declarator" "type_definition" "function_definition" "variadic_parameter_declaration" "declaration" "parenthesized_declarator" "attributed_declarator" "pointer_type_declarator" "parameter_declaration" "_field_declarator" "pointer_declarator" "init_declarator" "field_declaration" "array_declarator" "optional_parameter_declaration" "function_declarator" "template_instantiation" "_declarator" "for_range_loop" "reference_declarator"))
   ("requirement_seq" ("requires_expression"))
   ("requires_clause" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "template_declaration" "declaration" "constraint_conjunction" "lambda_expression" "delete_expression" "abstract_function_declarator" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "function_declarator" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("requires_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("return_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("seh_except_clause" ("seh_try_statement"))
   ("seh_finally_clause" ("seh_try_statement"))
   ("seh_leave_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("seh_try_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("simple_requirement" ("requirement_seq"))
   ("sized_type_specifier" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "enum_specifier" "declaration" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "dependent_type" "parameter_declaration" "preproc_elifdef" "_type_specifier" "field_declaration" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop"))
   ("sizeof_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("statement_identifier" ("labeled_statement" "goto_statement"))
   ("static_assert_declaration" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("storage_class_specifier" ("function_definition" "template_instantiation" "variadic_parameter_declaration" "declaration" "field_declaration" "for_range_loop" "optional_parameter_declaration" "operator_cast" "parameter_declaration"))
   ("string_content" ("string_literal"))
   ("string_literal" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "linkage_specification" "preproc_include" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "gnu_asm_clobber_list" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "gnu_asm_output_operand" "template_argument_list" "generic_expression" "concatenated_string" "fold_expression" "simple_requirement" "bitfield_clause" "sizeof_expression" "unary_expression" "co_return_statement" "comma_expression" "for_range_loop" "gnu_asm_expression" "subscript_designator" "parameter_pack_expansion" "user_defined_literal" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("struct_specifier" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "declaration" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "dependent_type" "parameter_declaration" "preproc_elifdef" "_type_specifier" "field_declaration" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop"))
   ("structured_binding_declarator" ("function_definition" "template_instantiation" "pointer_declarator" "_declarator" "init_declarator" "declaration" "reference_declarator" "array_declarator" "for_range_loop" "optional_parameter_declaration" "attributed_declarator" "parenthesized_declarator" "function_declarator" "parameter_declaration"))
   ("subscript_argument_list" ("subscript_expression"))
   ("subscript_designator" ("initializer_pair"))
   ("subscript_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("subscript_range_designator" ("initializer_pair"))
   ("switch_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("system_lib_string" ("preproc_include"))
   ("template_argument_list" ("template_method" "template_function" "template_type"))
   ("template_declaration" ("preproc_elifdef" "template_declaration" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("template_function" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "function_definition" "assignment_expression" "dependent_name" "declaration" "constraint_conjunction" "parenthesized_declarator" "delete_expression" "attributed_declarator" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parameter_declaration" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "pointer_declarator" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "function_declarator" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "template_instantiation" "co_return_statement" "_declarator" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "qualified_identifier" "explicit_function_specifier" "subscript_expression" "expression_statement" "reference_declarator" "initializer_pair"))
   ("template_instantiation" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "preproc_if" "compound_statement"))
   ("template_method" ("field_expression" "function_definition" "dependent_name" "_field_declarator" "pointer_declarator" "field_initializer" "field_declaration" "reference_declarator" "array_declarator" "parenthesized_declarator" "attributed_declarator" "qualified_identifier" "function_declarator"))
   ("template_parameter_list" ("lambda_expression" "template_template_parameter_declaration" "template_declaration"))
   ("template_template_parameter_declaration" ("template_parameter_list"))
   ("template_type" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "dependent_name" "template_declaration" "friend_declaration" "variadic_parameter_declaration" "enum_specifier" "declaration" "constraint_conjunction" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "base_class_clause" "dependent_type" "parameter_declaration" "preproc_elifdef" "constraint_disjunction" "_type_specifier" "field_declaration" "optional_parameter_declaration" "type_requirement" "requires_clause" "placeholder_type_specifier" "operator_cast" "union_specifier" "class_specifier" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "struct_specifier" "for_range_loop" "qualified_identifier" "compound_literal_expression"))
   ("this" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("throw_specifier" ("abstract_function_declarator" "function_declarator"))
   ("throw_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
   ("trailing_return_type" ("abstract_function_declarator" "compound_requirement" "function_declarator"))
   ("true" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("try_statement" ("labeled_statement" "translation_unit" "attributed_statement" "_statement" "preproc_if" "compound_statement" "function_definition" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "case_statement" "for_statement" "else_clause" "preproc_elifdef" "while_statement" "do_statement" "for_range_loop" "if_statement"))
   ("type_definition" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "field_declaration_list" "declaration_list" "preproc_elif" "preproc_else" "case_statement" "preproc_if" "init_statement" "compound_statement"))
   ("type_descriptor" ("throw_specifier" "trailing_return_type" "sizeof_expression" "alias_declaration" "template_argument_list" "parameter_pack_expansion" "offsetof_expression" "cast_expression" "alignof_expression" "compound_literal_expression" "generic_expression"))
   ("type_identifier" ("_type_declarator" "translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "friend_declaration" "variadic_parameter_declaration" "enum_specifier" "declaration" "constraint_conjunction" "new_expression" "preproc_ifdef" "parenthesized_declarator" "declaration_list" "attributed_declarator" "preproc_elif" "preproc_else" "template_type" "base_class_clause" "pointer_type_declarator" "dependent_type" "parameter_declaration" "preproc_elifdef" "pointer_declarator" "sized_type_specifier" "alias_declaration" "constraint_disjunction" "_type_specifier" "field_declaration" "array_declarator" "optional_parameter_declaration" "type_requirement" "requires_clause" "placeholder_type_specifier" "operator_cast" "type_parameter_declaration" "union_specifier" "function_declarator" "class_specifier" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "struct_specifier" "for_range_loop" "variadic_type_parameter_declaration" "qualified_identifier" "reference_declarator" "compound_literal_expression"))
   ("type_parameter_declaration" ("template_template_parameter_declaration" "template_parameter_list"))
   ("type_qualifier" ("function_definition" "template_instantiation" "pointer_declarator" "variadic_parameter_declaration" "type_definition" "pointer_type_declarator" "type_descriptor" "declaration" "field_declaration" "abstract_pointer_declarator" "array_declarator" "for_range_loop" "optional_parameter_declaration" "abstract_function_declarator" "operator_cast" "abstract_array_declarator" "function_declarator" "parameter_declaration"))
   ("type_requirement" ("requirement_seq"))
   ("unary_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "preproc_if" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "preproc_elif" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("union_specifier" ("translation_unit" "type_definition" "preproc_if" "compound_statement" "function_definition" "template_declaration" "variadic_parameter_declaration" "declaration" "new_expression" "preproc_ifdef" "declaration_list" "preproc_elif" "preproc_else" "dependent_type" "parameter_declaration" "preproc_elifdef" "_type_specifier" "field_declaration" "optional_parameter_declaration" "placeholder_type_specifier" "operator_cast" "optional_type_parameter_declaration" "template_instantiation" "type_descriptor" "for_range_loop"))
   ("update_expression" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("user_defined_literal" ("enumerator" "condition_clause" "new_declarator" "gnu_asm_input_operand" "pointer_expression" "_expression" "decltype" "abstract_array_declarator" "compound_requirement" "co_await_expression" "field_expression" "assignment_expression" "declaration" "constraint_conjunction" "delete_expression" "throw_statement" "case_statement" "noexcept" "cast_expression" "for_statement" "call_expression" "parenthesized_expression" "return_statement" "subscript_range_designator" "subscript_argument_list" "init_declarator" "conditional_expression" "co_yield_statement" "constraint_disjunction" "binary_expression" "field_declaration" "static_assert_declaration" "array_declarator" "lambda_capture_specifier" "optional_parameter_declaration" "requires_clause" "update_expression" "concept_definition" "argument_list" "initializer_list" "alignas_specifier" "template_argument_list" "generic_expression" "simple_requirement" "fold_expression" "unary_expression" "bitfield_clause" "sizeof_expression" "co_return_statement" "comma_expression" "for_range_loop" "subscript_designator" "parameter_pack_expansion" "explicit_function_specifier" "subscript_expression" "expression_statement" "initializer_pair"))
   ("using_declaration" ("preproc_elifdef" "translation_unit" "preproc_ifdef" "declaration_list" "preproc_elif" "field_declaration_list" "preproc_else" "preproc_if" "compound_statement"))
   ("variadic_declarator" ("variadic_parameter_declaration" "reference_declarator"))
   ("variadic_parameter" ("parameter_list"))
   ("variadic_parameter_declaration" ("parameter_list" "template_parameter_list"))
   ("variadic_type_parameter_declaration" ("template_template_parameter_declaration" "template_parameter_list"))
   ("virtual" ("function_definition" "template_instantiation" "variadic_parameter_declaration" "operator_cast" "declaration" "field_declaration" "for_range_loop" "optional_parameter_declaration" "base_class_clause" "parameter_declaration"))
   ("virtual_specifier" ("class_specifier" "struct_specifier" "abstract_function_declarator" "union_specifier" "function_declarator"))
   ("while_statement" ("preproc_elifdef" "while_statement" "labeled_statement" "preproc_if" "do_statement" "translation_unit" "preproc_ifdef" "for_range_loop" "declaration_list" "preproc_elif" "preproc_else" "attributed_statement" "case_statement" "_statement" "for_statement" "else_clause" "if_statement" "compound_statement"))
  ) 
)
;; END Inverse production rules for cpp
;; START All node types in cpp
(defconst combobulate-rules-cpp-types 
 '("_abstract_declarator" "_declarator" "_expression" "_field_declarator" "_statement" "_type_declarator" "_type_specifier" "abstract_array_declarator" "abstract_function_declarator" "abstract_parenthesized_declarator" "abstract_pointer_declarator" "abstract_reference_declarator" "access_specifier" "alias_declaration" "alignas_specifier" "alignof_expression" "argument_list" "array_declarator" "assignment_expression" "attribute" "attribute_declaration" "attribute_specifier" "attributed_declarator" "attributed_statement" "auto" "base_class_clause" "binary_expression" "bitfield_clause" "break_statement" "call_expression" "case_statement" "cast_expression" "catch_clause" "char_literal" "character" "class_specifier" "co_await_expression" "co_return_statement" "co_yield_statement" "comma_expression" "comment" "compound_literal_expression" "compound_requirement" "compound_statement" "concatenated_string" "concept_definition" "condition_clause" "conditional_expression" "constraint_conjunction" "constraint_disjunction" "continue_statement" "declaration" "declaration_list" "decltype" "default_method_clause" "delete_expression" "delete_method_clause" "dependent_name" "dependent_type" "destructor_name" "do_statement" "else_clause" "enum_specifier" "enumerator" "enumerator_list" "escape_sequence" "explicit_function_specifier" "expression_statement" "false" "field_declaration" "field_declaration_list" "field_designator" "field_expression" "field_identifier" "field_initializer" "field_initializer_list" "fold_expression" "for_range_loop" "for_statement" "friend_declaration" "function_declarator" "function_definition" "generic_expression" "gnu_asm_clobber_list" "gnu_asm_expression" "gnu_asm_goto_list" "gnu_asm_input_operand" "gnu_asm_input_operand_list" "gnu_asm_output_operand" "gnu_asm_output_operand_list" "gnu_asm_qualifier" "goto_statement" "identifier" "if_statement" "init_declarator" "init_statement" "initializer_list" "initializer_pair" "labeled_statement" "lambda_capture_specifier" "lambda_default_capture" "lambda_expression" "linkage_specification" "literal_suffix" "ms_based_modifier" "ms_call_modifier" "ms_declspec_modifier" "ms_pointer_modifier" "ms_restrict_modifier" "ms_signed_ptr_modifier" "ms_unaligned_ptr_modifier" "ms_unsigned_ptr_modifier" "namespace_alias_definition" "namespace_definition" "namespace_identifier" "nested_namespace_specifier" "new_declarator" "new_expression" "noexcept" "null" "number_literal" "offsetof_expression" "operator_cast" "operator_name" "optional_parameter_declaration" "optional_type_parameter_declaration" "parameter_declaration" "parameter_list" "parameter_pack_expansion" "parenthesized_declarator" "parenthesized_expression" "placeholder_type_specifier" "pointer_declarator" "pointer_expression" "pointer_type_declarator" "preproc_arg" "preproc_call" "preproc_def" "preproc_defined" "preproc_directive" "preproc_elif" "preproc_elifdef" "preproc_else" "preproc_function_def" "preproc_if" "preproc_ifdef" "preproc_include" "preproc_params" "primitive_type" "pure_virtual_clause" "qualified_identifier" "raw_string_content" "raw_string_delimiter" "raw_string_literal" "ref_qualifier" "reference_declarator" "requirement_seq" "requires_clause" "requires_expression" "return_statement" "seh_except_clause" "seh_finally_clause" "seh_leave_statement" "seh_try_statement" "simple_requirement" "sized_type_specifier" "sizeof_expression" "statement_identifier" "static_assert_declaration" "storage_class_specifier" "string_content" "string_literal" "struct_specifier" "structured_binding_declarator" "subscript_argument_list" "subscript_designator" "subscript_expression" "subscript_range_designator" "switch_statement" "system_lib_string" "template_argument_list" "template_declaration" "template_function" "template_instantiation" "template_method" "template_parameter_list" "template_template_parameter_declaration" "template_type" "this" "throw_specifier" "throw_statement" "trailing_return_type" "translation_unit" "true" "try_statement" "type_definition" "type_descriptor" "type_identifier" "type_parameter_declaration" "type_qualifier" "type_requirement" "unary_expression" "union_specifier" "update_expression" "user_defined_literal" "using_declaration" "variadic_declarator" "variadic_parameter" "variadic_parameter_declaration" "variadic_type_parameter_declaration" "virtual" "virtual_specifier" "while_statement") 
)
;; END All node types in cpp
;; START All supertypes in cpp
(defconst combobulate-rules-cpp-supertypes 
 '("_abstract_declarator" "_declarator" "_expression" "_field_declarator" "_statement" "_type_declarator" "_type_specifier") 
)
;; END All supertypes in cpp

;; START Auto-generated list of all languages
(defconst combobulate-rules-languages 
 '(c cpp css go html javascript json jsx python rust toml tsx typescript yaml) 
 "A list of all the languages that have production rules.")
;; END Auto-generated list of all languages
(defconst combobulate-rules-alist 
 `((c ,combobulate-rules-c)
 (cpp ,combobulate-rules-cpp)
 (css ,combobulate-rules-css)
 (go ,combobulate-rules-go)
 (html ,combobulate-rules-html)
 (javascript ,combobulate-rules-javascript)
 (json ,combobulate-rules-json)
 (jsx ,combobulate-rules-jsx)
 (python ,combobulate-rules-python)
 (rust ,combobulate-rules-rust)
 (toml ,combobulate-rules-toml)
 (tsx ,combobulate-rules-tsx)
 (typescript ,combobulate-rules-typescript)
 (yaml ,combobulate-rules-yaml)
))

(defconst combobulate-rules-inverse-alist 
 `((c ,combobulate-rules-c-inverse)
 (cpp ,combobulate-rules-cpp-inverse)
 (css ,combobulate-rules-css-inverse)
 (go ,combobulate-rules-go-inverse)
 (html ,combobulate-rules-html-inverse)
 (javascript ,combobulate-rules-javascript-inverse)
 (json ,combobulate-rules-json-inverse)
 (jsx ,combobulate-rules-jsx-inverse)
 (python ,combobulate-rules-python-inverse)
 (rust ,combobulate-rules-rust-inverse)
 (toml ,combobulate-rules-toml-inverse)
 (tsx ,combobulate-rules-tsx-inverse)
 (typescript ,combobulate-rules-typescript-inverse)
 (yaml ,combobulate-rules-yaml-inverse)
))

(defconst combobulate-rules-types-alist 
 `((c ,combobulate-rules-c-types)
 (cpp ,combobulate-rules-cpp-types)
 (css ,combobulate-rules-css-types)
 (go ,combobulate-rules-go-types)
 (html ,combobulate-rules-html-types)
 (javascript ,combobulate-rules-javascript-types)
 (json ,combobulate-rules-json-types)
 (jsx ,combobulate-rules-jsx-types)
 (python ,combobulate-rules-python-types)
 (rust ,combobulate-rules-rust-types)
 (toml ,combobulate-rules-toml-types)
 (tsx ,combobulate-rules-tsx-types)
 (typescript ,combobulate-rules-typescript-types)
 (yaml ,combobulate-rules-yaml-types)
))

(defconst combobulate-rules-supertypes-alist 
 `((c ,combobulate-rules-c-supertypes)
 (cpp ,combobulate-rules-cpp-supertypes)
 (css ,combobulate-rules-css-supertypes)
 (go ,combobulate-rules-go-supertypes)
 (html ,combobulate-rules-html-supertypes)
 (javascript ,combobulate-rules-javascript-supertypes)
 (json ,combobulate-rules-json-supertypes)
 (jsx ,combobulate-rules-jsx-supertypes)
 (python ,combobulate-rules-python-supertypes)
 (rust ,combobulate-rules-rust-supertypes)
 (toml ,combobulate-rules-toml-supertypes)
 (tsx ,combobulate-rules-tsx-supertypes)
 (typescript ,combobulate-rules-typescript-supertypes)
 (yaml ,combobulate-rules-yaml-supertypes)
))

(provide 'combobulate-rules)
